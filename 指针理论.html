<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>指针理论 - C++程序设计</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="程序的基本组成.html"><strong aria-hidden="true">2.</strong> 程序的基本组成</a></li><li class="chapter-item expanded "><a href="顺序结构程序设计.html"><strong aria-hidden="true">3.</strong> 顺序结构程序设计</a></li><li class="chapter-item expanded "><a href="顺序结构编程题.html"><strong aria-hidden="true">4.</strong> 顺序结构编程题</a></li><li class="chapter-item expanded "><a href="分支结构理论.html"><strong aria-hidden="true">5.</strong> 分支结构理论</a></li><li class="chapter-item expanded "><a href="分支结构程序设计.html"><strong aria-hidden="true">6.</strong> 分支结构程序设计</a></li><li class="chapter-item expanded "><a href="分支结构编程题.html"><strong aria-hidden="true">7.</strong> 分支结构编程题</a></li><li class="chapter-item expanded "><a href="循环结构理论.html"><strong aria-hidden="true">8.</strong> 循环结构理论</a></li><li class="chapter-item expanded "><a href="循环结构程序设计.html"><strong aria-hidden="true">9.</strong> 循环结构程序设计</a></li><li class="chapter-item expanded "><a href="循环结构编程题.html"><strong aria-hidden="true">10.</strong> 循环结构编程题</a></li><li class="chapter-item expanded "><a href="一维数组理论.html"><strong aria-hidden="true">11.</strong> 一维数组理论</a></li><li class="chapter-item expanded "><a href="一维数组程序设计.html"><strong aria-hidden="true">12.</strong> 一维数组程序设计</a></li><li class="chapter-item expanded "><a href="一维数组编程题.html"><strong aria-hidden="true">13.</strong> 一维数组编程题</a></li><li class="chapter-item expanded "><a href="查找及排序算法理论.html"><strong aria-hidden="true">14.</strong> 查找及排序算法理论</a></li><li class="chapter-item expanded "><a href="二维数组理论.html"><strong aria-hidden="true">15.</strong> 二维数组理论</a></li><li class="chapter-item expanded "><a href="二维数组编程题.html"><strong aria-hidden="true">16.</strong> 二维数组编程题</a></li><li class="chapter-item expanded "><a href="字符串理论.html"><strong aria-hidden="true">17.</strong> 字符串理论</a></li><li class="chapter-item expanded "><a href="vector和string程序设计.html"><strong aria-hidden="true">18.</strong> vector和string程序设计</a></li><li class="chapter-item expanded "><a href="字符串编程题.html"><strong aria-hidden="true">19.</strong> 字符串编程题</a></li><li class="chapter-item expanded "><a href="函数理论.html"><strong aria-hidden="true">20.</strong> 函数理论</a></li><li class="chapter-item expanded "><a href="函数编程题.html"><strong aria-hidden="true">21.</strong> 函数编程题</a></li><li class="chapter-item expanded "><a href="指针理论.html" class="active"><strong aria-hidden="true">22.</strong> 指针理论</a></li><li class="chapter-item expanded "><a href="指针编程题.html"><strong aria-hidden="true">23.</strong> 指针编程题</a></li><li class="chapter-item expanded "><a href="结构体理论.html"><strong aria-hidden="true">24.</strong> 结构体理论</a></li><li class="chapter-item expanded "><a href="结构体编程题.html"><strong aria-hidden="true">25.</strong> 结构体编程题</a></li><li class="chapter-item expanded "><a href="类与对象理论.html"><strong aria-hidden="true">26.</strong> 类与对象理论</a></li><li class="chapter-item expanded "><a href="类与对象编程题.html"><strong aria-hidden="true">27.</strong> 类与对象编程题</a></li><li class="chapter-item expanded "><a href="运算符重载理论.html"><strong aria-hidden="true">28.</strong> 运算符重载理论</a></li><li class="chapter-item expanded "><a href="递归、回溯与分治理论.html"><strong aria-hidden="true">29.</strong> 递归、回溯与分治理论</a></li><li class="chapter-item expanded "><a href="递归算法编程题.html"><strong aria-hidden="true">30.</strong> 递归算法编程题</a></li><li class="chapter-item expanded "><a href="枚举和贪心算法编程题.html"><strong aria-hidden="true">31.</strong> 枚举和贪心算法编程题</a></li><li class="chapter-item expanded "><a href="搜索算法编程题.html"><strong aria-hidden="true">32.</strong> 搜索算法编程题</a></li><li class="chapter-item expanded "><a href="动态规划算法编程题.html"><strong aria-hidden="true">33.</strong> 动态规划算法编程题</a></li><li class="chapter-item expanded "><a href="组合和继承理论.html"><strong aria-hidden="true">34.</strong> 组合与继承理论</a></li><li class="chapter-item expanded "><a href="模板和IO理论.html"><strong aria-hidden="true">35.</strong> 模板和IO理论</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="间接访问指针"><a class="header" href="#间接访问指针">间接访问——指针</a></h1>
<ul>
<li><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5">指针的概念</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">变量的内存地址</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">指针变量的定义和初始化</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8">指针的使用</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E4%B8%8E%E6%95%B0%E7%BB%84">指针运算与数组</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">数组的指针基本概念</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0">通过指针引用数组元素</a></li>
</ul>
</li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0">课后练习</a>
<ul>
<li><a href="#%E5%90%8E%E7%BD%AE%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">后置自增运算与数组指针</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">指针变量作为函数参数</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%86%85%E5%AE%B9%E6%AF%94%E8%BE%83%E6%9C%80%E5%90%8E%E8%BE%93%E5%87%BA0%E6%88%961">指针指向内容比较最后输出0或1</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%8D%E8%AE%A8%E8%AE%BA">字符串再讨论</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5">字符串指针的概念</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88%E7%BC%96%E7%A8%8B%E4%B8%BE%E4%BE%8B">字符串指针编程举例</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0">指针与函数</a>
<ul>
<li><a href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">指针作为函数参数</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">数组指针作为函数参数</a></li>
<li><a href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0">返回指针的函数</a></li>
</ul>
</li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-1">课后练习</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E6%9B%B4%E6%94%B9%E6%95%B0%E7%BB%84%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0%E5%80%BC">通过指针更改数组特定元素值</a></li>
<li><a href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9F%90%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6">输出二维字符串中某个字符串的某几个字符</a></li>
<li><a href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E6%94%B9%E5%8F%98%E9%80%A0%E6%88%90%E6%B7%B7%E4%B9%B1%E6%B1%82%E5%8A%A9gpt">全局变量值的改变造成混乱（求助GPT）</a></li>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%8C%87%E9%92%88%E5%92%8C%E4%BA%A4%E6%8D%A2%E5%9C%B0%E5%9D%80">交换指针和交换地址</a></li>
</ul>
</li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0">引用与函数</a>
<ul>
<li><a href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5">引用的概念</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E5%87%BD%E6%95%B0-1">引用与函数</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-1">动态内存分配</a></li>
<li><a href="#%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">深入了解动态内存分配</a></li>
</ul>
</li>
<li><a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84">指针数组</a></li>
<li><a href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88">指向函数的指针</a></li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E6%97%B6%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%83%BD%E5%B4%A9%E6%BA%83%E7%9A%84%E6%83%85%E5%86%B5">总结：使用指针时程序可能崩溃的情况</a></li>
<li><a href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0-2">课后练习</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E5%AD%97%E5%85%B8%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F">字符串按字典顺序排序</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88">函数指针</a></li>
<li><a href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%80%BC%E4%BA%92%E6%8D%A2">指针和值互换</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E4%BA%A4%E6%8D%A2">引用交换</a></li>
</ul>
</li>
</ul>
<h2 id="指针的概念"><a class="header" href="#指针的概念">指针的概念</a></h2>
<h3 id="变量的内存地址"><a class="header" href="#变量的内存地址">变量的内存地址</a></h3>
<p>程序中定义的变量在编译时被系统分配的内存单元，通过地址能找到所需的变量单元，我们可以说，地址指向该变量单元，将地址形象化地称为指针。</p>
<p>要区别内存单元的地址和内存单元的内容</p>
<p>如<code>int i=3; i_pointer=&amp;i; *i_pointer=50;</code>是把i（别名是<code>*i_pointer</code>）的值改为50，通过指针找到变量位置并赋值的存取方式为间接存取。<code>i=3</code>这种直接赋值的方式为直接存取。</p>
<ul>
<li>一个变量的地址称为该变量的指针</li>
<li>如果有一个变量专门用来存放另一个变量的地址（即指针），则它称为指针变量</li>
<li>i_pointer就是一个指针变量，指针变量就是地址变量，用来存放地址的变量，指针变量的值就是地址（即指针）</li>
</ul>
<h3 id="指针变量的定义和初始化"><a class="header" href="#指针变量的定义和初始化">指针变量的定义和初始化</a></h3>
<p>定义指针变量的一般形式为<code>类型 *指针变量名</code>如<code>int *pointer_1,*pointer_2;</code></p>
<ul>
<li>int为指针变量指定的基类型</li>
<li>基类型指定指针类型变量可指向的变量类型</li>
<li>如pointer_1可以指向整型变量，但不能指向浮点型变量</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    float *pointer_3;
    char *pointer_4;
    int a,b;
    int *pointer_1=&amp;a,*pointer_2=&amp;b;
    a=5;
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;
    *pointer_1=4;
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;endl;

}
</code></pre>
<pre><code>a=5
a=4
</code></pre>
<p>使用指针变量在屏幕上显示变量的地址值</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main()
{

    int a=0,b=1;
    char c='A';
    int *pa,*pb;//定义了指针变量pa但pa并未指向a
    char *pc;
    printf(&quot;a is %d, &amp;a is %p, pa is %p\n&quot;,a,&amp;a,pa);
    printf(&quot;b is %d, &amp;b is %p, pb is %p\n&quot;,b,&amp;b,pb);
    printf(&quot;c is %c, &amp;c is %p, pc is %p\n&quot;,c,&amp;c,pc);
    return 0;

}
</code></pre>
<pre><code>a is 0, &amp;a is 000000000073fe04, pa is 0000000000000001
b is 1, &amp;b is 000000000073fe00, pb is 0000000000000000
c is A, &amp;c is 000000000073fdff, pc is 000000000000002d
</code></pre>
<p>说明：没说<code>*pa=&amp;a;</code>，pa,pb,pc的值都是随机值</p>
<p><code>warning: 'pa' is used uninitialized in this function [-Wuninitialized]</code></p>
<p>如果指针指向一个不受控制的内存空间，并对该空间进行访问，将可能造成危险</p>
<p><strong>指针变量使用之前必须被初始化。</strong> Never use uninitialized pointers.</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main()
{

    int a=0,b=1;
    char c='A';
    int *pa,*pb;
    char *pc;
    pa=&amp;a;
    pb=&amp;b;
    pc=&amp;c;
    printf(&quot;a is %d, &amp;a is %p, pa is %p\n&quot;,a,&amp;a,pa);
    printf(&quot;b is %d, &amp;b is %p, pb is %p\n&quot;,b,&amp;b,pb);
    printf(&quot;c is %c, &amp;c is %p, pc is %p\n&quot;,c,&amp;c,pc);
    return 0;

}
</code></pre>
<pre><code>a is 0, &amp;a is 000000000073fe04, pa is 000000000073fe04
b is 1, &amp;b is 000000000073fe00, pb is 000000000073fe00
c is A, &amp;c is 000000000073fdff, pc is 000000000073fdff
</code></pre>
<p>指针要有名字、类型和值。</p>
<p><strong>Pointers have names, types and values.</strong></p>
<h3 id="指针的使用"><a class="header" href="#指针的使用">指针的使用</a></h3>
<p>要熟练应用两个有关的运算符：</p>
<p>（1）&amp; 取地址符</p>
<p>&amp;a  取变量a的地址</p>
<p>（2）<code>*</code>指针运算符（“间接访问”运算符）、</p>
<p>如果：<code>int a=0;int *p=&amp;a;</code>则在接下来的运算中<code>*p</code>代表a</p>
<p><code>k=*p</code>（把a的值赋给k）</p>
<p><code>*p=1;</code>（把1赋给a）引用指针所指向的变量的值，称为指针的解引用（Pointer Dereference）</p>
<p>指针使用</p>
<ul>
<li>指针变量可以指向不同的变量</li>
<li>同类的指针变量之间可相互赋值，表示二个指针指向同一内存空间</li>
<li>空指针不指向任何空间，用常量NULL表示，NULL的值（<code>0,'\0',false</code>）在C++中都被定义为0，不能引用空指针指向的值</li>
</ul>
<p>空指针会崩溃的几种方式：</p>
<ul>
<li><code>int *p=0;*p=3;</code></li>
<li><code>int *p;*p=3;</code></li>
<li><code>int *p=NULL;*p=3;</code></li>
</ul>
<p><strong>比较执行p1=p2和<code>*p1=*p2</code>后的不同结果</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost01/img/20230731114123.png" alt="" /></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    int p1=1;
    int p2=2;
    int *p11=&amp;p1;
    int *p22=&amp;p2;
    cout&lt;&lt;&quot;p1=&quot;&lt;&lt;p1&lt;&lt;endl;
    p1=p2;
    cout&lt;&lt;&quot;p1=&quot;&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;&quot;*p11=&quot;&lt;&lt;*p11&lt;&lt;endl;
    cout&lt;&lt;&quot;*p22=&quot;&lt;&lt;*p22&lt;&lt;endl;
    *p11=*p22;
    cout&lt;&lt;&quot;*p11=&quot;&lt;&lt;*p11&lt;&lt;endl;
    cout&lt;&lt;&quot;*p22=&quot;&lt;&lt;*p22&lt;&lt;endl;
    return 0;

}
</code></pre>
<pre><code>p1=1
p1=2
*p11=2
*p22=2
*p11=2
*p22=2
</code></pre>
<p>指针的初始化</p>
<ul>
<li>指针在使用前必须初始化</li>
<li>和别的变量一样，定义指针而不初始化是一个比较普通的错误</li>
<li>没有初始化的指针可能指向任意地址，对这些指针操作可能会导致程序错误</li>
<li>NULL是一个特殊指针值，称为空指针。它的值为0。它可以被用来初始化一个指针，表示不指向任何地址</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;

int main()
{

    int *p1,*p2,*p,a,b;
    cout&lt;&lt;&quot;Input two integer numbers:&quot;;
    cin&gt;&gt;a&gt;&gt;b;
    p1=&amp;a;
    p2=&amp;b;
    if(a&lt;b)
    {
        p=p1;p1=p2;p2=p;
        //也可以写成p1=&amp;b;p2=&amp;a;
    }
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b=&quot;&lt;&lt;b&lt;&lt;endl;
    cout&lt;&lt;&quot;*p1=&quot;&lt;&lt;*p1&lt;&lt;&quot;,*p2=&quot;&lt;&lt;*p2&lt;&lt;endl;
    return 0;

}
</code></pre>
<pre><code>Input two integer numbers:5 9
a=5,b=9
*p1=9,*p2=5
</code></pre>
<p>说明：</p>
<ul>
<li>a和b的值并未交换，它们仍保持原值</li>
<li>但p1和p2的值互换了</li>
<li>这样在输出<code>*p1和*p2</code>时，实际上是输出变量b和a的值</li>
</ul>
<h2 id="指针运算与数组"><a class="header" href="#指针运算与数组">指针运算与数组</a></h2>
<h3 id="数组的指针基本概念"><a class="header" href="#数组的指针基本概念">数组的指针基本概念</a></h3>
<p>指针和一维数组间的关系</p>
<ul>
<li>每个数组元素都有相应的地址</li>
<li>指针变量可以指向数组元素（把某一元素的地址放到一个指针变量中）</li>
<li>所谓数组元素的指针就是数组元素的地址</li>
</ul>
<pre><code class="language-cpp">int a[10]={1,3,5,7,9,11,13,15,17,19};
int *p;
p=&amp;a[0];//等价于p=a;
</code></pre>
<p>注意：数组名a不代表整个数组，只代表数组首元素的地址</p>
<p><code>p=a;</code>的作用是把a数组的首元素的地址赋给指针变量p，而不是把数组a各元素的值赋给p</p>
<p>也可写成下面这种形式</p>
<pre><code class="language-cpp">int a[10]={1,3,5,7,9,11,13,15,17,19};
int *p=a;//等价于int *p=&amp;a[0];
</code></pre>
<p>在引用数组元素时，指针允许以下的运算：</p>
<ul>
<li>加一个整数如p+1</li>
<li>减一个整数如p-1</li>
<li>自加运算如p++</li>
<li>自减运算如p--</li>
<li>两个指针相减，如p1-p2（只有p1和p2都指向同一数组中的元素时才有意义）</li>
</ul>
<p>（1）如果指针变量p已指向数组中的一个元素，则p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素。</p>
<p>（2）如果p的初值为<code>&amp;a[0]</code>，则p+i和a+i就是数组元素的<code>a[i]</code>的地址，或者说，它们指向a数组序号为i的元素</p>
<p><code>a[i]</code>（也可以写成<code>p[i]</code>）有两个别名：<code>*(p+i)和*(a+i)</code></p>
<p><code>p+i=&amp;a[i];</code></p>
<h3 id="通过指针引用数组元素"><a class="header" href="#通过指针引用数组元素">通过指针引用数组元素</a></h3>
<p>引用一个数组元素可用下面两种方法：</p>
<p>（1）下标法，如<code>a[i]</code>或<code>p[i]</code>形式</p>
<p>（2）指针法，如<code>*(a+i)或*(p+i)</code></p>
<p>其中a是数组名，p是指向数组元素的指针变量，其初值p=a</p>
<p>p和a的区别在于a是常量（数组名）不能执行自增操作，但p是指针变量可以执行自增操作</p>
<p>输出数组元素</p>
<p>（1）通过数组名计算数组元素地址，找出元素的值</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int a[10];
    cout&lt;&lt;&quot;Input 10 integer numbers:\n&quot;;
    for(int i=0;i&lt;10;i++) cin&gt;&gt;a[i];
    for(int i=0;i&lt;10;i++) cout&lt;&lt;*(a+i)&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>
<p>（2）用指针变量指向数组元素（速度较快）</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int a[10];
    int *p;
    cout&lt;&lt;&quot;Input 10 integer numbers:\n&quot;;
    for(int i=0;i&lt;10;i++) cin&gt;&gt;a[i];
    for(p=a;p&lt;(a+10);p++) cout&lt;&lt;*p&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>
<h2 id="课后练习"><a class="header" href="#课后练习">课后练习</a></h2>
<h3 id="后置自增运算与数组指针"><a class="header" href="#后置自增运算与数组指针">后置自增运算与数组指针</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    double a[]={7.1,8.2,9.3,10.5,11.6},*p;
    p=&amp;a[1];
    cout&lt;&lt;*p++&lt;&lt;' ';
    *p++=0;
    cout&lt;&lt;*p;
    //输出结果为8.2 10.5
    for(int i=0;i&lt;5;i++)
        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    //输出结果为7.1 8.2 0 10.5 11.6
    return 0;

}
</code></pre>
<h3 id="指针变量作为函数参数"><a class="header" href="#指针变量作为函数参数">指针变量作为函数参数</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;


int a[8]={1,2,3,4,5,6,7};
void fun(int *pa,int n);

int main()
{

    int m=8;
    fun(a,m);
    cout&lt;&lt;a[7]&lt;&lt;endl;//28

    return 0;

}
void fun(int *pa,int n)
{
    for(int i=0;i&lt;n-1;i++)
        *(pa+7)+=*(pa+i);
}
</code></pre>
<h3 id="指针指向内容比较最后输出0或1"><a class="header" href="#指针指向内容比较最后输出0或1">指针指向内容比较最后输出0或1</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

int main() {
    int a,b,k=8,m=6,n=k;
    int *p1=&amp;k,*p2=&amp;m;
    a=p1==&amp;n;
    cout&lt;&lt;a;//0
    return 0;
}
</code></pre>
<h2 id="字符串再讨论"><a class="header" href="#字符串再讨论">字符串再讨论</a></h2>
<h3 id="字符串指针的概念"><a class="header" href="#字符串指针的概念">字符串指针的概念</a></h3>
<p>字符串的常用表示是指向字符的指针</p>
<p>用法：</p>
<ul>
<li><code>char *String; String = &quot;abcde&quot;;</code></li>
<li><code>char *String, ss[]=&quot;abcdef&quot;; String = ss;</code></li>
</ul>
<p><code>char *String; String = &quot;abcde&quot;;</code>详解：</p>
<ul>
<li>字符串常量存储在内存中称为数据段的区域里，不能修改内容</li>
<li>将存储字符串“abcde”的内存首地址赋给指针变量String</li>
<li>访问限定
<ul>
<li>通过下标读取字符串中的字符比如<code>String[3]</code>的值是<code>'d'</code></li>
<li>不可以通过下标变量赋值，如<code>String[3]='w'</code>会报错</li>
<li>可以直接作为字符串操作函数的参数，但必须注意，如果该指针指向的是一个字符串常量时，则使用是受限的。如不能作为<code>strcpy</code>的第一个参数</li>
</ul>
</li>
</ul>
<p><code>char *String, ss[]=&quot;abcdef&quot;; String = ss;</code>详解</p>
<ul>
<li>字符数组存储在内存中栈区，可以修改内容</li>
</ul>
<p>通过字符指针输出字符串的内容</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    char *string=&quot;I love Chungkuo!&quot;;
    //相等于char *string; string=&quot;I love Chungkuo!&quot;;
    //char string[]=&quot;hello&quot;; string=&quot;I love Chungkuo!&quot;是错误的，数组名即是数组首地址，是个常量
    cout&lt;&lt;string&lt;&lt;endl;
    string=&quot;You love CCP!&quot;;//指针变量可以被重新赋值
    cout&lt;&lt;string&lt;&lt;endl;
    cout&lt;&lt;string+7&lt;&lt;endl;//输出e CCP!
    return 0;

}
</code></pre>
<p>上面的程序中可以给string赋值，但不能更改string里面的字符</p>
<h3 id="字符串指针编程举例"><a class="header" href="#字符串指针编程举例">字符串指针编程举例</a></h3>
<p><code>*(a+i)</code>是<code>a[i]</code>的别名</p>
<p><strong>字符数组实现</strong></p>
<p>下面两个字符串复制程序等价，不能忘了<code>*(b+i)='\0';</code>！</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    char a[]={&quot;Hello Chungkuo&quot;},b[20];
    int i;
    for(i=0;*(a+i)!='\0';i++)
        *(b+i)=*(a+i);
    *(b+i)='\0';
    for(i=0;*(b+i)!='\0';i++)
        cout&lt;&lt;*(b+i);
//输出Hello Chungkuo
    return 0;

}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    char a[]={&quot;Hello Chungkuo&quot;},b[20];
    int i;
    for(i=0;a[i]!='\0';i++)
        b[i]=a[i];
    b[i]='\0';
    cout&lt;&lt;&quot;string a is:&quot;&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;&quot;string b is:&quot;;
    for(i=0;b[i]!='\0';i++)
        cout&lt;&lt;b[i];
    cout&lt;&lt;&quot;\n&quot;;
    return 0;

}
</code></pre>
<p><strong>字符指针实现</strong></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    char a[]=&quot;I am a boy&quot;,b[20],*p1,*p2;
    p1=a;
    p2=b;
    for(;*p1!='\0';p1++,p2++)
        *p2=*p1;
    *p2='\0';
    cout&lt;&lt;&quot;string a is:&quot;&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;&quot;string b is:&quot;&lt;&lt;b&lt;&lt;endl;

    return 0;

}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    char a[]=&quot;I am a boy&quot;,b[20],*p1,*p2;
    p1=a;
    p2=b;
    while(*p1!='\0')//可以简化为while(*p1)
        *p2++=*p1++;//没加括号，先做*p2=*p1，再做p2++，p1++
    *p2='\0';
    cout&lt;&lt;&quot;string a is:&quot;&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;&quot;string b is:&quot;&lt;&lt;b&lt;&lt;endl;

    return 0;

}
</code></pre>
<h2 id="指针与函数"><a class="header" href="#指针与函数">指针与函数</a></h2>
<h3 id="指针作为函数参数"><a class="header" href="#指针作为函数参数">指针作为函数参数</a></h3>
<p>（1）按值调用call by value——普通变量作为函数参数</p>
<p>can not modify the argument. </p>
<p>形参parameter&lt;——实参变量variable</p>
<p>按值调用时，形参值的改变不会影响对应的实参</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


void Fun(int par)
{
    printf(&quot;par=%d\n&quot;,par);
    par=2;
}

int main()
{

    int arg=1;
    printf(&quot;arg=%d\n&quot;,arg);
    Fun(arg);
    printf(&quot;arg=%d\n&quot;,arg);
    return 0;

}
</code></pre>
<pre><code>arg=1
par=1
arg=1
</code></pre>
<p>（2）按地址调用call by reference——指针作为函数参数</p>
<p>In order to modify the argument</p>
<p>指针形参pointer parameter&lt;——&amp;(variable)</p>
<p>按地址调用时，指针变量作函数参数可以修改实参的值</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


void Fun(int *par)
{
    printf(&quot;par=%d\n&quot;,*par);
    *par=2;
}

int main()
{

    int arg=1;
    printf(&quot;arg=%d\n&quot;,arg);
    Fun(&amp;arg);
    printf(&quot;arg=%d\n&quot;,arg);
    return 0;

}
</code></pre>
<pre><code>arg=1
par=1
arg=2
</code></pre>
<p>下面结果的出现是由于函数返回值，和实参值、形参值无关。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


int Fun(int par)
{
    printf(&quot;par=%d\n&quot;,par);
    par=2;
    return par;
}

int main()
{

    int arg=1;
    printf(&quot;arg=%d\n&quot;,arg);
    arg = Fun(arg);
    printf(&quot;arg=%d\n&quot;,arg);
    return 0;

}
</code></pre>
<pre><code>arg=1
par=1
arg=2
</code></pre>
<p>根据交换两个值程序来探究形参和实参的关系，第一个交换不成功，第二个交换成功</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


void swap(int x,int y)
{
    int temp;
    temp=x;
    x=y;
    y=temp;
}

int main()
{

    int a,b;
    a=5;
    b=9;
    swap(a,b);
    printf(&quot;a=%d,b=%d\n&quot;,a,b);//a=5,b=9
    return 0;

}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;


void swap(int *x,int *y)
{
    int temp;//不能写成指针，指针temp未初始化，指向未知区域，对未知单元写操作是危险的
    temp=*x;
    *x=*y;
    *y=temp;
}

int main()
{

    int a,b;
    a=5;
    b=9;
    swap(&amp;a,&amp;b);
    printf(&quot;a=%d,b=%d\n&quot;,a,b);//a=9,b=5
    return 0;

}
</code></pre>
<h3 id="数组指针作为函数参数"><a class="header" href="#数组指针作为函数参数">数组指针作为函数参数</a></h3>
<p>用数组名做函数参数时，实参数组名代表该数组首元素的地址，形参应该是一个指针变量</p>
<p>C++编译器都是将形参数组名作为指针变量来处理的</p>
<p><code>void fun(int arr[], int n)</code>会被解析成<code>void fun(int *arr, int n)</code></p>
<p>实参数组名是指针变量，但形参数组名是按指针变量处理</p>
<p>在函数调用进行虚实结合后，它的值就是实参数组首元素的地址</p>
<p>在函数执行期间，形参数组可以再被赋值</p>
<pre><code class="language-cpp">void fun(int arr[], int n)
{
	cout&lt;&lt;*arr&lt;&lt;endl;
	arr=arr+3;
	cout&lt;&lt;*arr&lt;&lt;endl;
}
</code></pre>
<p><strong>区别指针变量和数组名</strong></p>
<p>数组实现：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{

    void inv(int x[],int n);
    int i,a[10]={3,7,9,11,0,6,7,5,4,2};
    for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    inv(a,10);
    for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    return 0;

}

void inv(int x[],int n)
{
    int temp,i,j,m=(n-1)/2;
    for(i=0;i&lt;=m;i++)
    {
        j=n-1-i;
        temp=x[i];
        x[i]=x[j];
        x[j]=temp;
    }
}
</code></pre>
<pre><code>3 7 9 11 0 6 7 5 4 2
2 4 5 7 6 0 11 9 7 3
</code></pre>
<p>指针+数组实现：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{

    void inv(int x[],int n);
    int i,a[10]={3,7,9,11,0,6,7,5,4,2};
    for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    inv(a,10);
    for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    return 0;

}

void inv(int x[],int n)
{
    int temp,*i,*j;
    i=x;
    j=x+n-1;
    for(;i&lt;j;i++,j--)
    {
        temp=*i;
        *i=*j;
        *j=temp;
    }
}
</code></pre>
<p>改写前例，用指针变量作实参</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{

    void inv(int x[],int n);
    int i,arr[10],*p=arr;
    for(i=0;i&lt;10;i++,p++)
        cin&gt;&gt;*p;
    p=arr;//回到首地址
    inv(p,10);
    for(p=arr;p&lt;arr+10;p++) cout&lt;&lt;*p&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    return 0;

}

void inv(int x[],int n)
{
    int temp,*i,*j;
    i=x;
    j=x+n-1;
    for(;i&lt;j;i++,j--)
    {
        temp=*i;
        *i=*j;
        *j=temp;
    }
}
</code></pre>
<p><strong>字符串作为函数的参数</strong></p>
<ul>
<li>字符串作为函数的参数和数组名作为参数传递一样，可以有两种方法：
<ul>
<li>作为字符数组传递</li>
<li>作为指向字符的指针传递</li>
</ul>
</li>
<li>两种传递方式本质相同，都是传递了字符串的首地址</li>
<li>字符串作为字符数组传递时不需要指定长度，因为字符串操作的结束是依据<code>'\0'</code></li>
</ul>
<p>下面的程序实现了单词计数的功能。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{

    int word_cnt(char *s);
    char sentence[81];
    int num;
    cin.getline(sentence,81);
    num=word_cnt(sentence);
    cout&lt;&lt;&quot;There are&quot;&lt;&lt;&quot; &quot;&lt;&lt;num&lt;&lt;&quot; &quot;&lt;&lt;&quot;words.&quot;&lt;&lt;endl;
    return 0;

}

int word_cnt(char *s)
{
    char prev=' ';
    int num=0;
    while(*s!='\0')
    {
        if(prev==' '&amp;&amp;*s!=' ')
            ++num;
        prev=*s++;
    }
    return num;
}
</code></pre>
<h3 id="返回指针的函数"><a class="header" href="#返回指针的函数">返回指针的函数</a></h3>
<ul>
<li>函数的返回值可以是一个指针</li>
<li>返回指针的函数原型：<code>类型*函数名（形式参数表）</code></li>
<li>当函数的返回值是指针时，返回地址对应的变量不能是局部变量</li>
</ul>
<p>实例：编程实现strcat()的功能</p>
<p>原型设计：<code>char *MyStrcat(char *dstStr, char *srcStr)</code></p>
<p>功能：将srcStr拼接到dstStr后面，将dstStr指针作为函数值返回</p>
<pre><code class="language-cpp">char *MyStrcat(char *dstStr, char *srcStr)
{
    char *pStr=dstStr;//保存字符串首地址指针
    //将指针移到字符串末尾
    while(*dstStr!='\0')
        dstStr++;
    //将字符串2内容复制到字符串1的后面
    for(;*srcStr!='\0';dstStr++,srcStr++)
        *dstStr=*srcStr;
    *dstStr='\0';//在连接后的字符串的末尾添加字符串结束标志
    return pStr;//返回连接后的字符串的指针
}
</code></pre>
<h2 id="课后练习-1"><a class="header" href="#课后练习-1">课后练习</a></h2>
<h3 id="通过指针更改数组特定元素值"><a class="header" href="#通过指针更改数组特定元素值">通过指针更改数组特定元素值</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


void sum(int a[])
{
    a[1]=a[0]+a[2];
}

int main()
{
    int a[10]={1,2,3,4,5,6,7,8,9,10};
    sum(&amp;a[3]);
    cout&lt;&lt;a[4];//10
    return 0;

}

</code></pre>
<h3 id="输出二维字符串中某个字符串的某几个字符"><a class="header" href="#输出二维字符串中某个字符串的某几个字符">输出二维字符串中某个字符串的某几个字符</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;


int main()
{

    char ss[][6]={&quot;while&quot;,&quot;for&quot;,&quot;else&quot;,&quot;break&quot;};
    cout&lt;&lt;ss[3]+1;//reak
    return 0;

}
</code></pre>
<h3 id="全局变量值的改变造成混乱求助gpt"><a class="header" href="#全局变量值的改变造成混乱求助gpt">全局变量值的改变造成混乱（求助GPT）</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int b=2;
int fun(int *k)
{
    b=*k+b;
    return(b);
}

int main()
{

    int a[10]={1,2,3,4,5,6,7,8},i;
    for(i=2;i&lt;4;i++)
    {
        b=fun(a+i)+b;
        cout&lt;&lt;b&lt;&lt;endl;//输出10和28
    }
    return 0;
}
</code></pre>
<pre><code>2
5
10
10
14
28
</code></pre>
<p>非常抱歉给出了错误的回答。让我重新解释为什么最终输出结果为10和28。</p>
<p>在第一次循环中：</p>
<ol>
<li>调用 <code>fun(a+i)</code>，其中 <code>i</code> 的值为 2，因此传递了指向 <code>a[2]</code> 的指针给 <code>fun</code> 函数。</li>
<li>在 <code>fun</code> 函数中，将 <code>a[2]</code> 的值（即 3）与全局变量 <code>b</code> 的值相加，并将结果赋给全局变量 <code>b</code>。此时，<code>b = 3 + 2 = 5</code>。</li>
<li>返回 <code>fun</code> 函数中的结果，即返回全局变量 <code>b</code> 的值（5）。</li>
<li>在 <code>main</code> 函数中，将返回值（5）与全局变量 <code>b</code> 相加，并将结果赋给全局变量 <code>b</code>。此时，<code>b = 5 + 5 = 10</code>。</li>
<li>输出全局变量 <code>b</code> 的值（10）。</li>
</ol>
<p>在第二次循环中：</p>
<ol>
<li>调用 <code>fun(a+i)</code>，其中 <code>i</code> 的值为 3，因此传递了指向 <code>a[3]</code> 的指针给 <code>fun</code> 函数。</li>
<li>在 <code>fun</code> 函数中，将 <code>a[3]</code> 的值（即 4）与全局变量 <code>b</code> 的值相加，并将结果赋给全局变量 <code>b</code>。此时，<code>b = 4 + 10 = 14</code>。</li>
<li>返回 <code>fun</code> 函数中的结果，即返回全局变量 <code>b</code> 的值（14）。</li>
<li>在 <code>main</code> 函数中，将返回值（14）与全局变量 <code>b</code> 相加，并将结果赋给全局变量 <code>b</code>。此时，<code>b = 14 + 14 = 28</code>。</li>
<li>输出全局变量 <code>b</code> 的值（28）。</li>
</ol>
<p>因此，最终输出结果为 10 和 28。我之前的回答有误，对此给您带来的困惑深感抱歉。</p>
<p>这个代码的主要目的是展示了如何在函数中修改全局变量，并且展示了如何使用指针和数组。但是需要注意的是，这个代码的风格并不是很好，因为全局变量的使用增加了代码的复杂性，而且在主函数中也没有初始化所有的数组元素，这可能会引发未定义的行为。</p>
<h3 id="交换指针和交换地址"><a class="header" href="#交换指针和交换地址">交换指针和交换地址</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

void swap2(int *c0, int *c1)
{
    int *t;
    t=c0;
    c0=c1;
    c1=t;
}

int main()
{
    int x=3,y=5,*p=&amp;x,*q=&amp;y;
    swap2(p,q);
    cout&lt;&lt;*p&lt;&lt;*q&lt;&lt;endl;//3,5
    swap2(&amp;x,&amp;y);
    cout&lt;&lt;*p&lt;&lt;*q&lt;&lt;endl;//3,5
    return 0;

}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


void swap1(int *c0, int *c1)
{
    int t;
    t=*c0;
    *c0=*c1;
    *c1=t;
}

void swap2(int *c0, int *c1)
{
    int *t;
    t=c0;
    c0=c1;
    c1=t;
}

int main()
{
    int a[]={1,3,5},b[]={2,4,6};
    swap1(a,a+1);
    swap2(&amp;b[0],&amp;b[1]);
    cout&lt;&lt;a[0]&lt;&lt;a[1]&lt;&lt;b[0]&lt;&lt;b[1];//3124
    return 0;

}
</code></pre>
<h2 id="引用与函数"><a class="header" href="#引用与函数">引用与函数</a></h2>
<h3 id="引用的概念"><a class="header" href="#引用的概念">引用的概念</a></h3>
<p>引用reference是已存在变量的<code>别名</code>alias，通过引用我们可以间接访问变量，指针也能间接访问变量，虽然指针也能间接访问变量，但引用在使用上相对指针<code>更安全</code>。</p>
<p>引用的主要用途是为了描述函数的参数和返回值，特别是为了传递较大的数据变量。</p>
<p>对引用型变量的操作实际上就是对被引用变量的操作。当定义一个引用型变量时，<code>必须</code>用已存在的变量对其初始化，于是引用就被绑定在那个变量上，对于引用的改动就是对它所绑定的变量的改动，反之亦然。</p>
<p>定义一个引用型变量的语法格式为：<code>数据类型&amp;引用变量名=变量名;</code>如<code>int &amp;a=b</code>;</p>
<p>其中：</p>
<ul>
<li>数据类型应与被引用变量的类型相同</li>
<li>&amp;是引用运算符</li>
<li>变量名为已定义的变量</li>
</ul>
<p>例如<code>int x; int &amp;refx=x;</code>中refx是一个引用型变量，它被初始化为对整型变量x的引用</p>
<p>当定义一个引用变量后，系统并没有为它分配内存空间。refx与被引用变量x具有相同的地址，即refx与x使用的是同一内存空间。对引用变量值的修改就是对被引用变量的修改，反之亦然。例如：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;


int main()
{
    int x;
    int &amp;refx=x;
    x=3;
    cout&lt;&lt;refx&lt;&lt;endl;//结果为3
    refx=5;
    cout&lt;&lt;x&lt;&lt;endl;//结果为5
    return 0;

}
</code></pre>
<p>从物理实现上看，引用是一个隐形的指针。引用封装了指针的特性，它不直接操作地址，不能由强制类型转换而得，因而具有较高的安全性，也不容易产生由于使用指针而常常产生得那些不易觉察得错误。</p>
<p>引用使用的注意事项：</p>
<p>（1）定义引用时必须立即对它初始化，不能定义完成后再赋值，如<code>int i;int &amp;j;j=i;</code>是错误的</p>
<p>（2）为引用提供的初始值可以是一个变量或另一个引用。如：<code>int i=5;int &amp;j1=i;int &amp;j2=j1;</code>是正确的</p>
<p>（3）引用不可被重新赋值，不可使其作为另一变量的别名。如<code>int i,k; int &amp;j=i;j=&amp;k;</code>是错误的</p>
<h3 id="引用与函数-1"><a class="header" href="#引用与函数-1">引用与函数</a></h3>
<p>C++引入引用的主要目的是将引用作为函数的参数。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void f(int &amp;r)
{
    cout&lt;&lt;&quot;r= &quot;&lt;&lt;r&lt;&lt;endl;
    cout&lt;&lt;&quot;&amp;r= &quot;&lt;&lt;&amp;r&lt;&lt;endl;
    r=5;
    cout&lt;&lt;&quot;r= &quot;&lt;&lt;r&lt;&lt;endl;
}

int main()
{
    int x=47;
    cout&lt;&lt;&quot;x= &quot;&lt;&lt;x&lt;&lt;endl;
    cout&lt;&lt;&quot;&amp;x= &quot;&lt;&lt;&amp;x&lt;&lt;endl;
    f(x);
    cout&lt;&lt;&quot;x= &quot;&lt;&lt;x&lt;&lt;endl;
    return 0;

}
</code></pre>
<pre><code>x= 47
&amp;x= 0x73fe0c
r= 47
&amp;r= 0x73fe0c
r= 5
x= 5
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int *m, int *n)
{
    int temp;
    temp=*m;
    *m=*n;
    *n=temp;
}


void swap(int m, int n)
{
    int temp;
    temp=m;
    m=n;
    n=temp;
}

void swap1(int &amp;m, int &amp;n)
{
    int temp;
    temp=m;
    m=n;
    n=temp;
}

int main()
{
    int a,b,c,d;
    a=5;b=9;
    c=5;d=9;
    swap(&amp;a,&amp;b);
    cout&lt;&lt;&quot;a=&quot;&lt;&lt;a&lt;&lt;&quot;,b= &quot;&lt;&lt;b&lt;&lt;endl;
    swap(c,d);
    cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;&quot;,d= &quot;&lt;&lt;d&lt;&lt;endl;
    swap1(c,d);
    cout&lt;&lt;&quot;c=&quot;&lt;&lt;c&lt;&lt;&quot;,d= &quot;&lt;&lt;d&lt;&lt;endl;

    return 0;

}
</code></pre>
<pre><code>a=9,b= 5
c=5,d= 9
c=9,d= 5
</code></pre>
<ul>
<li>调用<code>swap1(x,y)</code>时，相当于发生了变量定义<code>int &amp;m=x;int&amp;n=y;</code></li>
<li>即形式参数m和实际参数x共享一块空间，形式参数n和实际参数y共享一块空间，在swap1函数中交换了m和n的值，就相当于交换了x和y的值</li>
</ul>
<p>注意事项：这里的实参必须是变量名而不能是一个表达式</p>
<p><strong>引用作为函数的返回值</strong></p>
<p>函数的返回值类型为引用型，在函数调用时，若接受返回值的是一个引用变量，相当于定义了一个对返回变量的引用。若接受返回值是一个非引用变量，函数返回变量的值赋给接受变量。</p>
<p>如果函数返回值类型为引用型，则要求返回值为左值。这样，函数调用式可以作为左值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int&amp; max(int a[],int n)
{
    int t=0;
    for(int i=0;i&lt;n;i++)
        if(a[i]&gt;a[t]) t=i;
    return a[t];
}

int&amp; sum(int a[],int n)
{
    int s=0;
    for(int i=0;i&lt;n;i++)
        s+=a[i];
    return s;
}


int main()
{
    int a[10]={1,2,3,4,5,6,7,8,9,10};
    int m2=max(a,10);//m2=a[9];
    int &amp;m3=max(a,10);//即int &amp;m3=a[9];
    int &amp;m4=sum(a,10);//返回值s是个局部变量，被释放后，这里输出随机值

    cout&lt;&lt;&quot;m2=&quot;&lt;&lt;m2&lt;&lt;endl;
    cout&lt;&lt;&quot;m3=&quot;&lt;&lt;m3&lt;&lt;endl;
    cout&lt;&lt;&quot;m4=&quot;&lt;&lt;m4&lt;&lt;endl;

    m3+=10;
    max(a,10)-=100;
    cout&lt;&lt;sum(a,10)&lt;&lt;endl;//理论上应该返回-35

    return 0;

}
</code></pre>
<pre><code>m2=10
m3=10

Process returned -1073741819 (0xC0000005)   execution time : 2.989 s
</code></pre>
<p><strong>常引用</strong></p>
<p>如果在定义引用变量时用const修饰，被定义的引用就是常引用。定义常引用的格式如下：</p>
<p><code>const 数据类型 &amp;引用变量=变量名；</code></p>
<p>定义一个常引用后，就不能通过常引用更改引用的变量的值。</p>
<p>例如：<code>int i(100); const int &amp;r=i;</code>当试图用r=200去更改i的值是错误的，但通过i本身可以改变i的值如<code>i=200;</code>此时r的值变为200。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{
    int i(100);
    const int &amp;r=i;
    //r=200;
    //error: assignment of read-only reference 'r'
    i=200;
    cout&lt;&lt;r&lt;&lt;endl;//200

    return 0;

}
</code></pre>
<p>常引用类型常用作函数的形参类型，把形参定义为常引用类型时，这样在函数体内就不能通过形参改变实参的值，保证了函数调用时实参的安全性，这样的形参被称为只读形参。</p>
<pre><code class="language-cpp">void fun(const int&amp; x,int&amp; y)
{
    //x=y;
    //error: assignment of read-only reference 'x'
    
    y=x;
}
</code></pre>
<p>注意：形参为常引用类型时，实参可以是常量、变量表达式；但如果<code>形参不是常引用类型时，实参必须为左值（变量名）</code>。对<code>void fun(const int&amp; x,int&amp; y)</code>，调用<code>fun(100,200)</code>是错误的，调用<code>fun(100,a)</code>是正确的（a为变量）</p>
<h2 id="动态内存分配"><a class="header" href="#动态内存分配">动态内存分配</a></h2>
<h3 id="动态内存分配-1"><a class="header" href="#动态内存分配-1">动态内存分配</a></h3>
<p>在C++中，每个数组有几个元素必须在写程序时就决定。但有时，我们并不知道我们需要多大的数组直到程序开始运行，因此我们希望在程序中根据某一个当前运行值来决定数组的大小。但下面这种写法容易造成溢出问题：</p>
<pre><code class="language-cpp">int n;
cin&gt;&gt;n;
int scores[n];
</code></pre>
<p>这些问题的解决方案就是内存的动态分配。我们定义一个指针，并让它指向一个合适的内存。如<code>int *scores; scores=内存的起始地址；</code></p>
<p><strong>动态内存分配与回收</strong></p>
<ul>
<li>在C语言中，动态内存分配是通过系统函数malloc(), free()和运算符sizeof来实现的。</li>
<li>在C++中，动态内存分配由new和delete两个运算符来实现</li>
</ul>
<p>运算符new用于内存分配：</p>
<ul>
<li>申请动态变量：<code>p=new type;</code></li>
<li>申请动态数组：<code>p=new type[size];</code></li>
<li>申请动态变量并初始化：<code>p=new type(初值);</code></li>
</ul>
<p>运算符delete用于释放new分配的内存：</p>
<ul>
<li>释放动态变量：<code>delete p;</code></li>
<li>释放动态数组：<code>delete []p</code></li>
</ul>
<p>申请动态变量例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;


int main()
{
    //为简单变量动态分配内存并作初始化
    int *p;
    //这里不能写成int p;否则报如下错误
    //error: invalid conversion from 'int*' to 'int' [-fpermissive]
    p=new int;
    cin&gt;&gt;*p;
    cout&lt;&lt;*p&lt;&lt;endl;
    //动态分配内存，并将99作为初始值赋给它
    p=new int(99);
    cout&lt;&lt;*p;//99
    delete p;

    return 0;

}
</code></pre>
<p>申请动态数组例子：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;


int main()
{
    char *q;
    q=new char[10];
    strcpy(q,&quot;abcde&quot;);
    cout&lt;&lt;q&lt;&lt;endl;//abcde
    delete []q;

    return 0;

}
</code></pre>
<p><strong>动态分配的检查</strong></p>
<ul>
<li>new操作的结果是申请到的空间的地址</li>
<li>当系统空间用完时，new操作可能失败</li>
<li>new操作失败时，返回空指针</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
    int *p;
    p=new int;
    if(!p)
    {
        cout&lt;&lt;&quot;allocation failed\n&quot;;
        return 1;
    }
    *p=20;
    cout&lt;&lt;*p;
    delete p;

    return 0;

}
</code></pre>
<p>实例：求学生成绩的均值和均方差</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;


int main()
{
    int *score,num,i;
    double average=0,variance=0;
    cout&lt;&lt;&quot;请输入参加考试的人数：&quot;;
    cin&gt;&gt;num;
    score=new int[num];
    cout&lt;&lt;&quot;请输入成绩：\n&quot;;
    for(i=0;i&lt;num;i++)
        cin&gt;&gt;score[i];
    for(i=0;i&lt;num;i++) average+=score[i];
    average=average/num;
    for(i=0;i&lt;num;i++)
        variance+=(average-score[i])*(average-score[i]);
    variance=sqrt(variance)/num;
    cout&lt;&lt;&quot;平均分是：&quot;&lt;&lt;average&lt;&lt;&quot;\n均方差是：&quot;&lt;&lt;variance&lt;&lt;endl;
    delete []score;

    return 0;

}
</code></pre>
<h3 id="深入了解动态内存分配"><a class="header" href="#深入了解动态内存分配">深入了解动态内存分配</a></h3>
<div class="table-wrapper"><table><thead><tr><th>储存位置</th><th>分配类型</th></tr></thead><tbody>
<tr><td>OS/Program</td><td></td></tr>
<tr><td>数据段</td><td>静态分配</td></tr>
<tr><td>栈</td><td>自动分配</td></tr>
<tr><td>堆</td><td>动态分配</td></tr>
</tbody></table>
</div>
<ul>
<li>全局变量：编译器为它们分配空间，这些空间从程序一开始运行就存在，直到程序结束</li>
<li>自动变量：函数内的局部变量空间是分配在系统的栈工作区。当函数被调用时，空间被分配；当函数执行结束后，空间被释放</li>
<li>动态变量：在程序执行过程中需要新的存储空间时，可用动态分配的方法向系统申请新的空间，当不再使用动态变量时要用显式的方法把空间还给系统。这部分空间是从被称为堆的内存区域分配。</li>
</ul>
<p>自动分配在栈区的数组过大，造成程序不正常运行，有两种解决方法：</p>
<ul>
<li>移动到数据段区域即变成全局数组</li>
<li>移动到堆区即利用动态分配的方法取得足够大的内存空间如<code>char *s; s=new int[5];</code></li>
</ul>
<p><strong>内存泄漏</strong></p>
<ul>
<li>动态变量是通过指针间接访问的。如果该指针被修改，这个区域就被丢弃了。堆管理器认为你在继续使用它们，但你不知道它们在哪里，这被称为内存泄漏。如<code>int *p;p=new int[100];p=new int;</code></li>
<li>为了避免出现孤立的区域，应该明白地告诉堆管理器这些区域不再使用。可以采用delete操作，它释放由new申请的内存。</li>
<li>释放内存对一些程序不重要，但对有些程序很重要。如果你的程序要运行很长时间，而且存在内存泄漏，这样程序会耗尽所有内存，直至程序崩溃。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;

using namespace std;

char *ltrim(char *str)
{
    char *temp=new char[100];
    int i=0,j=0;
    while(str[i]==' ')
        i++;
    while(str[i]!='\0')
        temp[j++]=str[i++];
    temp[j]='\0';
    return temp;
}
//这个函数的功能是删掉字符串左边的空格

int main ()

{
    char *str;
    int i,j;
    for(j=0;i&lt;3;j++)
    {
        cout&lt;&lt;&quot;Press Enter to start&quot;&lt;&lt;j+1&lt;&lt;&quot;round&quot;&lt;&lt;j+1;
        cin.get();
        for(i=0;i&lt;500000;i++)
        {
            str=ltrim(&quot; How are you? &quot;);
            cout&lt;&lt;'.';
            delete [] str;//恢复这条语句则内存不会泄露
        }
    }
    cout&lt;&lt;&quot;Press Enter to finish&quot;;
    cin.get();
    return 0;

}
</code></pre>
<p><strong>delete动态内存注意事项：</strong></p>
<p>（1）释放内存区域之后，堆管理器收回这些区域，而指针仍然指向堆区，但不能再用指针指向这些区域。以下程序错误：</p>
<pre><code class="language-cpp">int *p;
p=new int[10];
delete []p;
*p=1;
</code></pre>
<p>（2）要确保在程序释放且只释放一次。以下程序错误：</p>
<pre><code class="language-cpp">int *p;
p=new int[10];
delete []p;
delete []p;
</code></pre>
<h2 id="指针数组"><a class="header" href="#指针数组">指针数组</a></h2>
<ul>
<li>一个数组的元素都是指针类型数据，称这个数组为指针数组，也就是说，指针数组中的每一个元素都存放一个地址，相当于一个指针变量</li>
<li>定义一维指针数组的一般形式为<code>类型名*数组名[数组长度]；</code>如<code>int* p[4];</code></li>
<li>指针数组比较适合用来只想若干个字符串，是字符串处理更加方便灵活</li>
<li>可以分别定义一些字符串，然后用指针数组中的元素分别指向各字符串</li>
<li>由于各字符串长度一般不相等，所以比用二维数组节省内存单元</li>
</ul>
<p>国名字符串物理排序——二维数组不完全版</p>
<pre><code class="language-cpp">int main ()

{
    char name[N][MAX_LEN];
    
    for(int i=0;i&lt;n-1;i++)
    {
        for(j=i+1;j&lt;n;j++)
        {
            if(strcmp(str[j],str[i])&lt;0)
            {
                strcpy(temp,str[i]);
                strcpy(str[i],str[j]);
                strcpy(str[j],temp);
            }//交换字符串内容
        }
    }
    return 0;

}
</code></pre>
<p>国名字符串索引排序——指针数组实现（利用动态内存分配可以节省内存空间）</p>
<pre><code class="language-cpp">int main ()

{
    char *ptr[N];
    
    for(int i=0;i&lt;n-1;i++)
    {
        for(j=i+1;j&lt;n;j++)
        {
            if(strcmp(ptr[j],ptr[i])&lt;0)
            {
                strcpy(temp,ptr[i]);
                strcpy(ptr[i],ptr[j]);
                strcpy(ptr[j],temp);
            }//交换指针数组中的字符串指针
        }
    }
    return 0;

}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

#define MAX_LEN 10
#define N 150

int main()
{
    int i,n;
    char name[N][MAX_LEN];
    char *pStr[N];
    printf(&quot;How many countries?&quot;);
    scanf(&quot;%d&quot;,&amp;n);
    getchar();
    printf(&quot;Input their names:\n&quot;);
    for(i=0;i&lt;n;i++)
    {
        gets(name[i]);//等同于cin.getline()
        pStr[i]=name[i];//使用指针数组之前，必须对数组元素进行初始化
    }
    SortString(pStr,n);
    printf(&quot;Sorted results:\n&quot;);
    for(i=0;i&lt;n;i++)
    {
        puts(pStr[i]);
    }
    return 0;
}
</code></pre>
<h2 id="指向函数的指针"><a class="header" href="#指向函数的指针">指向函数的指针</a></h2>
<p>函数的指针就是指向函数的指针，指向函数代码的起始地址</p>
<p>定义：<code>返回类型（*指针变量名）（）；</code>两个括号都不能少</p>
<p>赋值：</p>
<pre><code class="language-cpp">int isdigit(int n,int k)
{...}
int (*p)(int,int);
p=isdigit;
</code></pre>
<p>引用：</p>
<pre><code class="language-cpp">a=isdigit(n,k);
a=p(n,k)
//这两种引用方式效果等同
</code></pre>
<p><strong>函数指针及其应用——编写通用性更强的函数</strong></p>
<p>典例1：计算函数的定积分</p>
<p>典例2：既能按照升序排序，又能按照降序排序</p>
<p>普通函数实现方式：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

#define N 40

/*函数功能：输入学生某门课的成绩，当输入负值时，结束输入，返回学生人数*/

int ReadScore(int score[])
{
    int i=-1;
    do
    {
      i++;
      printf(&quot;Input score:&quot;);
      scanf(&quot;%d&quot;,&amp;score[i]);
    }while(score[i]&gt;=0);
    return i;
}
/*函数功能：输出学生成绩*/
void PrintScore(int score[],int n)
{
    int i;
    for(i=0;i&lt;n;i++)
    {
        printf(&quot;%4d&quot;,score[i]);
    }
    printf(&quot;\n&quot;);
}
/*函数功能：选择法实现数组a的升序排序*/
void AscendingSort(int a[],int n)
{
    int i,j,k,temp;
    for(i=0;i&lt;n-1;i++)
    {
        k=i;
        for(j=i+1;j&lt;n;j++)
        {
            if(a[j]&lt;a[k])
                k=j;
        }
        if(k!=i)
        {
            temp=a[k];
            a[k]=a[i];
            a[i]=temp;
        }
    }
}

/*函数功能：选择法实现数组a的降序排序*/
void DescendingSort(int a[],int n)
{
    int i,j,k,temp;
    for(i=0;i&lt;n-1;i++)
    {
        k=i;
        for(j=i+1;j&lt;n;j++)
        {
            if(a[j]&gt;a[k])
                k=j;
        }
        if(k!=i)
        {
            temp=a[k];
            a[k]=a[i];
            a[i]=temp;
        }
    }
}


int main()
{
    int score[N],n;
    int order;//值为1表示升序，值为2表示降序
    n=ReadScore(score);
    printf(&quot;Total students are %d\n&quot;,n);
    printf(&quot;Enter 1 to sort in ascending order,\n&quot;);
    printf(&quot;Enter 2 to sort in descending order,\n&quot;);
    scanf(&quot;%d&quot;,&amp;order);
    printf(&quot;Data items in original order\n&quot;);
    PrintScore(score,n);
    if(order==1)
    {
        AscendingSort(score,n);
        printf(&quot;Data items in ascending order\n&quot;);
    }
    else
    {
        DescendingSort(score,n);
        printf(&quot;Data items in descending order\n&quot;);
    }
    PrintScore(score,n);
    return 0;

}

</code></pre>
<p>函数指针实现：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

#define N 40

/*函数功能：输入学生某门课的成绩，当输入负值时，结束输入，返回学生人数*/

int ReadScore(int score[])
{
    int i=-1;
    do
    {
      i++;
      printf(&quot;Input score:&quot;);
      scanf(&quot;%d&quot;,&amp;score[i]);
    }while(score[i]&gt;=0);
    return i;
}
/*函数功能：输出学生成绩*/
void PrintScore(int score[],int n)
{
    int i;
    for(i=0;i&lt;n;i++)
    {
        printf(&quot;%4d&quot;,score[i]);
    }
    printf(&quot;\n&quot;);
}
/*函数功能：通用的交换法排序*/
void SelectionSort(int a[],int n,int (*compare)(int a,int b))
{
    int i,j,k,temp;
    for(i=0;i&lt;n-1;i++)
    {
        k=i;
        for(j=i+1;j&lt;n;j++)
        {
            if((compare)(a[j],a[k]))//调用函数指针compare指向的函数
                k=j;
        }
        if(k!=i)
        {
            temp=a[k];
            a[k]=a[i];
            a[i]=temp;
        }
    }
}
/*决定数据是否按升序排序，a&lt;b为真，则按升序排序*/
int Ascending(int a,int b)
{
    return a&lt;b;
}
/*决定数据是否按降序排序，a&gt;b为真，则按降序排序*/
int Descending(int a,int b)
{
    return a&gt;b;
}

int main()
{
    int score[N],n;
    int order;//值为1表示升序，值为2表示降序
    n=ReadScore(score);
    printf(&quot;Total students are %d\n&quot;,n);
    printf(&quot;Enter 1 to sort in ascending order,\n&quot;);
    printf(&quot;Enter 2 to sort in descending order,\n&quot;);
    scanf(&quot;%d&quot;,&amp;order);
    printf(&quot;Data items in original order\n&quot;);
    PrintScore(score,n);
    if(order==1)
    {
        SelectionSort(score,n,Ascending);//函数指针指向Ascending()
        printf(&quot;Data items in ascending order\n&quot;);
    }
    else
    {
        SelectionSort(score,n,Descending);//函数指针指向Descending()
        printf(&quot;Data items in descending order\n&quot;);
    }
    PrintScore(score,n);
    return 0;

}
</code></pre>
<pre><code>Input score:81
Input score:82
Input score:83
Input score:84
Input score:85
Input score:-1
Total students are 5
Enter 1 to sort in ascending order,
Enter 2 to sort in descending order,
1
Data items in original order
  81  82  83  84  85
Data items in ascending order
  81  82  83  84  85
</code></pre>
<h2 id="总结使用指针时程序可能崩溃的情况"><a class="header" href="#总结使用指针时程序可能崩溃的情况">总结：使用指针时程序可能崩溃的情况</a></h2>
<p>（1）指针p未赋值就使用<code>*p</code>如<code>int *p;*p=1;</code>或<code>char *str;strcpy(str,&quot;hello&quot;);</code></p>
<p>（2）指针p的值为NULL却使用<code>*p</code>，如<code>int *p=NULL;*p=1;</code></p>
<p>（3）指针p指向动态内存，但该内存已被delete了，再使用<code>*p</code>，如</p>
<pre><code class="language-cpp">int *p;
p=new int[10];
delete []p;
p[0]=1;//即*p=1;
</code></pre>
<p>（4）指针指向动态内存，但该内存被delete两次，如：</p>
<pre><code class="language-cpp">int *p;
p=new int[10];
delete []p;
delete []p;
</code></pre>
<p>（5）指针指向动态数组，但数组在操作时曾经下标越界，然后delete时会崩溃，如：</p>
<pre><code class="language-cpp">int *p;
p=new int[10];
p[10]=1;
delete []p;
</code></pre>
<p>（6）指针指向普通数组，delete时会崩溃，如：</p>
<pre><code class="language-cpp">int a[];
int *p;
p=a;
delete []p;
</code></pre>
<p>（7）指针指向函数内部的局部变量，在程序执行退出函数后使用指针所指向的变量，如：</p>
<pre><code class="language-cpp">int* getMax(int a,int b)
{
	int max=a;
	if(b&gt;a) max=b;
	return &amp;max;
}
int main()
{
	int a=2,b=3,*p;
	p=getMax(a,b);
	cout&lt;&lt;*p;
	return 0;
}
</code></pre>
<p>或：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

char* MyStrcpy(char* srcStr)
{
	char dstStr[100];
	int i;
	for(i=0;srcStr[i]!='\0';i++)
		dstStr[i]=srcStr[i];
	dstStr[i]='\0';
	return dstStr;
}
int main()
{
	char* str;
	str=MyStrcpy(&quot;hello&quot;);//str指向局部变量dstStr的首地址
	cout&lt;&lt;str&lt;&lt;endl;
	return 0;
}
</code></pre>
<p>啥也不输出，说明程序崩溃了。原因在于dstStr是个局部变量在退出函数后就被释放了。</p>
<p>自定义函数返回局部变量地址，程序会崩溃；但返回局部变量值，程序正常运行。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;

int GetMax(int a,int b)
{
    int i=0;
    if(a&gt;b) i++;
    else i--;
    return i;
}
int main()
{
	int a=3,b=4;
	cout&lt;&lt;GetMax(a,b)&lt;&lt;endl;//-1
	return 0;
}
</code></pre>
<h2 id="课后练习-2"><a class="header" href="#课后练习-2">课后练习</a></h2>
<h3 id="字符串按字典顺序排序"><a class="header" href="#字符串按字典顺序排序">字符串按字典顺序排序</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

void f(char *p[],int n)
{
    char *t;
    int i,j;
    for(i=0;i&lt;n-1;i++)
        for(j=i+1;j&lt;n;j++)
        if(strcmp(p[i],p[j])&gt;0)
    {
        t=p[i];
        p[i]=p[j];
        p[j]=t;
    }
}
int main()
{
    char *p[5]={&quot;abc&quot;,&quot;aabdfg&quot;,&quot;abbd&quot;,&quot;dcdbe&quot;,&quot;cd&quot;};
    f(p,5);
    cout&lt;&lt;strlen(p[1]);//4
}
</code></pre>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

float f1(float n)
{
    return n*n;
}
float f2(float n)
{
    return 2*n;
}
int main()
{
    float (*p1)(float),(*p2)(float),(*t)(float),y1,y2;
    p1=f1;
    p2=f2;
    y1=p2(p1(2.0));
    t=p1;
    p1=p2;
    p2=t;
    y2=p2(p1(2.0));
    cout&lt;&lt;y1&lt;&lt;&quot;,&quot;&lt;&lt;y2;//8,16
    return 0;
}
</code></pre>
<h3 id="指针和值互换"><a class="header" href="#指针和值互换">指针和值互换</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{
    int *s1,*s2;
    int m;
    s1=new int;
    *s1=15;
    s2=s1;
    *s2=25;
    m=*s1+*s2;50
    cout&lt;&lt;m;//

    return 0;
}
</code></pre>
<p>这段程序的执行流程如下：</p>
<ol>
<li>首先，程序包含了iostream头文件，以便使用输入输出流。</li>
<li>使用<code>using namespace std;</code>语句引入std命名空间，这样可以直接使用标准库中的函数和对象，而不需要使用全名。</li>
<li>定义了一个main函数，作为程序的入口点，它返回一个整数值。</li>
<li>在main函数中，声明了两个指针变量<code>s1</code>和<code>s2</code>，这里的类型是<code>int*</code>，表示指向整数型数据的指针。</li>
<li>声明了一个整数变量<code>m</code>，用于存储计算结果。</li>
<li>使用<code>new int</code>动态分配了一个整数型的内存空间，并将其地址赋给<code>s1</code>指针。此时，<code>s1</code>指向这个动态分配的整数变量。</li>
<li>通过解引用操作符<code>*s1</code>将数值15存储到<code>s1</code>指向的内存空间中。</li>
<li>将<code>s1</code>的值赋给<code>s2</code>，即让<code>s2</code>指向与<code>s1</code>相同的内存空间。</li>
<li>通过解引用操作符<code>*s2</code>将数值25存储到<code>s2</code>指向的内存空间中。由于<code>s2</code>指向的内存空间与<code>s1</code>相同，所以此操作同时修改了<code>s1</code>指向的内存空间中的值。</li>
<li>计算<code>s1</code>指向的值和<code>s2</code>指向的值的和，并将结果存储到变量<code>m</code>中，即<code>m = *s1 + *s2</code>，结果为50。</li>
<li>执行<code>cout&lt;&lt;m;</code>语句，将变量<code>m</code>的值输出到标准输出流，结果为&quot;50&quot;。</li>
<li><code>return 0;</code>语句表示程序正常结束，并返回0作为退出代码。</li>
</ol>
<p>因此，程序最终的输出结果是&quot;50&quot;。</p>
<pre><code>0x73fe10
0x73fe08
50
</code></pre>
<h3 id="引用交换"><a class="header" href="#引用交换">引用交换</a></h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int p1,int &amp;p2)
{
    int p;
    p=p1;
    p1=p2;
    p2=p;
}
int main()
{
    int a=5,b=8;
    swap(a,b);
    cout&lt;&lt;a&lt;&lt;b;//55
    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int p1,int &amp;p2)
{
    int p;
    p=p1;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
    p1=p2;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
    p2=p;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
}


int main()
{
    int a=5,b=8;
    swap(a,b);
    cout&lt;&lt;a&lt;&lt;b;//55


    return 0;
}

</code></pre>
<pre><code>5
5
8
5
8
8
5
8
5
55
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void swap(int &amp;p1,int &amp;p2)
{
    int p;
    p=p1;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
    p1=p2;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
    p2=p;
    cout&lt;&lt;p&lt;&lt;endl;
    cout&lt;&lt;p1&lt;&lt;endl;
    cout&lt;&lt;p2&lt;&lt;endl;
}


int main()
{
    int a=5,b=8;
    swap(a,b);
    cout&lt;&lt;a&lt;&lt;b;//55


    return 0;
}
</code></pre>
<pre><code>5
5
8
5
8
8
5
8
5
85
</code></pre>
<pre><code class="language-cpp">void swap1(int &amp;m, int &amp;n)
{
    int temp;
    temp=m;
    m=n;
    n=temp;
}
</code></pre>
<p>这个函数的作用是交换两个整数变量的值。</p>
<p>函数<code>swap1</code>接受两个整数的引用作为参数<code>m</code>和<code>n</code>，这意味着传递给函数的是变量的引用而不是值，函数内部对这些引用进行操作会直接影响到原始变量。</p>
<p>在函数内部，创建了一个临时变量<code>temp</code>，用于存储变量<code>m</code>的值。
然后，将变量<code>m</code>的值赋给变量<code>n</code>，将变量<code>n</code>的值赋给变量<code>m</code>，以完成两个变量值的交换。
最后，函数执行完毕，交换操作对原始变量产生了影响。</p>
<p>通过调用这个函数并传递两个整数变量的引用作为参数，可以实现对这两个变量值进行交换的操作，而无需借助额外的中间变量。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="函数编程题.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="指针编程题.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="函数编程题.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="指针编程题.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
