<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>vector类程序设计 - C++语言程序设计</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="程序的基本组成.html"><strong aria-hidden="true">2.</strong> 程序的基本组成</a></li><li class="chapter-item expanded "><a href="顺序结构程序设计.html"><strong aria-hidden="true">3.</strong> 顺序结构程序设计</a></li><li class="chapter-item expanded "><a href="顺序结构编程题.html"><strong aria-hidden="true">4.</strong> 顺序结构编程题</a></li><li class="chapter-item expanded "><a href="分支结构理论.html"><strong aria-hidden="true">5.</strong> 分支结构理论</a></li><li class="chapter-item expanded "><a href="分支结构程序设计.html"><strong aria-hidden="true">6.</strong> 分支结构程序设计</a></li><li class="chapter-item expanded "><a href="分支结构编程题.html"><strong aria-hidden="true">7.</strong> 分支结构编程题</a></li><li class="chapter-item expanded "><a href="循环结构理论.html"><strong aria-hidden="true">8.</strong> 循环结构理论</a></li><li class="chapter-item expanded "><a href="循环结构程序设计.html"><strong aria-hidden="true">9.</strong> 循环结构程序设计</a></li><li class="chapter-item expanded "><a href="循环结构编程题.html"><strong aria-hidden="true">10.</strong> 循环结构编程题</a></li><li class="chapter-item expanded "><a href="一维数组理论.html"><strong aria-hidden="true">11.</strong> 一维数组理论</a></li><li class="chapter-item expanded "><a href="一维数组程序设计.html"><strong aria-hidden="true">12.</strong> 一维数组程序设计</a></li><li class="chapter-item expanded "><a href="一维数组编程题.html"><strong aria-hidden="true">13.</strong> 一维数组编程题</a></li><li class="chapter-item expanded "><a href="查找及排序算法理论.html"><strong aria-hidden="true">14.</strong> 查找及排序算法理论</a></li><li class="chapter-item expanded "><a href="二维数组理论.html"><strong aria-hidden="true">15.</strong> 二维数组理论</a></li><li class="chapter-item expanded "><a href="二维数组编程题.html"><strong aria-hidden="true">16.</strong> 二维数组编程题</a></li><li class="chapter-item expanded "><a href="字符串理论.html"><strong aria-hidden="true">17.</strong> 字符串理论</a></li><li class="chapter-item expanded "><a href="字符串编程题.html"><strong aria-hidden="true">18.</strong> 字符串编程题</a></li><li class="chapter-item expanded "><a href="函数理论.html"><strong aria-hidden="true">19.</strong> 函数理论</a></li><li class="chapter-item expanded "><a href="函数编程题.html"><strong aria-hidden="true">20.</strong> 函数编程题</a></li><li class="chapter-item expanded "><a href="指针理论.html"><strong aria-hidden="true">21.</strong> 指针理论</a></li><li class="chapter-item expanded "><a href="结构体理论.html"><strong aria-hidden="true">22.</strong> 结构体理论</a></li><li class="chapter-item expanded "><a href="结构体编程题.html"><strong aria-hidden="true">23.</strong> 结构体编程题</a></li><li class="chapter-item expanded "><a href="组合体和枚举类型理论.html"><strong aria-hidden="true">24.</strong> 组合体和枚举类型理论</a></li><li class="chapter-item expanded "><a href="任务自动化——预处理.html"><strong aria-hidden="true">25.</strong> 任务自动化——预处理理论</a></li><li class="chapter-item expanded "><a href="类与对象理论.html"><strong aria-hidden="true">26.</strong> 类与对象理论</a></li><li class="chapter-item expanded "><a href="类与对象编程题.html"><strong aria-hidden="true">27.</strong> 类与对象编程题</a></li><li class="chapter-item expanded "><a href="运算符重载理论.html"><strong aria-hidden="true">28.</strong> 运算符重载理论</a></li><li class="chapter-item expanded "><a href="递归、回溯与分治理论.html"><strong aria-hidden="true">29.</strong> 递归、回溯与分治理论</a></li><li class="chapter-item expanded "><a href="递归算法编程题.html"><strong aria-hidden="true">30.</strong> 递归算法编程题</a></li><li class="chapter-item expanded "><a href="枚举和贪心算法编程题.html"><strong aria-hidden="true">31.</strong> 枚举和贪心算法编程题</a></li><li class="chapter-item expanded "><a href="搜索算法编程题.html"><strong aria-hidden="true">32.</strong> 搜索算法编程题</a></li><li class="chapter-item expanded "><a href="动态规划算法编程题.html"><strong aria-hidden="true">33.</strong> 动态规划算法编程题</a></li><li class="chapter-item expanded "><a href="组合与继承理论.html"><strong aria-hidden="true">34.</strong> 组合与继承理论</a></li><li class="chapter-item expanded "><a href="类模板理论.html"><strong aria-hidden="true">35.</strong> 类模板理论</a></li><li class="chapter-item expanded "><a href="IO理论.html"><strong aria-hidden="true">36.</strong> IO理论</a></li><li class="chapter-item expanded "><a href="STL理论.html"><strong aria-hidden="true">37.</strong> STL理论</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vector类程序设计.html" class="active"><strong aria-hidden="true">37.1.</strong> vector类程序设计</a></li><li class="chapter-item expanded "><a href="string类程序设计.html"><strong aria-hidden="true">37.2.</strong> string类程序设计</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++语言程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="vector类程序设计"><a class="header" href="#vector类程序设计">vector类程序设计</a></h1>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84vector">动态数组vector</a>
<ul>
<li><a href="#vector%E4%BB%8B%E7%BB%8D">vector介绍</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAvector%E5%AF%B9%E8%B1%A1">创建vector对象</a></li>
<li><a href="#push_back%E5%B0%BE%E9%83%A8%E6%8F%92%E5%85%A5">push_back尾部插入</a></li>
<li><a href="#%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C">遍历操作</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
<li><a href="#vector%E5%85%B6%E5%AE%83%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C">vector其它常用操作</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4vector">二维vector</a></li>
</ul>
</li>
</ul>
<h2 id="动态数组vector"><a class="header" href="#动态数组vector">动态数组vector</a></h2>
<h3 id="vector介绍"><a class="header" href="#vector介绍">vector介绍</a></h3>
<p>vector是一个容器，能存放各种类型的数据，包括简单类型如int、double、char或自定义的结构体类型或类类型，简单地说，vector是一个能够存放任意类型的动态数组，可以动态改变大小。</p>
<p>在C++中，<code>std::vector</code>是标准模板库（STL）提供的动态数组容器，它能够自动调整大小以适应元素的添加和删除操作。<code>std::vector</code>提供了与普通数组类似的访问方式，同时还提供了一系列方便的成员函数和操作符重载来简化数组的操作。</p>
<p>要使用<code>std::vector</code>，首先需要包含头文件<code>&lt;vector&gt;</code>。</p>
<p>下面是一些常见的 <code>std::vector</code> 操作示例：</p>
<ol>
<li>创建一个空的 <code>std::vector</code>：</li>
</ol>
<pre><code class="language-cpp">std::vector&lt;int&gt; myVector;//也可以创建一个初始大小为10的动态数组vector&lt;int&gt; nums(10);
</code></pre>
<ol start="2">
<li>在 <code>std::vector</code> 中添加元素：</li>
</ol>
<pre><code class="language-cpp">myVector.push_back(10);  // 向尾部添加元素
myVector.push_back(20);
myVector.push_back(30);
</code></pre>
<ol start="3">
<li>获取 <code>std::vector</code> 的大小（元素个数）：</li>
</ol>
<pre><code class="language-cpp">int size = myVector.size();
</code></pre>
<ol start="4">
<li>访问 <code>std::vector</code> 中的元素：</li>
</ol>
<pre><code class="language-cpp">int element = myVector[index];  // 使用下标访问元素
</code></pre>
<ol start="5">
<li>修改 <code>std::vector</code> 中的元素：</li>
</ol>
<pre><code class="language-cpp">myVector[index] = newValue;
</code></pre>
<ol start="6">
<li>迭代遍历 <code>std::vector</code> 中的元素：</li>
</ol>
<pre><code class="language-cpp">for (const auto&amp; element : myVector) {
    // 使用 element 进行操作
}
</code></pre>
<ol start="7">
<li>删除 <code>std::vector</code> 中的元素：</li>
</ol>
<pre><code class="language-cpp">myVector.pop_back();  // 删除尾部元素
</code></pre>
<ol start="8">
<li>清空 <code>std::vector</code> 中的所有元素：</li>
</ol>
<pre><code class="language-cpp">myVector.clear();
</code></pre>
<p><code>std::vector</code> 还提供了许多其他的成员函数和操作符重载，用于插入、删除、查找等操作，以及获取容量、判断是否为空等功能。可以查阅C++的文档或参考教程来获取更详细的信息和示例。</p>
<p>需要注意的是，<code>std::vector</code> 是动态数组，它会在需要时自动调整大小，但这可能会导致内存重新分配和元素复制，因此在需要频繁添加或删除元素的情况下，可能会影响性能。</p>
<h3 id="创建vector对象"><a class="header" href="#创建vector对象">创建vector对象</a></h3>
<p>（1）<code>vector&lt;T&gt; v</code>：创建空的vector</p>
<p>（2）<code>vector&lt;T&gt; v(n)</code>：创建一个大小为n的vector，每个元素具有默认值</p>
<p>（3）<code>vector&lt;T&gt; v(n,e）</code>：创建一个大小为n的vector，每个元素都是e</p>
<p>（4）<code>vector&lt;T&gt; v2(v1)</code>：创建同类型的v2，并将拷贝v1的所有元素如<code>vector&lt;char&gt; v1(5,'a');vector&lt;char&gt; v2(v1);</code></p>
<p>（5）<code>vector&lt;T&gt; v(begin,end)</code>：创建一个vector，以区间<code>[begin,end)</code>为元素初值</p>
<p>begin作为一个迭代器（或者说指针），通过拷贝迭代器区间<code>[begin,end)</code>的元素值（不包括end所指向的元素），创建一个新的vector对象。例如下面的代码利用int数组iArray各元素值，创建了vector对象。</p>
<pre><code class="language-cpp">int iArray[]={11,13,19,23,27};
vector&lt;int&gt; v(iArray,iArray+3);
</code></pre>
<p>代码将<code>iArray[0]</code>到<code>iArray[2]</code>拷贝到vector对象v中，从而v中有三个元素。</p>
<p>注意：</p>
<p>如果vector中存放的元素类型是类，并且数据成员有动态生成的、存在深拷贝的问题的话，这个时候该类必须具有拷贝构造函数，否则在vector的创建、插入等拷贝的过程中会发生错误。</p>
<p>比如有以下类声明：</p>
<pre><code class="language-cpp">class student 
{
private:
    int ID;
    char *name;
public:
    student(char* n)
    {
        name = new char[strlen(n)+1];
        strcpy(name,n);
    }
};
</code></pre>
<p>该类没有拷贝构造函数，不可放到vector容器中。</p>
<p>由于该类中的name需要在构造函数中<code>动态生成</code>，所以存在深拷贝问题。如果class student没有声明拷贝构造函数（如上的代码），则<code>vector&lt;student&gt; v;</code>创建出来的vector在使用的过程中会发生错误。</p>
<p>如前所述，student类应该声明拷贝构造函数、析构函数、重载赋值运算符。</p>
<p>C++11增加了定义时初始化的操作如下：</p>
<pre><code class="language-cpp">vector&lt;int&gt; month={1,2,3,4,5};
//也可以去掉等号如下：
vector&lt;int&gt; month {1,2,3,4,5};
</code></pre>
<h3 id="push_back尾部插入"><a class="header" href="#push_back尾部插入">push_back尾部插入</a></h3>
<p>在 <code>std::vector</code> 中添加元素：</p>
<pre><code class="language-cpp">myVector.push_back(10);  // 向尾部添加元素
myVector.push_back(20);
myVector.push_back(30);
</code></pre>
<p>push_back操作不会造成溢出。当vector已经装满时，它会自动扩充容量。</p>
<h3 id="遍历操作"><a class="header" href="#遍历操作">遍历操作</a></h3>
<p>（1）基于下标的遍历</p>
<p><code>v.at(idx)</code>函数也能获取某下标处的元素，at函数会进行越界检查，如果下标越界，将抛出异常。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v(3);
    v.push_back(3);
    v.push_back(10);
    v.push_back(19);
    for(int i=0;i&lt;v.size();i++)
        cout&lt;&lt;v.at(i)&lt;&lt;&quot; &quot;;//cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;

    return 0;
}
</code></pre>
<pre><code>0 0 0 3 10 19
</code></pre>
<p>（2）基于范围的for循环</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v(3);
    v.push_back(3);
    v.push_back(10);
    v.push_back(19);
    for(auto elem:v)//for(int elem:v)
        cout&lt;&lt;elem&lt;&lt;&quot; &quot;;

    return 0;
}

</code></pre>
<p>注意：使用范围的for循环，elem是从v中复制出来的元素，所以不能修改v中的值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v(3);
    v.push_back(3);
    v.push_back(10);
    v.push_back(19);
    for(auto elem:v)
        elem+=2;
    for(auto elem:v)
        cout&lt;&lt;elem&lt;&lt;&quot; &quot;;//0 0 0 3 10 19

    return 0;
}
</code></pre>
<p>此时需要使用引用。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v(3);
    v.push_back(3);
    v.push_back(10);
    v.push_back(19);
    for(auto &amp;elem:v)
        elem+=2;
    for(auto elem:v)
        cout&lt;&lt;elem&lt;&lt;&quot; &quot;;//2 2 2 5 12 21

    return 0;
}
</code></pre>
<p>实际上，为了提高程序执行效率，避免元素的拷贝，通常使用引用，代码模板如下：</p>
<pre><code class="language-cpp">for(auto &amp;elem:v)
        //对elem进行处理
</code></pre>
<h3 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h3>
<p>迭代器是一种检查容器内元素并遍历元素的数据类型。C++更趋向于使用迭代器而不是下标操作，因为标准库为每一种标准容器如vector定义了一种迭代器类型，而只有少数容器如vector支持下标操作访问容器元素。</p>
<p>（1）<strong>定义和初始化</strong></p>
<p>每种容器都定义了自己的迭代器类型如vector：</p>
<p><code>vector&lt;int&gt;::iterator iter1;</code>定义一个名为iter1的迭代器变量</p>
<p><code>vector&lt;int&gt;::reverse_iterator iter2;</code>定义一个名为iter2的逆向迭代器变量</p>
<p>每种容器都定义了一对名为begin和end的函数，用于返回迭代器。部分容器如vector还定义了一对名为rbegin和rend的函数用于返回逆向迭代器。各函数的功能如下表：</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody>
<tr><td>begin()</td><td>返回一个迭代器，指向第一个元素</td></tr>
<tr><td>end()</td><td>返回一个迭代器，指向最后一个元素之后</td></tr>
<tr><td>rbegin()</td><td>返回一个逆向迭代器，指向逆向遍历的第一个元素，即容器的最后一个元素</td></tr>
<tr><td>rend()</td><td>返回一个逆向迭代器，指向逆向遍历的最后一个元素之后，即容器的第一个元素之前</td></tr>
</tbody></table>
</div>
<p>下面对迭代器进行初始化操作：</p>
<pre><code class="language-cpp">vector&lt;int&gt; v(10);
vector&lt;int&gt;::iterator iter1=v.begin();//将迭代器iter1初始化为指向v的第一个元素

vector&lt;int&gt;::reverse_iterator iter2=v.end();//将迭代器iter2初始化为指向v的最后一个元素的下一个位置
</code></pre>
<p>注意end并不指向容器的任何元素，而是指向容器的最后元素的下一位置，称为超出末端迭代器，如果vector为空，则begin返回的迭代器和end返回的迭代器相同。一旦向上面这样定义和初始化，就相当于把该迭代器和容器进行了某种关联，就像把一个指针初始化为指向数组的某一个元素一样。</p>
<p>（2）<strong>常用操作</strong></p>
<p>对于vector和string等少数容器，我们可以将迭代器理解成数组的指针，因此具有下面的常用操作：</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody>
<tr><td><code>*iter</code></td><td>对iter进行解引用，返回迭代器iter指向的元素的引用</td></tr>
<tr><td>iter-&gt;men</td><td>对iter进行解引用，获取指定元素中名为men的成员，等价于<code>(*iter).men</code></td></tr>
<tr><td>++iter</td><td>给iter加一，使其指向容器的下一个元素</td></tr>
<tr><td>iter--</td><td>给iter减一，使其指向容器的前一个元素</td></tr>
<tr><td><code>iter1==iter2</code></td><td>比较两个迭代器是否相等，当它们指向同一个容器的同一个元素或者都指向都一个容器的超出末端的下一个位置时，它们相等</td></tr>
<tr><td>iter+n</td><td>在迭代器上加整数n，将产生指向容器中后面第n各元素的迭代器，新计算出来的迭代器必须指向容器中的元素或超出容器末端的下一个元素</td></tr>
<tr><td><code>iter[n]</code></td><td>相当于<code>*(iter+n)</code></td></tr>
<tr><td>iter1-iter2</td><td>两个迭代器相减，得出两个迭代器的距离，两个迭代器必须指向容器中的元素或超出容器末端的下一个元素</td></tr>
<tr><td>!=、&lt;=</td><td>元素靠后的迭代器大于靠前的迭代器，两个迭代器必须指向同一个容器中的元素或超出容器末端的下一个元素</td></tr>
</tbody></table>
</div>
<p>假设已经声明<code>vector&lt;int&gt; v</code>，下面用迭代器来遍历v容器，把每个元素加2：</p>
<pre><code class="language-cpp">for(vector&lt;int&gt;::iterator iter=v.begin();iter!=v.end();++iter)
        *iter+=2;
</code></pre>
<p>由于迭代器的类型写起来很复杂，我们也可以使用auto简化如下：</p>
<pre><code class="language-cpp">for(auto iter=v.begin();iter!=v.end();++iter)
        *iter+=2;
</code></pre>
<p>这里再看一个简单的例子——用迭代器算术操作来移动迭代器直接指向某个元素：</p>
<pre><code class="language-cpp">vector&lt;int&gt;::iterator mid=v.begin()+v.size()/2;
</code></pre>
<p>以上语句初始化mid迭代器，使其指向v中最靠近正中间的元素。</p>
<p>从这些运算可以看出，将迭代器看成数组的指针，理解起来非常容易。</p>
<p>（3）<strong>reverse_iterator</strong></p>
<p>下面代码是现在vector中查找最后一个等于3的元素并将它修改为0</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v(10,3);
    v.push_back(8);
    v.push_back(9);
    v.push_back(10);
    for(vector&lt;int&gt;::reverse_iterator iter=v.rbegin();iter!=v.rend();++iter)
    {
        if(*iter==3)
        {
            *iter=0;
            break;
        }
    }
    for(auto elem:v)
        cout&lt;&lt;elem&lt;&lt;&quot; &quot;;
    return 0;
}
</code></pre>
<pre><code>3 3 3 3 3 3 3 3 3 0 8 9 10
</code></pre>
<p>需要注意的是，对于reverse_iterator类型的iter，++iter使得指针往前移动。</p>
<p>（4）<strong>const_iterator</strong></p>
<p>每种容器都定义了一种名为const_iterator的类型。该类型的迭代器只能读取容器中的元素，不能用于改变其值。之前的例子中，普通迭代器可以对容器中的元素进行解引用并修改，但const_iterator类型的迭代器只能用于读不能进行重写。例如可以进行如下操作：</p>
<pre><code class="language-cpp">for(vector&lt;int&gt;::const_iterator iter=v.begin();iter!=v.end();++iter)
	cout&lt;&lt;*iter&lt;&lt;endl;//合法读取容器中元素值
</code></pre>
<pre><code class="language-cpp">for(vector&lt;int&gt;::const_iterator iter=v.begin();iter!=v.end();++iter)
	*iter=0;//不合法，不能进行写操作
</code></pre>
<p>const_iterator和const iterator不一样，后者是一个常量，对迭代器进行声明时，必须对迭代器进行初始化，并且不能修改迭代器的值。<strong>而const_iterator生命的迭代器可以修改迭代器自身的值，但是不能通过修改它修改vector的元素的值。这有点像常量指针和指针常量的关系。</strong> 例如</p>
<pre><code class="language-cpp">vector&lt;int&gt; ivec(10);
const vector&lt;int&gt;::iterator iter=v.begin();
*iter=0;//合法，可以改变其指向的元素的值
++iter;//不合法，无法改变其指向的位置
</code></pre>
<p>对于const类型的容器，必须使用const_iterator，而不能使用iterator。比如：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void print(const vector&lt;int&gt;&amp;v)
{
    for(vector&lt;int&gt;::const_iterator iter=v.begin();iter!=v.end();++iter)
        cout&lt;&lt;*iter&lt;&lt;&quot; &quot;;
}

int main() {
    vector&lt;int&gt; v;
    v.push_back(8);
    v.push_back(9);
    v.push_back(10);
    print(v);//8 9 10

    return 0;
}
</code></pre>
<p>（5）<strong>能使迭代器失效的操作</strong></p>
<p>由于一些对容器的操作如删除元素或插入元素等会修改容器的内在状态，这会使得原来的迭代器失效，也可能同时是其他迭代器失效。使用无效的迭代器是没有定义的，可能会导致和使用野指针相同的问题。所以在使用迭代器编写程序时，需要特别留意哪些操作会使迭代器失效。使用无效迭代器会导致严重的运行时错误。</p>
<p>比如下面的函数删除vector中所有的元素3，其中erase函数将使得迭代器iter失效：</p>
<pre><code class="language-cpp">void delete1(vector&lt;int&gt;&amp;v, int num)
{
    for(vector&lt;int&gt;::iterator iter=v.begin();iter!=v.end();)
    {
        if(*iter==num)
            iter=v.erase(iter);//一定要将返回的迭代器赋值给iter
        else
            ++iter;
    }
}
</code></pre>
<p>代码中，执行v.erase(iter)后，iter可能指向不明确，也即迭代器失效，从而后续的操作可能发生错误，但不是必然发生错误，所以要特别注意。</p>
<p>因此需要将函数erase的返回值再赋给iter，语句为<code>iter=v.erase(iter);</code>，使得iter指向被删除元素的下一个元素，这样，循环可以继续正常进行。</p>
<h3 id="vector其它常用操作"><a class="header" href="#vector其它常用操作">vector其它常用操作</a></h3>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>效果</th></tr></thead><tbody>
<tr><td>v.size()</td><td>返回元素个数</td></tr>
<tr><td>v.empty()</td><td>判断容器是否为空，为空返回true</td></tr>
<tr><td>v1=v2</td><td>将v2的全部元素赋值给v1</td></tr>
<tr><td>v.assign(n,e)</td><td>将元素e的n个拷贝赋值给v如<code>v.assign(2,2);</code></td></tr>
<tr><td>v.assign(beg,end)</td><td>讲区间<code>[beg,end)</code>的元素赋值给v如<code>v2.assign(v1.begin()+1,v1.begin()+4);</code></td></tr>
<tr><td>v1.swap(v2)</td><td>互换v1和v2的元素</td></tr>
<tr><td>v.at(idx)</td><td>返回索引idx所标识的元素的引用，进行越界检查，如果越界会抛出异常</td></tr>
<tr><td><code>v[idx]</code></td><td>返回索引idx所标识的元素的引用，不进行越界检查</td></tr>
<tr><td>v.front()</td><td>返回第一个元素的引用，不检查元素是否存在，如<code>v.front()=10;</code>修改第0个元素</td></tr>
<tr><td>v.back()</td><td>返回最后一个元素的引用，不检查元素是否存在</td></tr>
<tr><td>v.insert(pos,e)</td><td>在pos位置插入元素e的副本，并指向插入的第一个元素</td></tr>
<tr><td>v.insert(pos,n,e)</td><td>在pos位置插入n个元素e的副本，并指向插入的第一个元素</td></tr>
<tr><td>v.insert(pos,begin,end)</td><td>在pos位置插入区间<code>[begin,end)</code>内所有元素的副本，并指向pos</td></tr>
<tr><td>v.pop_back()</td><td>移除最后一个元素，但不返回最后一个元素</td></tr>
<tr><td>v.erase(pos)</td><td>删除pos位置的元素，返回下一个元素的位置</td></tr>
<tr><td>v.erase(begin,end)</td><td>删除区间<code>[begin,end)</code>的元素，返回下一个元素的位置</td></tr>
<tr><td>v.clear()</td><td>移除所有元素，清空容器</td></tr>
<tr><td>v.resize(num)</td><td>将元素数量改为num（增加的元素用default构造函数产生，多余的元素被删除）</td></tr>
<tr><td>v.resize(num,e)</td><td>将元素数量改为num（增加的元素是e的副本）</td></tr>
</tbody></table>
</div>
<p>insert操作实例</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; v;
    v.push_back(8);
    v.push_back(9);
    v.push_back(10);
    vector&lt;int&gt;::iterator iter=v.insert(v.begin()+1,8);
    //vector&lt;int&gt;::iterator iter=v.insert(v.begin()+1,5,8);
    //vector&lt;int&gt; v1={1,2,3,4};
    //vector&lt;int&gt;::iterator iter=v.insert(v.begin()+1,8);
    cout&lt;&lt;iter-v.begin()&lt;&lt;endl;//1

    return 0;
}
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int main() {
    vector&lt;int&gt; v2={10,20,30,40};
    
    vector&lt;int&gt; v1={1,2,3,4};
    vector&lt;int&gt;::iterator iter=v2.insert(v2.begin()+1,v1.begin(),v1.end()-1);
    //代码执行后v2元素为{10,1,2,3,20,30,40}
    vector&lt;int&gt;::iterator iter=v2.insert(v2.begin()+1,v1.rbegin(),v1.rend()-1);
    //代码执行后v2元素为{10,4,3,2,20,30,40}
    cout&lt;&lt;iter-v2.begin()&lt;&lt;endl;//1

    return 0;
}
</code></pre>
<p>erase操作实例</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v;
    v.push_back(8);
    v.push_back(9);
    v.push_back(10);
    vector&lt;int&gt;::iterator iter=v.erase(v.begin()+1);
    cout&lt;&lt;*iter&lt;&lt;endl;//10

    return 0;
}

</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;


int main() {
    vector&lt;int&gt; v={1,2,3,4,5,6,7,8};

    vector&lt;int&gt;::iterator iter=v.erase(v.begin()+1,v.begin()+5);
    //v={1,6,7,8}
    cout&lt;&lt;*iter&lt;&lt;endl;//6

    return 0;
}
</code></pre>
<h3 id="二维vector"><a class="header" href="#二维vector">二维vector</a></h3>
<p>vector中的元素也可以是vector，从而可以得到二维、三维等多维的vector。要声明一个二维的vector，可以使用以下语句：<code>vector&lt;vector&lt;int&gt;&gt; Array;</code>。如果C++版本在是C++11以前，则以上声明中<code>&gt;&gt;</code>内要有一个空格，否则编译报错，如：<code>vector&lt;vector&lt;int&gt; &gt; Array;</code></p>
<p>下面举例说明二维vector的应用：输出一个杨辉三角形。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;iomanip&gt;
using namespace std;


int main() {
    int i=0,j=0;
    vector&lt;vector&lt;int&gt;&gt; Array;
    vector&lt;int&gt; aLine;
    aLine.push_back(1);
    Array.push_back(aLine);//第0行是1
    aLine.push_back(1);
    Array.push_back(aLine);//第1行是1 1
    for(i=2;i&lt;9;i++)
    {
        vector&lt;int&gt; lastLine=Array[i-1];
        aLine.clear();
        aLine.push_back(1);
        for(j=1;j&lt;lastLine.size();j++)
            aLine.push_back(lastLine[j-1]+lastLine[j]);

        aLine.push_back(1);//最后一个元素是1
        Array.push_back(aLine);

    }
    for(j=0;j&lt;Array.size();j++)
    {
        for(i=0;i&lt;Array[j].size();i++)
            cout&lt;&lt;setw(2)&lt;&lt;Array[j][i]&lt;&lt;&quot; &quot;;
        cout&lt;&lt;endl;
    }

    return 0;
}
</code></pre>
<pre><code> 1
 1  1
 1  2  1
 1  3  3  1
 1  4  6  4  1
 1  5 10 10  5  1
 1  6 15 20 15  6  1
 1  7 21 35 35 21  7  1
 1  8 28 56 70 56 28  8  1
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="STL理论.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="string类程序设计.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="STL理论.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="string类程序设计.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
