# 程序的基本组成

<!-- toc -->

## 程序基本结构

```cpp
#include <iostream>

using namespace std;

int main()
{
   cout<<"天漢复兴！"<<endl;
   return 0;
}
```

每一个C++程序都需要有一个main函数，而且只能有一个main函数。

单行注释`//`

多行注释`/**/`

C++的编译分为两个阶段：预编译+编译

预编译处理程序中预编译命令，即那些以#开头的指令。

编译预处理主要有：
- 库包含：用#include实现，表示程序使用了某个库。库包含就是把库的接口文件放入源文件，以便编译器检查程序中对库的调用是否正确。执行`#include "filename"`可以使用自定义库

名字空间是把一组程序实体组合在一起构成一个作用域。一个名字空间不能有重名，不同名字空间中可以有定义相同的实体名。当引用某个实体时需要加上名字空间的限定如名字空间名::实体名。C++标准库中的名字都定义在名字空间std中，如`std::cout`

## 变量定义

标识符identifier是用来对C++程序中的常量、变量以及用户自定义函数的名称进行标识的符号。

标识符通常由数字、字母、下划线组成，但数字不能放在开头。

标识符通用命名规则：
- 建议标识符命名应直观、易懂如MaxValue
- 建议标识符的命名不要太长如TmpValue
- 建议常量所有字母都大写如`const int MAX = 100;`

一个_标识符_是一个由数字，下划线，小写和大写拉丁字母，和大多数 Unicode 字符（见下文的详细说明）组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁语字母，下划线或 Unicode 非数字字符）开头。标识符区分大小写（小写和大写字母是不同的），而且每一个字符都是起作用的。

在声明中可以用标识符来命名对象、引用、函数、枚举项、类型、类成员、命名空间、模板、模板特化、形参包、goto 标号，以及其他实体，但有以下例外：

- 关键词标识符不能用于其他目的；
- 其中任何位置带有双下划线的标识符都是被保留的；
- 以一个下划线跟着一个大写字母开头的标识符是被保留的；
- 以一个下划线开头的标识符在全局命名空间中是被保留的。

这里“被保留”的意思是，标准库的头文件可能 `#define` 或者声明这样的标识符以便其内部使用，编译器可能会预先定义这种非标准的标识符，而且名字重整算法可能会假定某些这样的标识符是没有被使用的。如果程序员使用了这样的标识符的话，其行为是未定义的。

此外，对等同于关键词的标识符进行 `#define` 或 `#undef`，是未定义行为。一旦包含了至少一个标准库头文件，对等同于由任何标准库头文件中声明的名字的标识符进行 `#define` 或 `#undef`，也是未定义行为。

在表达式中指名某个变量、函数、概念的特化 (C++20 起)或枚举项的标识符可以作为表达式使用。仅由这个标识符组成的表达式的结果，是该标识符所指名的实体。若该标识符指名的是某个函数、变量、模板形参对象 (C++20 起)或数据成员，则表达式的值类别为左值，否则为纯右值（例如枚举项是纯右值表达式，概念的特化是 bool 纯右值 (C++20 起)）。

名字是以下各项之一，用来代表某个实体或者某个标号：

- 标识符；
- 函数写法的重载运算符的名字（ `operator+ 、 operator new` ）；
- 用户定义的转换函数的名字（ `operator bool `）；
- 用户定义的字面量运算符的名字（ `operator "" _km `）；
- 模板的名字后随其实参列表（ `MyTemplate<int>` ）。

代表实体的名字都是由声明引入到程序中来的。代表标号的名字则既可以通过 goto 语句，也可以通过带标号语句引入到程序中来。在多个翻译单元中使用一个名字，可以代表相同或者不同的实体，这依赖于其连接。

每当编译器在程序中遇到一个未知的名字时，它就会通过进行名字查找来将之与引入这个名字的声明联系起来，但对模板的声明和定义中的待决名不会这样做（对于这些名字，编译器需要确定它们所指名的是类型、模板还是别的什么实体，这可能需要进行显式消歧义）。

在C++中，每个变量在使用前必须被定义。

赋初值有两种格式：
- 类型名 变量名= 初值；如`int count=0;`
- 类型名 变量名(初值); 如`int count(0);`

## 数据类型

数据类型包括两个方面：
- 数据的取值范围
- 可用的操作

C/C++中数据类型分为两大类：
- 基本数据类型：整型、浮点型、字符型和布尔型
- 构造数据类型：数组、结构体、联合体和枚举

### 整型

- 基本型int：现在4字节，最初2字节
- 长型long：4字节
- 短整型short：2字节
- 长整型long long：8字节

原码、反码、补码

整数运算时要注意数据的表示范围，如整数用两个字节表示时，正整数32767加一的结果是-32768。这称为整数运算的溢出。

在某些应用中不可能出现负数，为避免整型数中有一半的数值范围被浪费，C++定义了只有非负数的类型——无符号数。无符号数就是在各种整数类型前加上关键词`unsigned`。

整型常量可以用十进制、八进制和十六进制表示：
- 十进制
- 八进制：以0开头的数字如`014`
- 十六进制：以0x开头的数字如`0xC3af`

### 浮点型

### 字符型

```cpp
/* Online C++ Compiler and Editor */
#include <iostream>

using namespace std;

int main()
{
   cout<<'\0'-'0'<<endl;//-48
   return 0;
}
```

```cpp
#include <iostream>

using namespace std;

int main()
{
   char c = 32;
   cout<<c<<endl;//空格
   return 0;
}
```


### 布尔型及类型总结

## 常量

## 算术表达式

## 赋值表达式

## 自增自减运算符

## 强制类型转换

## 数据的输入输出

### 输入流对象cin

格式：cin>>变量1>>变量2>>...>>变量n

- 当程序执行到这个语句时会停下来等待用户的输入
- 用户可以输入数据用回车结束
- 当有多个输入数据时，一般用用空白字符（空格、制表符和回车）分隔。

```cpp
#include <iostream>

using namespace std;

int main()
{

   int a,b,c;/*
   a,b,c = scanf("%d %d %d",&a,&b,&c);
   float average = (a+b+c)/3.0;
   printf("%d\n",a);
   printf("%d\n",b);
   printf("%d\n",c);
   printf("%.2f\n",average);

   cout << "Hello World" << endl;*/
   cin>>a>>b>>c;
   float average = (a+b+c)/3.0;
   //cout<<average;
   printf("%.2f\n",average);
   return 0;
}
```

cin.get

- 作用：从键盘接受一个字符
- 用法：cin.get(ch),或ch=cin.get()都是从键盘输入一个字符并存放到变量ch中
- 对应的用户输入：cin.get()可以接受任意字符，包括空白字符，而cin>>ch不能接受空白字符

```cpp
#include <iostream>

using namespace std;

int main()
{
   char ch;
   cin>>ch;//输入a
   cout<<(int)ch<<endl;//输出97
   return 0;
}
```

```cpp
#include <iostream>

using namespace std;

int main()
{
   char ch;
   ch=cin.get();//输入空格
   cout<<(int)ch<<endl;//输出32
   return 0;
}
```

按enter键输出10，表示回车\r，

C标准中空白字符有：空格（‘ ’）、换页（‘\\f’）、换行（‘\\n’）、回车（‘\\r’）、水平制表符（‘\\t’）、垂直制表符（‘\\v’）六个。

功能|ASCII码|16进制
-|-|-
回车|13
换行 |10
空格|32



### 输出流对象cout

输出格式可以是`cout>>a<<'+'<<b<<'='<<a+b<<endl;`

对于浮点数，可以用setprecision来设置精度（即实数型的有效位数）。一旦调用了setprecision，将影响后续所有输出的浮点数的精度，直到下一个设置精度的操作为止。

#### 设置浮点数精度

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
   double x = 123.456789, y = 9876.54321;
   cout<<setprecision(9)<<x<<'\t'<<y<<endl;
   cout<<setprecision(8)<<x<<'\t'<<y<<endl;
   cout<<setprecision(7)<<x<<'\t'<<y<<endl;
   cout<<setprecision(6)<<x<<'\t'<<y<<endl;
   cout<<setprecision(5)<<x<<'\t'<<y<<endl;
   cout<<setprecision(4)<<x<<'\t'<<y<<endl;
   cout<<setprecision(3)<<x<<'\t'<<y<<endl;
   cout<<setprecision(2)<<x<<'\t'<<y<<endl;
   cout<<setprecision(1)<<x<<'\t'<<y<<endl;
   cout<<setprecision(0)<<x<<'\t'<<y<<endl;
   
   return 0;
}
```

输出结果：
```txt
123.456789      9876.54321
123.45679       9876.5432
123.4568        9876.543
123.457 9876.54
123.46  9876.5
123.5   9877
123     9.88e+003
1.2e+002        9.9e+003
1e+002  1e+004
1e+002  1e+004
```
结果可能会四舍五入。

上面的输出结果没有完全对齐，可以通过域宽来解决这个问题。

####  设置域宽

域宽指数据所占的字符个数，设置域宽可以用流操纵符(setw)，设置宽度是适合于下一次输出（仅对一次输出起作用），之后的操作的宽度将被设置为默认值。如果没有设置输出宽度时，C++按实际长度输出，如整型变量a=123,b=456，cout<<a<<b;输出123456。

一旦设置了域宽，该输出必须占满域宽。如果输出值的宽度比域宽小，则插入填充字符填充。默认的填充字符是空格。如果实际宽度大于指定的域宽，则按实际宽度输出。如`cout<<setw(5)<<x<<setw(5)<<y;`输出为`  123  456`每个数值占5个位置，前面用空格填充。

```cpp
#include <iostream>
#include <iomanip>
using namespace std;

int main()
{
   double x = 123.456789, y = 9876.54321;
   cout<<left;//左对齐
   cout<<setprecision(9)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(8)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(7)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(6)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(5)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(4)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(3)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(2)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(1)<<setw(15)<<x<<'\t'<<y<<endl;
   cout<<setprecision(0)<<setw(15)<<x<<'\t'<<y<<endl;
   
   return 0;
}
```
输出结果：
```
123.456789     	9876.54321
123.45679      	9876.5432
123.4568       	9876.543
123.457        	9876.54
123.46         	9876.5
123.5          	9877
123            	9.88e+03
1.2e+02        	9.9e+03
1e+02          	1e+04
1e+02          	1e+04
```

流操纵符
- left：输出左对齐，必要时在右边填充字符
- right：输出右对齐，必要时在左边填充字符
- fixed：以定点小数形式输出浮点数
- setfill：设置填充字符。它有一个字符型的参数

#### 保留两位小数的三种写法

前面要有`#include <iomanip>`

```cpp
//第一种写法
cout<<setiosflags(ios::fixed)<<setprecision(2);
```

```cpp
//第二种写法
cout.setf(ios::fixed);
cout<<setprecision(2);
```

```cpp
//第三种写法
cout<<fixed<<setprecision(2);
```

## 程序设计的风格

- 使用缩进来区别程序不同的控制级别
- 命名习惯
- 注释
- 易于修改

## 补充：逗号表达式

逗号表达式，是c语言中的逗号运算符，优先级别最低，它将两个及其以上的式子联接起来，从左往右逐个计算表达式，整个表达式的值为最后一个表达式的值。

如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后表达式2，整个表达式值是表达式2的值，如：（3+5，6+8）的值是14；a=(a=3*5,a*4)的值是60，其中（a=3*5,a*4）的值是60， a的值在逗号表达式里一直是15，最后被逗号表达式赋值为60，a的值最终为60。

(表达式1，表达式2，表达式3，...... ，表达式n)

逗号表达式的要领：

(1) 逗号表达式的运算过程为：从左往右逐个计算表达式。

(2) 逗号表达式作为一个整体，它的值为最后一个表达式（也即表达式n）的值。

(3) 逗号运算符的优先级别在所有运算符中最低。

```cpp
#include <iostream>

using namespace std;

int main()
{
   int a,b;
   a=3;
   b=a++;
   cout<<a<<" "<<b<<endl;//4 3
   a=3;
   cout<<++a<<endl;//4
   b=(a=1, a+1, a++);
   cout<<a<<" "<<b<<endl;//2 1
   return 0;
}
```

```cpp
#include <iostream>

using namespace std;

int main()
{
   int x,y,z,w;
   x=1;
   y=1;
   z=x++,y++,++y;//赋值运算符优先级高于逗号表达式
   x=1;
   y=1;
   w=(x++,y++,++y);
   printf("%d,%d,%d,%d\n",x,y,z,w);//输出2,3,1,3
   return 0;
}
```








