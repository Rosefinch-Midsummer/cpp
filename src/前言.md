# 前言

<!-- toc -->

# 版本更新资料汇总




# 程序组织结构

## 内部函数

函数本质上是全局的，在多文件的程序中，在连接时会检查函数在全局作用域是否名字唯一，如果不是则出现连接错误。

在函数定义前加上static修饰，则称为内部函数，定义形式为：

```cpp
static 返回类型 函数名（形式参数列表）
{
	函数体
}
```

按照前面的实体可见规则，内部函数仅在包含它的文件中有效。

使用内部函数的原因是该函数在逻辑上仅限定在一个文件中使用，其他文件不会用到。而且希望连接检查时永远不会出现该函数名不唯一的连接错误，这在多人编写同一个程序的软件开发模式中是常用的策略。
## 外部函数

在函数定义前加上extern声明，则称为外部函数，定义形式为

```cpp
extern 返回类型 函数名（形式参数列表）
{
	函数体
}
```

在调用另一个文件中的函数时，需要用extern声明此函数是外部函数，声明形式为`extern 返回类型函数名（类型1 参数名1，类型2 参数名2，...);`

C++所有的函数本质上都是外部函数。因此，上面的extern都可以省略。
## 多文件结构

多文件结构本质上反映面向过程的结构化设计内在要求，同时多文件结构也是高效率的编程模式。

编译器编译时的基本单位是源文件。编译完成后得到目标代码文件，然后连接器开始工作。连接器将多个目标代码和使用到的库函数代码（通常都是二进制形式）逐个连接起来，在这个过程中，它可以发现：

（1）全局函数或全局变量是否在不同的文件中重复定义，或者在全局范围内是否有相同名字的实体。

（2）在多个目标代码和库函数中找不到全局函数或全局变量的定义。

若连接器成功处理完所有的连接，则产生可执行文件，一次编译连接的过程宣告完成。

## 头文件与工程文件

### 头文件

头文件（.h）本质上是源文件（.cpp），它是通过文件包含命令嵌入源文件中去编译的，文件包含命令的写法格式如如下两种：

```cpp
#include <头文件名>
#include 头文件名
```

一般情况下，使用系统函数时应用第一种写法，使用自定义头文件和附加库头文件时应用第二种写法。

头文件的工作原理是通过将每个源文件中外部函数的函数声明等信息集中写道一个文件中，称为头文件（有别于源文件）例如a.cpp变为a.h。而别的源文件只需用文件包含命令将这个头文件包含进来，则编译时编译器自然就有了函数声明。在使用时mian.cpp文件可以有其他3个文件的声明集合，换言之，其他3个文件的外部函数声明等在main.cpp文件可见。如main.cpp文件开头可以这样写：

```cpp
#include "a.h"
#include "b.h"
#include "c.h"
```

头文件除了函数声明外，还经常包括全局性变量、宏定义等信息，但头文件一般不包括定义内容，如函数定义和变量定义，而只包含声明内容，这是因为头文件会被多次包含，如果是定义内容导致重复定义，这是编译自定义头文件的重要原则：定义内容和程序实现代码等应放在对应的源文件中。

一般情况下，头文件和源文件是对应的，多个源文件就有多个头文件，文件名和源文件也是相同的，这样自成体系，便于管理。
### 工程文件

多文件结构程序在编译时需要工程文件来管理，不同的编译器有不同的工程文件格式，但都支持命令行编译Makefile文件。

Makefile文件定义了一系列的规则来定义指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，编译时使用什么参数，甚至进行更复杂的功能操作。

Makefile文件使用脚本命令，可以执行操作系统所允许的命令。以下是GCC编译系统的Makefile文件示例，它指定编译和连接4个文件：main.cpp、a.cpp、b.cpp和c.cpp。

```makefile
0CFLAGS=-nologo-W3-Zi-MD-01-DWIN32
INCLUDES=
COMPILE_cpp=c1-Fo$@$(CFLAGS)-EHsc $(INCLUDES)-c
a.o : a.cpp
	$(COMPILE_cpp) a.cpp
b.o : b.cpp
	$(COMPILE_cpp) b.cpp
c.o : c.cpp
	$(COMPILE_cpp) c.cpp
main.o : main.cpp
	$(COMPILE_cpp) main.cpp
```

集成开发环境的编译器如Code::Blocks允许可视化管理工程文件。
## 提高编译速度

要提高编译速度首先要完善程序的代码结构，例如，精简头文件，接口与实现完全分离，高度模块化。如果是单个文件且代码量较大时，为了一点小改动就要重新对大面积代码编译，实在是不划算。高度模块化就是低耦合，就是尽可能地减少相互依赖。例如，函数与函数之间降低相互依赖，则这两个函数就可以分离到不同的文件中；在文件与文件之间，一个头文件的变化尽量不要引起其他文件的重新编译。

提高编译速度还可以利用编译器的功能，提高编译器的工作效率。现今的编译器一般都有下面的功能。

（1）预编译头文件。

即使很小的程序都会使用头文件的，特别是那些标准库的头文件，代码量甚至超过程序本身。预编译头文件是指编译器第一次编译文件时将头文件的编译结果缓存下来，如果下次编译时发现没有新的则它将直接使用缓存结果，不用对头文件再次编译。

（2）增量编译。

增量编译是指编译器编译得到目标代码后，如果下次编译时发现文件并未经过修改，则使用前一次的目标代码而无需再次编译。在多文件结构程序中，调试修改一般是集中在少数文件上，所以增量编译节省的编译时间是可观的。

（3）编译缓存。

增编编译是比较目标代码和源文件的时间来决定是否要重新编译。编译缓存是指将前面的编译结果缓存下来，根据文件的内容来判断是否重新编译。**例如，对一个文件输入一个没有作用的空格会导致增量编译失效，但编译缓存能判别出增加的这个空格是否足以需要重新编译。**


# 学习资源









