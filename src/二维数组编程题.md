# 二维数组编程题

<!-- toc -->

## 5-1二维数组->简单

### 二维数组求各行均值

问题描述 :

在3\*4的二维数组a中，计算出各行的平均值，放在一个一维数组b中

输入说明 :

3\*4的整数二维数组a的各个元素，按照三行四列的格式输入，整数之间以空格分隔。

输出说明 :

一维数组b的值，输出时，小数尾部的0不输出。

```cpp
#include <iostream>
using namespace std;

int main()
{

    int a[3][4];
    double b[3];
    for(int i=0;i<3;i++)
    {
        double sum=0;
        for(int j=0;j<4;j++)
        {
            cin>>a[i][j];
            sum+=a[i][j];
        }
        b[i]=sum/4.0;
    }
    for(int i=0;i<3;i++)
    {
        if(i==0)
            cout<<b[i];
        else
            cout<<" "<<b[i];
    }
    cout<<" ";

    return 0;

}
```

### 旋转句子（求助GPT）

问题描述 :

旋转句子，要求把输入的句子按顺时针旋转90度。即输入时的句子是从左至右和自上而下的显示方式，输出时变成从上到下和从右到左的显示方式。换句话说，就是输入的最后一句输出在最左边的列，输入的第一句输出在最右边的列。

输入说明 :

输入时最多100个句子（1句即一行），每句不超过100个字符。合法字符包括：换行符、空格、任何标点符、数字、小写和大写英文字母。

注意：一个句子可能不包含任何字符，即空行。

输出说明 :

按顺时针旋转90度后的那些句子。

注意：如果输入了n个句子，则输出就有n列，输出的最下面一行也有n列。可参见输出范例，每一行都有4个字符，最下面一行的第1、3、4个字符都是空格。

输入范例 :

```
Rene Decartes once said,

"I think, therefore I am."
Sample Input
```

输出范例 :

```
S" R
aI e
m  n
pt e
lh  
ei D
 n e
Ik c
n, a
p  r
ut t
th e
 e s
 r  
 e o
 f n
 o c
 r e
 e  
   s
 I a
   i
 a d
 m ,
 .  
 "  
```

以下是一个解决该问题的 C++ 程序示例： 

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 105;

char sentence[MAXN][MAXN]; // 存储输入的句子
int len[MAXN]; // 每句话的长度
int max_len = 0; // 最长的句子长度

int main() {
    int n = 0; // 句子的数量
    while (fgets(sentence[n], MAXN, stdin)) { // 逐行读入句子
        len[n] = strlen(sentence[n]); // 记录句子长度
        if (sentence[n][len[n] - 1] == '\n') { // 判断该行句子的最后一个字符是否为换行符
            sentence[n][len[n] - 1] = '\0'; // 如果是，将其替换为字符串结束符
            len[n]--; // 更新句子长度
        }
        max_len = max(max_len, len[n]); // 更新最长的句子长度
        n++; // 句子数量加一
    }

    for (int i = 0; i < max_len; i++) { // 按列输出旋转后的句子
        for (int j = n - 1; j >= 0; j--) { // 按行输出每个字符
            if (i >= len[j]) { // 如果该行的长度小于 i，则输出空格
                cout << ' ';
            } else {
                cout << sentence[j][i]; // 否则输出该行的第 i 个字符
            }
        }
        cout << endl;
    }

    return 0;
}
```

程序首先定义了一个二维字符数组 `sentence` 用于存储输入的句子，以及一个一维整型数组 `len` 用于记录每个句子的长度，还定义了一个整型变量 `max_len` 用于记录最长的句子长度。

程序使用 `fgets` 逐行读入句子，记录每个句子的长度，并去掉每个句子的换行符。读入句子的过程中，程序同时更新 `max_len`。

读入句子后，程序使用两个循环，按列输出旋转后的句子。外层循环按列循环，内层循环按行循环，输出每个字符。如果该行的长度小于当前列的索引，则输出空格。否则，输出该行的第 i 个字符。

程序最后返回 0，结束运行。

如果程序多输出了一行空白字符，可能是因为输入的最后一行句子后面有一个额外的换行符。您可以尝试在读入每行句子后，判断该行句子的最后一个字符是否为换行符，如果是，则将其替换为字符串结束符 `\0`。

这个修改后的程序应该可以正确输出旋转后的句子，且不会多输出一行空白字符。

### 特殊的矩阵运算

问题描述 :

输入m个方阵，方阵的元素是非0整数。对于n阶方阵A，明明现在需要进行特殊的运算。

方阵A有两条对角线：从左上角到右下角的对角线，元素为5 8 9，以及从左下角到右上角的对角线，元素为2 8 3。

求A两条对角线元素相乘的和（对角线积），`5*2+8*8+9*3=101；`

求A两条对角线元素相除的和（对角线商）：`5/2+8/8+9/3=6`。   （注意：求对角线商时用整除，所以5/2的结果为2。）

输入说明 :

输入由多组数据组成。

1.     第一行有一个整数m，表示接下来有m组测试数据；

2.     第二行有一个整数n，表示n阶方阵，0 < n < 10；

3.     接下来的m行，每行有n\*n个非0整数，整数间用空格分隔，每行对应一个矩阵。例如上述方阵A的输入格式为：5 1 3 5 8 7 2 6 9

输出说明 :

对每个矩阵，输出两个整数，表示对角线积和对角线商，用空格分隔。每个矩阵的输出结果占一行。

输入范例 :

```
2
3
5 1 3 5 8 7 2 6 9
-2 3 2 1 2 49 22 1 2 
```

输出范例 :

```
101 6
-36 2
```

```cpp
#include <iostream>
using namespace std;

int main()
{

    int m,n;
    cin>>m;
    cin>>n;
    int arr[n][n];
    while(m--)
    {
        int sum_times=0;
        int sum_division=0;
        for(int j=0;j<n;j++)
        {
            for(int t=0;t<n;t++)
                cin>>arr[j][t];
        }
        for(int i=0;i<n;i++)
        {
            sum_times+=arr[i][i]*arr[n-i-1][i];
            sum_division+=arr[i][i]/arr[n-i-1][i];

        }
        cout<<sum_times<<" "<<sum_division<<endl;
    }

    return 0;

}
```

### 发牌（调教GPT）

问题描述 :

编制一个模拟发牌的程序。有编号为1，2，3，4四个人，将一付去掉大小怪的扑克按照如下顺序排列梅花c0-c12，方块d0-d12，红桃h0--h12，黑桃s0-s12，然后按照1，2，3，4四个人的顺序发牌，问最后每个人手上的牌有哪些。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据由一行组成。每组数据包含一个在1到4之间的整数，代表四个人中的一个，在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。对于每组输入，输出那个人手上的牌。每组一行。每行包括13张牌，每张牌由牌的花色和牌的大小组成。牌的花色和牌的大小之间有一个空格，前后两张牌之间也有一个空格。其余数据前后没有多余的空格，两组数据之间也没有多余的空行。

输入范例 :

```
1
2
```

输出范例 :

```
c 0 c 4 c 8 c 12 d 3 d 7 d 11 h 2 h 6 h 10 s 1 s 5 s 9
c 1 c 5 c 9 d 0 d 4 d 8 d 12 h 3 h 7 h 11 s 2 s 6 s 10
```

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main()
{

    int n;

    string s1="c 0 c 4 c 8 c 12 d 3 d 7 d 11 h 2 h 6 h 10 s 1 s 5 s 9";

    string s2="c 1 c 5 c 9 d 0 d 4 d 8 d 12 h 3 h 7 h 11 s 2 s 6 s 10";

    string s3="c 2 c 6 c 10 d 1 d 5 d 9 h 0 h 4 h 8 h 12 s 3 s 7 s 11";
    string s4="c 3 c 7 c 11 d 2 d 6 d 10 h 1 h 5 h 9 s 0 s 4 s 8 s 12";

    while(cin>>n)
    {
        switch(n)
        {
        case 1:
            cout<<s1<<endl;
            break;
        case 2:
            cout<<s2<<endl;
            break;
        case 3:
            cout<<s3<<endl;
            break;
        case 4:
            cout<<s4<<endl;
            break;
        }
    }

    return 0;

}
```

以下是一个解决该问题的 C++ 程序示例：

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 53;

char card[MAXN][3] = { // 存储所有的扑克牌
    "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12",
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d10", "d11", "d12",
    "h0", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9", "h10", "h11", "h12",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12"
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin >> player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i < 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i < 13; i++) { // 输出当前玩家的手牌
            cout << card[cards[i]] << " "; // 根据牌的索引输出牌的花色和大小
        }
        cout << endl; // 输出换行符
    }

    return 0;
}
```

程序首先定义了一个二维字符数组 `card`，用于存储所有的扑克牌。程序使用一个整型变量 `player` 循环读入每个玩家的编号，然后按照顺序发牌，并将当前玩家手中的牌存储到一个整型数组 `cards` 中。

程序使用一个循环输出当前玩家的手牌，即输出 `cards` 中存储的牌的花色和大小。其中，牌的花色和大小存储在 `card` 数组中，可以通过牌的索引在 `card` 中查找。

程序最后返回 0，结束运行。

上面的程序编译错误。

`error: initializer-string for array of chars is too long [-fpermissive]`

字符数组初始化时，数组大小一定要大于字符串长度+1，否则编译错误。字符串数组最后有`\0`

根据您的反馈，程序报错 `"error: initializer-string for array of chars is too long [-fpermissive]"`，这通常是因为使用了 C++11 或更高版本的编译器，导致编译器对标准的限制更加严格，不允许使用初始化字符串的长度超过编译器规定的最大长度。

为了解决这个问题，您可以将 `card` 数组定义为一个二维字符指针，然后将每张扑克牌的字符串存储在堆中，并将其指针存储到 `card` 数组中。

以下是修改后的 C++ 程序示例：

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 53;

char* card[MAXN] = { // 存储所有的扑克牌
    "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12",
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "d10", "d11", "d12",
    "h0", "h1", "h2", "h3", "h4", "h5", "h6", "h7", "h8", "h9", "h10", "h11", "h12",
    "s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11", "s12"
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin >> player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i < 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i < 13; i++) { // 输出当前玩家的手牌
            cout << card[cards[i]] << " "; // 根据牌的索引输出牌的花色和大小
        }
        cout << endl; // 输出换行符
    }

    return 0;
}
```

这个修改后的程序应该可以正常编译和运行，且正确输出每个玩家的手牌。

PE：测试数据结果正确，但空格、换行、tab等字符不正确。

具体信息如下:

```
测试用例 459结果为 PE:
测试用例 460结果为 PE:
测试用例 461结果为 PE:
测试用例 462结果为 PE:
```

非常感谢您的反馈。根据题目的输出要求，程序需要在输出每个玩家的手牌时，每张牌之间有一个空格，每组测试数据输出后需要换行。

以下是修改后的 C++ 程序示例：

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 53;

char* card[MAXN] = { // 存储所有的扑克牌
    "c 0", "c 1", "c 2", "c 3", "c 4", "c 5", "c 6", "c 7", "c 8", "c 9", "c 10", "c 11", "c 12",
    "d 0", "d 1", "d 2", "d 3", "d 4", "d 5", "d 6", "d 7", "d 8", "d 9", "d 10", "d 11", "d 12",
    "h 0", "h 1", "h 2", "h 3", "h 4", "h 5", "h 6", "h 7", "h 8", "h 9", "h 10", "h 11", "h 12",
    "s 0", "s 1", "s 2", "s 3", "s 4", "s 5", "s 6", "s 7", "s 8", "s 9", "s 10", "s 11", "s 12"
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin >> player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i < 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i < 13; i++) { // 输出当前玩家的手牌
            cout << card[cards[i]];
            if (i != 12) { // 如果不是最后一张牌，则输出一个空格
                cout << " ";
            }
        }
        cout << endl; // 输出换行符
    }

    return 0;
}
```

这个修改后的程序会按照题目的输出要求输出每个玩家的手牌。每张牌的花色和大小之间有一个空格，牌与牌之间也有一个空格，每组测试数据的输出结果后面跟着一个换行符。

### 矩阵问题

问题描述 :

从键盘上输入一个整数N，按以下规律输出一个(2N+1)*(2N+1)的矩阵：

对角线的值为1，

上半三角区域值为2，

下半三角区域值为3，

左半三角区域的值为4，

右半三角区域的值为5。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组测试数据数据占一行，大于零，小于等于8。

输出说明 :

对每组测试数据，你的程序需要向标准输出文件（通常为启动该程序的终端）依次输出符合要求的矩阵，每行数据与数据之间以空格分隔，在行首和行尾不要输出多余的空格。在所有数据前后，以及两组数据之间不要输出多余的空行。

输入范例 :

```
1
8
```

输出范例 :

```
1 2 1
4 1 5
1 3 1
1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1
4 1 2 2 2 2 2 2 2 2 2 2 2 2 2 1 5
4 4 1 2 2 2 2 2 2 2 2 2 2 2 1 5 5
4 4 4 1 2 2 2 2 2 2 2 2 2 1 5 5 5
4 4 4 4 1 2 2 2 2 2 2 2 1 5 5 5 5
4 4 4 4 4 1 2 2 2 2 2 1 5 5 5 5 5
4 4 4 4 4 4 1 2 2 2 1 5 5 5 5 5 5
4 4 4 4 4 4 4 1 2 1 5 5 5 5 5 5 5
4 4 4 4 4 4 4 4 1 5 5 5 5 5 5 5 5
4 4 4 4 4 4 4 1 3 1 5 5 5 5 5 5 5
4 4 4 4 4 4 1 3 3 3 1 5 5 5 5 5 5
4 4 4 4 4 1 3 3 3 3 3 1 5 5 5 5 5
4 4 4 4 1 3 3 3 3 3 3 3 1 5 5 5 5
4 4 4 1 3 3 3 3 3 3 3 3 3 1 5 5 5
4 4 1 3 3 3 3 3 3 3 3 3 3 3 1 5 5
4 1 3 3 3 3 3 3 3 3 3 3 3 3 3 1 5
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
```

```cpp
#include <iostream>
using namespace std;

int main()
{

    int N;

    while(cin>>N)
    {
        int a[2*N+1][2*N+1];
        for(int i=0;i<2*N+1;i++)
        {
            for(int j=0;j<2*N+1;j++)
            {
                if((i==j)||(i+j==2*N)) a[i][j]=1;
                else if(((i+j)<=2*N)&&(i<=N)&&(i<j)) a[i][j]=2;
                else if(((i+j)>=2*N+1)&&(i>N)&&(i>j)) a[i][j]=3;
                else if(((i+j)<=2*N-1)&&(j<=N)&&(i>j)) a[i][j]=4;
                else a[i][j]=5;
            }
        }
        for(int i=0;i<2*N+1;i++)
        {
            for(int j=0;j<2*N+1;j++)
            {
                if(j>0) cout<<" ";
                cout<<a[i][j];
            }
            cout<<endl;
        }
    }

    return 0;

}
```







