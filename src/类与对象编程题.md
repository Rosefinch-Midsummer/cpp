# 类与对象编程题

<!-- toc -->

### 1字符串填充（默认形参）

问题描述 :

实验目的：学习函数的默认形参的使用。

内容：对于字符串，实现以下填充函数，并编写main函数测试这些函数：

1. padLeft函数：

功能：将一字符串左填充（在左边填充指定字符）至n个字符的长度，可指定填充字符，比如填充“\*”，如果不指定填充字符，则填充空格。

2. padRight函数：

功能：将一字符串右填充至n个字符的长度，可指定填充字符，比如填充“\*”，如果不指定填充字符，则填充空格。

输入说明 :

测试程序输入时，每组测试数据包含两行，第一行输入一个整数，指定需要完成的操作，第二行为该操作需要的数据。  

对于每个整数对应的操作及其相应数据的输入方式如下（输入的字符串中不包含空格）：  

11：对应padLeft，第二行输入字符串string1、整数n，其间以空格分隔（由于没指定填充字符，所以填充空格）  
异常处理：如果string1的长度大于等于n，则不填充任何字符。

12：对应padLeft，第二行输入字符串string1、整数n、一个填充字符，其间以空格分隔（填充字符不为空格）  
异常处理：如果string1的长度大于等于n，则不填充任何字符。

21：对应padRight，第二行输入字符串string1、整数n，其间以空格分隔（由于没指定填充字符，所以填充空格）  
异常处理：如果string1的长度大于等于n，则不填充任何字符。

22：对应padRight，第二行输入字符串string1、整数n、一个填充字符，其间以空格分隔（填充字符不为空格）  
异常处理：如果string1的长度大于等于n，则不填充任何字符。  

输出说明 :

对于每组测试数据，输出对应的结果。如果结果为空字符串，则输出一个空行。

每行行首与行尾无多余空格，第一行之前与最后一行之后无多余空行。

输入范例 :

```
11
abcdef 4
12
abcdef 8 *
21
abcdef 6
22
abcdef 10 .
```

输出范例 :

```
abcdef
**abcdef
abcdef
abcdef....
```

```cpp
#include <iostream>
#include <string>
using namespace std;

string padLeft(string string1, int n, char padding=' ')
{
    if(string1.length()>=n) return string1;
    else
    {
        for(int i=0;i<=n-string1.length();i++)
            string1=padding+string1;
    }
    return string1;
}

string padRight(string string1, int n, char padding=' ')
{
    if(string1.length()>=n) return string1;
    else
    {
        for(int i=0;i<=n-string1.length();i++)
            string1.push_back(padding);
    }
    return string1;
}

int main()
{
 int num, length;
 char padding;
 string src, dest;

 while(cin >> num)
 {
  switch(num)
  {
   case 11:
    cin >> src >> length;
    cout << padLeft(src, length) << endl;
    break;
   case 12:
    cin >> src >> length >> padding;
    cout << padLeft(src, length, padding) << endl;
    break;
   case 21:
    cin >> src >> length;
    cout << padRight(src, length) << endl;
    break;
   case 22:
    cin >> src >> length >> padding;
    cout << padRight(src, length, padding) << endl;
    break;
  }
 }
 return 0;
}
```

### 2 删除字符(函数重载)

问题描述 :

内容：对于字符串，实现以下删除字符的函数，并编写main函数测试这些函数：  
实验目的：学习函数重载的使用。

1.remove函数：  
从形参传入一个字符，将该字符从字符串中删除。

2.remove函数：  
从形参传入一个下标index，将index处的字符从字符串中删除。

3.remove函数：  
从形参传入两个下标startIndex和endIndex，将从startIndex到endIndex范围内的字符从字符串中删除。

输入说明 :

输入时，每组测试数据包含两行，第一行输入一个整数，指定需要完成的操作，第二行为该操作需要的数据。  

对于每个整数对应的操作及其相应数据的输入方式如下（输入的字符串中不包含空格）：  

1：对应remove，第二行输入字符串和一个字符（以空格分隔），将字符从字符串中删除。

2：对应remove，第二行输入字符串和index（以空格分隔），将index处的字符从字符串中删除。  
异常处理：如果index不合法，则不删除字符。

3：对应remove，第二行输入字符串和startIndex、endIndex（以空格分隔），将从startIndex到endIndex范围内的字符从字符串中删除。  
异常处理：如果startIndex、endIndex不合法，则不删除字符。

输出说明 :

对于每组测试数据，输出对应的结果。如果结果为空字符串，则输出一个空行。

每行行首与行尾无多余空格，第一行之前与最后一行之后无多余空行。

输入范例 :

```
1
acdef b
2
abcdef 3
2
abcdef 6
3
abcd 0 3
3
abcdef 3 5
3
abcdef 3 7
```

输出范例 :

```
acdef
abcef
abcdef

abc
abcdef
```

```cpp
#include <iostream>
#include <string>
using namespace std;

string remove(string src, char delChar)
{
    string dest;
    for(int i=0;i<src.length();i++)
        if(src[i]!=delChar) dest.push_back(src[i]);
    return dest;
}

string remove(string src, int index)
{
    string dest;
    if(index>=src.length()||index<0)
        return src;
    else
    {
        for(int i=0;i<src.length();i++)
            if(i!=index) dest.push_back(src[i]);
    }
    return dest;
}

string remove(string src, int startIndex,int  endIndex)
{
    string dest;
    if(startIndex<0||startIndex>=src.length()||endIndex<0||endIndex>=src.length())
        return src;
    else
    {
        if(startIndex==0&&endIndex==src.length()-1) return"";
        else if(startIndex==0&&endIndex!=src.length()-1)
        {
            for(int i=endIndex+1;i<src.length();i++)
                dest.push_back(src[i]);
        }
        else if(startIndex!=0&&endIndex==src.length()-1)
        {
            for(int i=0;i<startIndex;i++)
                dest.push_back(src[i]);
        }
        else
        {
            for(int i=0;i<startIndex;i++)
                dest.push_back(src[i]);
            for(int i=endIndex+1;i<src.length();i++)
                dest.push_back(src[i]);
        }
    }
    return dest;
}


int main()
{
 int num, index, startIndex, endIndex;
 char delChar;
 string src, dest;

 while(cin >> num)
 {
  switch(num)
  {
   case 1:
    cin >> src >> delChar;
    cout << remove(src, delChar) << endl;
    break;
   case 2:
    cin >> src >> index;
    cout << remove(src, index) << endl;
    break;
   case 3:
    cin >> src >> startIndex >> endIndex;
    cout << remove(src, startIndex, endIndex) << endl;
    break;
  }
 }
 return 0;
}
```

注意：返回空字符串是`return "";`不是`return " ";`

### 3 复制字符串（求助GPT）

内容：对于字符串，实现以下复制功能数，并编写main函数测试这些函数：  

实验内容：使用**默认形参或者重载**实现

cpy函数：  

原型可为：  `string cpy(string src, int startIndex, int endIndex)`

功能：从字符串src复制部分字符形成新字符串并返回。可指定复制的起始位置和结束位置，即从startIndex到endIndex之间的所有字符都复制到结果字符串中。startIndex默认为0， endIndex默认为到字符串尾部。

比如，  

cpy(src)： 将src的所有字符都复制并返回  

cpy(src, 3)：将src从下标为3的位置直到结尾的所有字符都复制并返回

cpy(src, 3, 5)：将src的第3、4、5个字符复制并返回

输入说明 :

输入时，每组测试数据包含两行，第一行输入一个整数，指定需要完成的操作，第二行为该操作需要的数据。  
对于每个整数对应的操作及其相应数据的输入方式如下（输入的字符串中不包含空格）：

1：对应cpy，第二行输入字符串src

2：对应cpy，第二行输入字符串src和整数startIndex，以空格分隔。复制从startIndex开始的子字符串，下标从0开始。  

异常处理：如果startIndex不合法，则不复制任何字符，结果为空字符串。

3：对应cpy，第二行输入字符串src和整数startIndex、endIndex，以空格分隔。  

异常处理：如果startIndex、endIndex不合法，则不复制任何字符，结果为空字符串。

输出说明 :

对于每组测试数据，输出对应的结果。如果结果为空字符串，则输出一个空行。

每行行首与行尾无多余空格，第一行之前与最后一行之后无多余空行。

输入范例 :

```
1
aabbccdd
2
abcdef 4
2
abcdef 7
3
abcdef 0 3
3
abcdef 0 6
3
abcdef 3 2
3
abcdef 0 0
```

输出范例 :

```
aabbccdd
ef

abcd


a

```

自己写的下面这个C++函数要使用src的最大下标作为形参默认值，但这个程序会报错，帮我找出问题所在，以及如何修改程序。

```cpp
string cpy(string src, int startIndex=0, int endIndex=src.length()-1)
{
    string dest;
    //startIndex=0;
    //endIndex=src.length()-1;
    if(startIndex<0||startIndex>src.length()-1||endIndex<0||endIndex>src.length()-1)
        return "";
    else
    {
        for(int i=startIndex;i<=endIndex;i++)
            dest.push_back(src[i]);
    }
    return dest;
}
```

在C++中，形参的默认值不能依赖于其他形参。在你的代码中，形参`endIndex`的默认值依赖于形参`src`，这是不允许的，所以编译器报错。

一个解决方案是：在函数内部检查`endIndex`的值是否为默认值，如果是，则将其设置为`src.length()-1`。

下面是修改后的代码：

```cpp
string cpy(string src, int startIndex=0, int endIndex=-1)
{
    string dest;
    if(endIndex == -1) endIndex = src.length()-1;  //如果endIndex为默认值，设置其为src的最大下标
    if(startIndex<0||startIndex>src.length()-1||endIndex<0||endIndex>src.length()-1)
        return "";
    else
    {
        for(int i=startIndex;i<=endIndex;i++)
            dest.push_back(src[i]);
    }
    return dest;
}
```

在这个版本中，我们把`endIndex`的默认值改为了`-1`，在函数内部，我们检查`endIndex`的值，如果为`-1`（默认值），我们把它设为`src.length()-1`。这样，如果用户没有提供`endIndex`的值，函数就会使用`src`的最大下标。

完整代码如下：

```cpp
#include <iostream>
#include <string>
using namespace std;

string cpy(string src, int startIndex=0, int endIndex=-1)
{
    string dest;
    if(endIndex == -1) endIndex = src.length()-1;  //如果endIndex为默认值，设置其为src的最大下标
    if(startIndex<0||startIndex>src.length()-1||endIndex<0||endIndex>src.length()-1)
        return "";
    else
    {
        for(int i=startIndex;i<=endIndex;i++)
            dest.push_back(src[i]);
    }
    return dest;
}

int main()
{
 int num, length, index, startIndex, endIndex;
 string src, dest;

 while(cin >> num)
 {
  switch(num)
  {
   case 1:
    cin >> src;
    cout << cpy(src) << endl;
    break;
   case 2:
    cin >> src >> startIndex;
    cout << cpy(src, startIndex) << endl;
    break;
   case 3:
    cin >> src >> startIndex >> endIndex;
    cout << cpy(src, startIndex, endIndex) << endl;
    break;
  }
 }
 return 0;
}
```

### 4 正整数格式输出

问题描述 :

内容：对于任意一个输入的位数不确定的正整数，实现以下格式输出函数：将该整数按照标准的三位分解格式输出。例如，当用户输入82668234时，程序应该输出82,668,234。并编写main函数测试该功能函数。

注意：**要求使用函数参数的地址传递方式实现。**

函数原型为：`void format(char *ptr, int digit); //第一个形参为字符型指针变量，第二个形参为输入的正整数`

功能：将输入的正整数按位转换成字符，并通过指针间址访问。从最低位开始计数，每三位添加字符','，实现格式转换。转换结束后，将转换结果输出到屏幕上。

输入说明 :

输入时，可输入任意组测试数据。每组测试数据包含一行，即输入一个整数。

组与组之间无空行。

输出说明 :

对于每组测试数据，输出对应的结果。

每行行首与行尾无多余空格，第一行之前与最后一行之后无多余空行。

输入范例 :

```
1234567890
123
12
1234
```

输出范例 :

```
1,234,567,890
123
12
1,234
```

```cpp
#include <iostream>
using namespace std;

void format(char *ptr, int digit) {
    int count = 0;
    while (digit > 0) {
        // 每三位添加一个逗号
        if (count != 0 && count % 3 == 0) {
            *(--ptr) = ',';
        }
        *(--ptr) = '0' + (digit % 10);
        digit /= 10;
        count++;
    }
    cout << ptr;
}

int main() {
    int digit;
    char tmp, *ptr;

    while (cin >> digit) {
        ptr = &tmp; // tmp仅用于指针初始化
        format(ptr, digit); // 格式化转换并输出
        cout << endl;
    }

    return 0;
}
```

当你运行这个程序时，它将按照以下步骤执行：

1. 在 `main` 函数中，声明了整数变量 `digit`、字符变量 `tmp` 和字符指针变量 `ptr`。
2. 进入 `while` 循环，在每次循环开始之前，从输入中读取一个整数并将其存储在 `digit` 中。
3. 将 `ptr` 的地址设置为 `&tmp`，这样 `ptr` 指向了字符变量 `tmp`。以此为基础新建了一个字符数组。
4. 调用 `format(ptr, digit)`，将 `ptr` 和 `digit` 作为参数传递给 `format` 函数。
5. 在 `format` 函数中，使用指针 `ptr` 来访问字符数组中的元素，它并不是指向最低位，而是指向一个临时的字符位置，用于存储转换后的字符。它从最低位开始将整数 `digit` 转换为字符，并在需要的地方插入逗号。
6. 将转换结果输出到屏幕上，然后在 `format` 函数返回到 `main` 函数之前，输出一个换行符。
7. 回到 `while` 循环的开头，继续下一次循环，直到没有更多的输入。
8. 程序结束，`main` 函数返回0，程序退出。

此程序的目的是将输入的正整数按照标准的三位分解格式输出。它使用函数参数的地址传递方式，通过指针间址访问字符数组，并在每三位之间插入逗号进行格式转换。转换结果通过调用 `cout` 输出到屏幕上。

希望这个解释能够帮助你理解程序的运行过程。如果还有其他问题，请随时提问。

### 5 字符串分析

问题描述 :

内容：对于任意一个输入的字符串（限定长度在100以内），实现以下功能函数：要求统计其中字符（包括空格）的个数，同时分别指出其中大、小写字母、数字以及其它字符的个数。最后将所有统计结果输出到屏幕上。并编写main函数测试该功能函数。

注意：**要求使用指针实现，函数的参数传递采用地址传递、引用传递方式。**

函数原型为：  `void string_analysis(char *ptr, int &total, int &cap, int &sma, int &num, int &oth);//total为所有字符的个数，cap为大写字母的个数，sma为小写字母的个数，num为数字的个数，oth为其它字符的个数`

输入说明 :

输入的字符串测试数据位于一行。

输出说明 :

对于测试数据，输出对应的分析结果。

第一行：大写字母的个数

第二行：小写字母的个数

第三行：数字的个数

第四行：其它字符的个数

第五行：所有字符的个数

输入范例 :

```
I am 21 years old.
```

输出范例 :

```
1
10
2
5
18
```

```cpp
#include <iostream>
using namespace std;

void string_analysis(char *ptr, int &total, int &cap, int &sma, int &num, int &oth)
{
    while(*ptr!='\0')
    {
        if(*ptr<='Z'&&*ptr>='A')
            cap++;
        else if(*ptr<='z'&&*ptr>='a')
            sma++;
        else if(*ptr<='9'&&*ptr>='0')
            num++;
        else
            oth++;
        ptr++;
    }
    total=cap+sma+num+oth;
}

int main(){

   char str[100];

   int total,cap,sma,num,oth;

   total = cap = sma = num = oth = 0;

   cin.get(str,100);

   string_analysis(str, total, cap, sma, num, oth);

   cout<<cap<<endl;

   cout<<sma<<endl;

   cout<<num<<endl;

   cout<<oth<<endl;

   cout<<total<<endl;
   
   return 0;
}
```

### 6 字符串转换为整型数值

问题描述 :

内容：对于任意一个输入的数字字符串（限定长度在100以内，允许有正负号,字符串内部无多余的空格），实现以下功能函数：将该数字字符串转换为整型数值。最后将转换结果输出到屏幕上。并编写main函数测试该功能函数。

注意：**要求使用指针实现，函数的参数传递采用地址传递方式。**

函数原型为：`int myatoi(char *string);`

输入说明 :

输入时，可输入任意组测试数据。每组测试数据包含一行，即输入一个数字字符串。

组与组之间无空行。

输出说明 :

对于每组测试数据，输出对应的转换结果。

每行行首与行尾无多余空格，第一行之前与最后一行之后无多余空行。

输入范例 :

```
-123
+345
```

输出范例 :

```
-123
345
```

```cpp
#include <iostream>
#include <cstring>
using namespace std;


int myatoi(char *string)
{
    int num=0;
    int mul=1;
    int len=strlen(string);
    if(string[0]=='+')
    {
        for(int i=len-1;string[i]!='+';i--)
        {
            num+=(string[i]-'0')*mul;
            mul*=10;
        }
    }
    else
    {
        for(int i=len-1;string[i]!='-';i--)
        {
            num-=(string[i]-'0')*mul;
            mul*=10;
        }
    }
    return num;
}

int main(){

   char str[100];

   while(cin>>str)
    cout<<myatoi(str)<<endl;

   return 0;

}
```

### 7 函数模板：两点间的距离

问题描述 :

使用模板函数，分别求出int型数的两点间的距离和浮点型数的两点间的距离。在main函数中测试运用模板函数。

函数原型为：

```cpp
template <class T>

T distance( T, T, T, T);
```

输入说明 :

每组测试数据为两行，格式如下：

i_x1 i_y1 i_x2 i_y2  //两个int型测试点的x坐标，y坐标，坐标之间用空格分隔

d_x1 d_y1 d_x2 d_y2  //两个double型测试点的x坐标，y坐标，坐标之间用空格分隔

行与行之间无多余的空行和空格。

输出说明 :

输出数据分两行，分别对应int型和double型的两点间的距离

行与行之间无多余的空行和空格。

输入范例 :

```
1 1 2 1
10.0 20.0 5.0 5.0
```

输出范例 :

```
1
15.8114
```

```cpp
#include <iostream>
#include <cmath>
using namespace std;

template <class T>

T distance( T x1, T y1, T x2, T y2)
{
    double dist=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
    return (T)dist;
}

int main( ){

   int i_x1, i_y1, i_x2, i_y2;

   double d_x1, d_y1, d_x2, d_y2;

   cin>>i_x1>>i_y1>>i_x2>>i_y2;

   cin>>d_x1>>d_y1>>d_x2>>d_y2;

   cout<<distance( i_x1, i_y1, i_x2, i_y2 )<<endl;

   cout<<distance(d_x1, d_y1, d_x2, d_y2 )<<endl;

   return 0;

}
```

在C++中，函数模板是一种通用函数，可以用于多种类型的数据。通过使用函数模板，可以编写一次代码，然后用于多种不同类型的数据，从而提高代码的复用性和灵活性。在函数模板中，使用模板参数来表示类型参数，以便在编译时根据实际类型生成具体的函数代码。

- 如果一组重载函数仅仅是参数的类型不一样，程序的逻辑完全一样，那么这一组重载函数可以写成一个函数模板。
- 所谓的函数模板就是实现类型的参数化（泛型化），即把函数中某些形式参数的类型定义成参数，称为模板参数
- 在函数调用时，编译器根据实际参数的类型确定模板参数的值，生成不同的模板参数。

函数模板的调用是在编译时进行的，它可以根据函数参数的类型自动推断出模板参数的类型，并生成相应的函数代码。在函数调用时，需要指定函数模板的名称和模板参数，以便编译器能够实例化出具体的函数代码。

函数模板可以用来创建一个通过功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。

定义形式为

```cpp
template <class 类型名1，class 类型名2，...>

返回类型 函数名（形参表）
{
	函数体；
}
```

注意：
- template关键字声明的是模板
- <>中是模板的参数表，可以有一项或多项，其中的类型名称为参数化类型，是一种抽象类型或可变类型
- class是类型关键字，也可以用typename作为关键字
- 函数返回值类型可以是普通类型，也可以是模板参数表中指定的类型
- 模板参数表中的参数类型可以是普通类型

```cpp
template<class T>
T add(T a, T b) {
    return a + b;
}
```

### 8 盒子类（求助GPT）

问题描述 :

定义盒子Box类，计算盒子的体积及表面积。Box类包括：

私有数据成员：

```
int Length //Box的长度

int Width   //Box的宽度

int Height  //Box的高度
```

公有成员函数：

```
void InitBox( int x, int y, int z); //设置Box的尺寸

void setVolume( );            //计算Box的体积

void setArea( );             //计算Box的表面积

void show( );              //输出盒子的信息，输出形式见“输出说明”
```

输入说明 :

输入三个整数：Length（长）、Width（宽）、Height（高），整数之间以空格分隔。

输入的整数都为非负数。

输出说明 :

输出三行：

第一行输出Length（长）、Width（宽）、Height（高），整数之间以一个空格分隔

第二行输出体积

第三行输出表面积

输出行之间无多余的空行和空格

输入范例 :`1 2 3`

输出范例 :

```
1 2 3
6
22
```

```cpp
#include <iostream>
using namespace std;

class Box
{
private:
    int Length; //Box的长度
    int Width;   //Box的宽度
    int Height;  //Box的高度
public:
    void InitBox( int x, int y, int z)
    {
        Length=x;
        Width=y;
        Height=z;
    }

    void setVolume( )
    {
        int volume=Length*Width*Height;
    }

    void setArea( )
    {
        int area=2*(Length*Width+Width*Height+Height*Length);
    }

    void show( )
    {
        cout<<Length<<" "<<Width<<" "<<Height<<endl;
        cout<<Length*Width*Height<<endl;
        cout<<2*(Length*Width+Width*Height+Height*Length)<<endl;
    }
};

int main()

{

     int intLength, intWidth, intHeight;

     Box box;

     cin>>intLength;

     cin>>intWidth;

     cin>>intHeight;

     box.InitBox(intLength,intWidth,intHeight);

     box.setVolume();

     box.setArea();

     box.show();

     return 0;

}
```

根据题目的要求，我们需要完成一个用于计算盒子体积和表面积的类 `Box`，并在 `main` 函数中使用该类进行计算和输出。

下面是完成这个程序的代码：

```cpp
#include <iostream>
using namespace std;

class Box {
private:
    int Length; // Box的长度
    int Width;  // Box的宽度
    int Height; // Box的高度
    int Volume; // Box的体积
    int Area;   // Box的表面积

public:
    void InitBox(int x, int y, int z); // 设置Box的尺寸
    void setVolume();                  // 计算Box的体积
    void setArea();                    // 计算Box的表面积
    void show();                       // 输出盒子的信息
};

void Box::InitBox(int x, int y, int z) {
    Length = x;
    Width = y;
    Height = z;
}

void Box::setVolume() {
    Volume = Length * Width * Height;
}

void Box::setArea() {
    Area = 2 * (Length * Width + Width * Height + Height * Length);
}

void Box::show() {
    cout << Length << " " << Width << " " << Height << endl;
    cout << Volume << endl;
    cout << Area << endl;
}

int main() {
    int intLength, intWidth, intHeight;
    Box box;

    cin >> intLength;
    cin >> intWidth;
    cin >> intHeight;

    box.InitBox(intLength, intWidth, intHeight);
    box.setVolume();
    box.setArea();
    box.show();

    return 0;
}
```

在这个程序中，我们首先定义了 `Box` 类，包含了私有数据成员 `Length`、`Width` 和 `Height`，以及公有成员函数 `InitBox`、`setVolume`、`setArea` 和 `show`。

在 `main` 函数中，我们首先声明了输入的整数变量 `intLength`、`intWidth` 和 `intHeight`，然后创建了 `Box` 类的对象 `box`。

接着，通过 `cin` 输入三个整数，分别为 `Length`、`Width` 和 `Height`，并调用 `box.InitBox` 方法来设置盒子的尺寸。

然后，我们分别调用 `box.setVolume` 和 `box.setArea` 方法来计算盒子的体积和表面积。

最后，调用 `box.show` 方法来输出盒子的信息，包括尺寸、体积和表面积。

希望这个程序满足了题目的要求。如果还有其他问题，请随时提问。

### 9 学生数组排序（求助GPT）

问题描述 :

输入3个学生的姓名和英语、数学成绩，需要求每个学生的总成绩并对3个学生按总成绩降序输出，请编写一个类student,实现该功能。

student类的数据成员包括（但不限于）name（姓名，类型为string）、math(数学)、english(英语)。要求用成员函数实现以下功能：

1、使用构造函数给各属性赋初值

2、调用实例方法计算学生总成绩

3、其它必要的功能

另设计一个函数对学生按总成绩降序排列，并在main函数中输出学生信息。

main函数的实现参考如下代码，请设计student类和sortStudent函数。

```cpp
int main()

{

    student s[3],temp;

    string sName;//或char sName[20];

    int sMath, sEnglish;

    int i;



    for(i=0; i<3; i++)

    {

        cin>>sName>>sMath>>sEnglish;

        s[i]=student(sName, sMath, sEnglish);

        s[i].calcTotal();

    }

    sortStudent(s, 3);

    for(i=0;i<3;i++)

    {

        cout<<s[i].getName()<<" "<<s[i].getMath()<<" "<<s[i].getEnglish()<<" "<<s[i].getTotal()<<endl;

    }

    return 0;

}
```

main函数中声明了一个数组，包含三个对象，然后输入必要信息，给三个对象赋值并计算总成绩，之后对数组排序并按总成绩降序输出学生姓名及其成绩。

对于两个总成绩相同的学生，排序后不改变他们原来的顺序。

输入说明 :

输入三行，表示三个学生的信息，每一行包括学生姓名、数学成绩、英语成绩，中间以空格分隔。  

成绩为0到100之间的整数。

输出说明 :

输出三行，按总成绩降序输出学生姓名及其数学成绩、英语成绩、总成绩。

如果有两个学生总成绩相同，那么原来排在前的学生先输出。

输入范例 :

```
John 80 90
Kevy 85 90
Lucy 90 80
```

输出范例 :

```
Kevy 85 90 175
John 80 90 170
Lucy 90 80 170
```

自己写的程序不能通过第一个数据测试，不加break时可以通过这个数据的测试。

```cpp
#include <iostream>
using namespace std;

class student
{
private:
    string name;
    int Math;
    int English;

public:
    int total;
    student()
    {

    }
    student(string sName,int sMath,int sEnglish)
    {
        name=sName;
        Math=sMath;
        English=sEnglish;
    }
    void calcTotal()
    {
        total=Math+English;
    }
    string getName()
    {
        return name;
    }
    int getMath()
    {
        return Math;
    }
    int getEnglish()
    {
        return English;
    }
    int getTotal()
    {
        return total;
    }
};

void sortStudent(student a[], int n)
{
    student tmp;
    int k;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i+1;j<n;j++)
        {
            if(a[i].total<a[j].total)
            {
                k=j;
                break;
            }
        }
        tmp=a[i];
        a[i]=a[k];
        a[k]=tmp;
    }

}

int main()

{

    student s[3],temp;

    string sName;//或char sName[20];

    int sMath, sEnglish;

    int i;



    for(i=0; i<3; i++)

    {

        cin>>sName>>sMath>>sEnglish;

        s[i]=student(sName, sMath, sEnglish);

        s[i].calcTotal();

    }

    sortStudent(s, 3);

    for(i=0;i<3;i++)

    {

        cout<<s[i].getName()<<" "<<s[i].getMath()<<" "<<s[i].getEnglish()<<" "<<s[i].getTotal()<<endl;

    }

    return 0;

}
```

我检查了你提供的程序，并发现其中存在一个问题，即在排序函数 `sortStudent` 中的比较和交换逻辑有误。下面是修正后的代码：

```cpp
void sortStudent(student a[], int n)
{
    student tmp;
    int k;
    for (int i = 0; i < n - 1; i++)
    {
        k = i;
        for (int j = i + 1; j < n; j++)
        {
            if (a[j].total > a[k].total) // 修改比较逻辑
            {
                k = j;
            }
        }
        tmp = a[i];
        a[i] = a[k];
        a[k] = tmp;
    }
}
```

在原来的代码中，比较逻辑错误地使用了 `a[i].total` 和 `a[j].total` 进行比较，而实际上应该使用 `a[j].total` 和 `a[k].total` 进行比较，以确保选择出最大的元素进行交换。

修正后的代码将比较逻辑修改为 `a[j].total > a[k].total`，以确保每次找到最大的元素索引 `k`。

希望这次的修正解决了问题。如果还有其他问题，请随时提问。

题目要求我们创建一个`student`类，并在`main`函数中使用这个类的对象。同时，我们需要定义一个函数`sortStudent`来对学生对象数组进行排序。

首先，我们需要创建一个`student`类。这个类包含四个私有成员：`name`、`math`、`english`和`total`。同时，我们提供公共的构造函数和几个成员函数。

其次，我们需要定义`sortStudent`函数。这个函数接受一个学生对象数组和一个整数作为参数，然后使用稳定的排序算法对数组进行排序。这里我们使用冒泡排序，因为它是稳定的排序算法，可以保证两个总成绩相同的学生排序后不改变他们原来的顺序。

最后，在`main`函数中，我们创建一个学生对象数组，然后输入学生的信息，计算总成绩，对学生对象数组进行排序，最后输出排序后的学生信息。

以下是完成的C++程序：

```cpp
#include <iostream>
#include <string>
using namespace std;

class student
{
    string name;
    int math;
    int english;
    int total;
public:
    student(string n, int m, int e): name(n), math(m), english(e), total(m+e) {}
    student(){}
    void calcTotal() {
        total = math + english;
    }
    string getName() {
        return name;
    }
    int getMath() {
        return math;
    }
    int getEnglish() {
        return english;
    }
    int getTotal() {
        return total;
    }
};

void sortStudent(student s[], int n)
{
    for(int i=0; i<n-1; i++)
    {
        for(int j=0; j<n-1-i; j++)
        {
            if(s[j].getTotal() < s[j+1].getTotal())
            {
                student temp = s[j];
                s[j] = s[j+1];
                s[j+1] = temp;
            }
        }
    }
}

int main()
{
    student s[3];
    string sName;
    int sMath, sEnglish;
    int i;

    for(i=0; i<3; i++)
    {
        cin>>sName>>sMath>>sEnglish;
        s[i]=student(sName, sMath, sEnglish);
        s[i].calcTotal();
    }

    sortStudent(s, 3);

    for(i=0;i<3;i++)
    {
        cout<<s[i].getName()<<" "<<s[i].getMath()<<" "<<s[i].getEnglish()<<" "<<s[i].getTotal()<<endl;
    }

    return 0;
}
```

### 10 寻找最好成绩

问题描述 :

建立一个对象数组，内放若干个学生的学习数据（学号，成绩）。

设计一函数max,使用学生对象数组作为参数，在max函数里找出这些学生中成绩最高者，并输出其学号及成绩。

在main函数中使用并测试之。在main函数中读入学生数据，创建学生对象数组，并调用max函数输出成绩最高者。

如果有多名学生成绩最高，则按照输入的先后顺序输出这些学生的信息。

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Student{

private:

          int num;  //学号

          float score; //分数

public:

           Student(int num)
           {
               this->num=num;
           }
           Student(){}

           void SetScore(float score)
           {
               this->score=score;
           }

           int GetNum()
           {
               return num;
           }

           float GetScore()
           {
               return score;
           }
           friend void max( Student arr[] ,int n);

};

void max( Student arr[] ,int n)
{
    float max=arr[0].score;
    vector<int> idx;
    for(int i=0;i<n;i++)
    {
        if(max<arr[i].GetScore())
        {
            max=arr[i].GetScore();
        }
    }
    for(int i=0;i<n;i++)
    {
        if(max==arr[i].GetScore())
            idx.push_back(i);
    }
    for(int j=0;j<idx.size();j++)
    {
        cout<<arr[idx[j]].GetNum()<<" "<<arr[idx[j]].GetScore()<<endl;
    }
}

int main( )

{

   int i, n, num;

   float score;

   cin>>n;

   Student stu[n];

   for( i = 0; i < n; i++)

   {

        cin>>num>>score;

        stu[i] = Student(num);

        stu[i].SetScore(score);

    }

    max(stu, n );

    return 0;

}
```

注意：通过构造函数传值时，要写`this->num=num;`不要写`num=num;`否则出现的都是随机值

### 11 查找学生

问题描述 :

实验目的：学习string类型的使用；学习对象数组的使用。

实验内容：

设计一个student类，包含学生学号、姓名、语文成绩、数学成绩。

现有n个学生，保存在一个数组中，请对每个学生，分别计算语数两门课的平均成绩。

此外，再设计一个函数findStudent，根据传入的学生数组和需要查找的姓名searchName，查找姓名中包含searchName的学生。比如输入”huang”，则输出所有姓名中包含”huang”的学生的成绩。

分析：

类中的属性可包括（但不仅限于）：number, name, chinese, math, average。其中，学号number为int类型，name为string类型，成绩为double类型。

类中的方法可包括（但不仅限于）：

setChinese、getChinese、setMath、getMath、calcAverage、getAverage以及包含两个形参（学号和姓名）的构造函数。

说明：

由于成绩需要在0到100之间，因此语文成绩和数学成绩不能随意赋值，所以不能将chinese和math这两个属性设置为public，而是设置为private，同时增加两个方法，bool setChinese (int score)，bool setMath(int score)。

这两个方法的逻辑为（以setChinese为例）：

```cpp
bool setChinese (double score)

{

   //如果形参score在0到100之间，则将chinese赋值为score，并返回true，否则将chinese赋值为0，并返回false

}
```

相应地，还需要增加getChinese方法，该方法里不需要进行什么处理，直接return chinese即可。可如下实现：

```cpp
double getChinese()

{

       return chinese;

}
```

对于number和name，一般也设置为private，仅通过构造函数给它们赋值，再增加两个方法： getNumber以及getName获取它们的值。

输入说明 :

输入的第一行为学生的数目n，

其后n行为n个学生的数据，每个学生的数据占一行，包括学号、姓名、语文成绩、数学成绩，其间以空格分隔。

再后一行（最后一行）为需要查找的姓名。

每行的开头和结尾无多余的空格。

学号为整数，姓名为字符串，成绩为实数。姓名中不包含空格。

输出说明 :

输出符合条件的学生的学号、姓名、语文成绩、数学成绩及平均成绩，其间以一个空格分隔。

如果输出多名学生，则每名学生独占一行。

输出无多余空行及多余空格。

输出的实数以cout的默认输出格式为准，比如实数82输出就是“82”，后面不会有小数点及“0”。

如果未找到，则输出“Not found.”，不包括引号。

输入范例 :

```
10
100 stu1 80 81
101 stu12 82 83
102 stu13 1000 81
105 stu5 80 82
104 stu4 80 81
103 stu3 99 81
106 stu6 86 88.5
107 stu7 80 81
108 John 0 0
109 Kevin 0 100
stu1
```

输出范例 :

```
100 stu1 80 81 80.5
101 stu12 82 83 82.5
102 stu13 0 81 40.5
```

```cpp
#include <iostream>
#include <string>
using namespace std;

class Student{

private:
    int number;
    string name;
    double chinese;
    double math;
    double average;

public:

           Student(int num, string s)
           {
               number=num;
               name=s;
           }
           Student(){}

           int getNumber()
           {
               return number;
           }
           string getName()
           {
               return name;
           }

           bool setChinese (double score)
           {
               if(score<=100&&score>=0)
               {
                   chinese=score;
                   return true;
               }
               else
               {
                   chinese=0;
                   return false;
               }

           }
           double getChinese()
           {
               return chinese;
           }

           bool setMath (double score)
           {
               if(score<=100&&score>=0)
               {
                   math=score;
                   return true;
               }
               else
               {
                   math=0;
                   return false;
               }

           }

           double getMath()
           {
               return math;
           }

           void calcAverage()
           {
               average=(chinese+math)/2.0;

           }

           double getAverage()
           {
               calcAverage();
               return average;
           }

};

void findStudent(Student stu[], int n, string searchName)
{
    int count=0;
    for(int i=0;i<n;i++)
    {
        if((stu[i].getName()).find(searchName)!=string::npos)
        {
            cout<<stu[i].getNumber()<<" "<<stu[i].getName()<<" "<<stu[i].getChinese()<<" "<<stu[i].getMath()<<" "<<stu[i].getAverage()<<endl;
            count++;
        }
    }
    if(count==0) cout<<"Not found."<<endl;
}



int main()

{

  int n,i;

  int number;

  string name, searchName;

  double math,chinese;

  cin>>n;

  Student stu[n];

  for(i=0;i<n;i++)

  {

    cin>>number>>name>>chinese>>math;

    stu[i] = Student(number, name);

    stu[i].setChinese(chinese);

    stu[i].setMath(math);

  }

  cin>>searchName;  //输入需要查找的姓名

  findStudent(stu, n, searchName);  //调用函数，查找学生，输出信息

  return 0;

}
```

### 12 长方形集合

问题描述 :

定义一个Point类，包括两个私有属性：int x, int y，它们分别表示一个点的x和y座标。

再定义构造函数：`Point(int x, int y)`，即传两个参数，构造一个点对象。

定义一个Rectangle类，包括四个私有属性：`Int num, Point topLeft, int width, int height，`

它们分别表示长方形的编号（长方形的编号不重复）、左上角顶点的座标，以及横向的宽度和纵向的高度。

注意：在计算机系统里，座标系如下定义：屏幕的左上角的座标是（0,0），x轴是横轴，屏幕的最右端x值最大，y轴是纵轴，屏幕的最下方y值最大。

再定义构造函数：`Rectangle(int num, int x, int y, int width, int height)`

以及实例方法：

`int getArea()    //获取该图形的面积`

`bool isIn(Point p)   //判断传入的点是否在该图形之内（不包括边界），如果在内部返回true，否则返回false`

定义一个RectangleCollection类，包括两个私有属性：

`Rectangle rects[100];   //一个包含长方形的数组，最多100个元素`

`int count;            //以上数组中长方形的实际个数`

还包括实例方法：

`void addRectangle(Rectangle r)//添加一个长方形到数组中，并count++`

`void deleteRectangle(int num) //根据num从数组中删除一个长方形（该长方形的编号等于num）`

`int inRects(Point p)//根据传入的p，判断p位于rects数组中的哪些长方形之内，返回这些长方形面积之和。`

请根据自己的需要定义其它构造函数或者其它方法和属性。

使用main函数测试以上RectangleCollection类的addRectangle方法、deleteRectangle方法以及inRects方法。

输入说明 :

可输入多组测试数据，每组测试数据包含两行：  

第一行输入一个操作的种类，  

1：增加一个长方形  

2：删除一个长方形  

3：求包含某一指定点的所有长方形的面积和  

第二行输入所需要的参数：  

对于第1个操作，第二行输入长方形r的信息，包括编号num，左上角顶点x座标、左上角顶点y座标、宽度、高度。  

对于第2个操作，第二行输入一个编号num  

对于第3个操作，第二行输入一个点p的信息，包括其x座标和y座标。  

所有输入都为非负整数，之间以一个空格分隔。无多余空格或空行，两组测试数据之间也无空行。

在输入时，将保证不会向长方形集合中添加一个编号（num）已经存在的长方形。

输出说明 :

仅第3个操作有输出，因此，测试数据中必然包含第3个操作。  

第3个操作仅输出一个整数，占一行。  

如果有多个输出，每个输出占一行，行首与行尾无空格，中间无空行。

输入范例 :

```
1
1 4 4 4 4
1
3 3 3 3 3
1
2 2 3 5 4
3
5 5
2
3
3
5 5
1
3 3 3 4 4
3
5 5
```

输出范例 :

```
45
36
52
```

这个错误是由于在 `Rectangle` 类的构造函数中，没有为 `Point` 类的成员 `topLeft` 显示调用构造函数，导致编译器无法找到默认构造函数 `Point::Point()`。要解决这个问题，你可以修改 `Rectangle` 类的构造函数，显式调用 `Point` 类的构造函数来创建 `topLeft` 对象。

下面是修改后的代码：

```cpp
class Point
{
private:
    int x;
    int y;

public:
    Point(int x, int y)
    {
        this->x = x;
        this->y = y;
    }
    int getX()
    {
        return x;
    }
    int getY()
    {
        return y;
    }
};

class Rectangle
{
private:
    int num;
    Point topLeft;
    int width;
    int height;

public:
    Rectangle(int num, int x, int y, int width, int height)
    {
        this->num = num;
        this->topLeft = Point(x, y); // 调用Point类的构造函数来创建topLeft对象
        this->width = width;
        this->height = height;
    }
    int getArea()
    {
        return width * height;
    }
    bool isIn(Point p)
    {
        if ((p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width) && (p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height))
            return true;
        else
            return false;
    }
};
```

通过在 `Rectangle` 类的构造函数中显式调用 `Point` 类的构造函数来为 `topLeft` 成员创建对象，这样就可以避免编译错误。现在，代码应该能够正确编译和运行。

希望这次的修改解决了你的问题。如果还有其他疑问，请随时提问。

抱歉，我之前的回答有误。错误的根本原因是在 `Rectangle` 类中，没有为 `topLeft` 成员提供默认构造函数。为了解决这个问题，你可以在 `Point` 类中添加一个默认构造函数，以便在 `Rectangle` 类中使用。

以下是修正后的代码：

```cpp
class Point
{
private:
    int x;
    int y;

public:
    Point() {} // 添加默认构造函数

    Point(int x, int y)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
};

class Rectangle
{
private:
    int num;
    Point topLeft;
    int width;
    int height;

public:
    Rectangle(int num, int x, int y, int width, int height)
    {
        this->num = num;
        this->topLeft = Point(x, y);
        this->width = width;
        this->height = height;
    }

    int getArea()
    {
        return width * height;
    }

    bool isIn(Point p)
    {
        if ((p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width) && (p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height))
            return true;
        else
            return false;
    }
};
```

通过为 `Point` 类添加默认构造函数，可以解决编译错误。现在，代码应该能够正确编译和运行。

非常抱歉之前的错误造成的困扰。希望这次的修改能够解决问题。如果还有其他疑问，请随时提问。

```cpp
#include <iostream>
#include <string>
using namespace std;
class Point
{
private:
    int x;
    int y;

public:
    Point(){}// 添加默认构造函数
    Point(int x, int y)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
};

class Rectangle
{
private:
    int num;
    Point topLeft;
    int width;
    int height;

public:
    Rectangle(){}
    Rectangle(int num, int x, int y, int width, int height)
    {
        this->num = num;
        this->topLeft = Point(x, y);// 调用Point类的构造函数来创建topLeft对象
        this->width = width;
        this->height = height;
    }

    int getArea()
    {
        return width * height;
    }
    int getNum()
    {
        return num;
    }

    bool isIn(Point p)
    {
        if (p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width && p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height)
            return true;
        else
            return false;
    }
};

class RectangleCollection
{
private:
    Rectangle rects[100];
    int count;

public:
    RectangleCollection()
    {
        count = 0;
    }

    void addRectangle(Rectangle r)
    {
        rects[count] = r;
        count++;
    }


    void deleteRectangle(int num)
    {
        for (int i = 0; i < count; i++)
        {
            if (rects[i].getNum() == num)
            {
                for (int j = i; j < count - 1; j++)
                {
                    rects[j] = rects[j + 1];
                }
                count--;
                break;
            }
        }
    }

    int inRects(Point p)
    {
        int sumArea = 0;
        for (int i = 0; i < count; i++)
        {
            if (rects[i].isIn(p))
            {
                sumArea += rects[i].getArea();
            }
        }
        return sumArea;
    }
};

int main()
{
    int num, topLeftX, topLeftY, width, height;
    int px, py;
    int op;
    RectangleCollection rc;
    Rectangle r;
    Point p;

    while (cin >> op)
    {
        switch (op)
        {
            case 1:
                cin >> num >> topLeftX >> topLeftY >> width >> height;
                r =Rectangle(num, topLeftX, topLeftY, width, height);
                rc.addRectangle(r);
                break;
            case 2:
                cin >> num;
                rc.deleteRectangle(num);
                break;
            case 3:
                cin >> px >> py;
                p=Point(px, py);
                cout << rc.inRects(p) << endl;
                break;
        }
    }
    return 0;
}
```

这段程序首先定义了 `Point` 类和 `Rectangle` 类，分别表示点和长方形。然后，定义了 `RectangleCollection` 类，表示长方形集合。`RectangleCollection` 类中包含了添加长方形、删除长方形和计算点在长方形集合内的面积和的方法。

在主函数 `main` 中，程序读取输入的操作种类，并根据不同的操作种类进行相应的处理。具体地，当操作种类为 1 时，读取长方形的信息并将其添加到长方形集合中；当操作种类为 2 时，根据给定的编号从长方形集合中删除相应的长方形；当操作种类为 3 时，读取点的信息，并计算点在长方形集合内的面积和，并将结果输出。

程序使用 `RectangleCollection` 的对象 `collection` 来管理长方形集合，并根据输入的操作种类和参数调用相应的方法。程序会持续读取输入，直到结束。

### 13 类和对象：使用日期类计算相隔天数

要求：使用日期类，设计1个用户函数CalDay，计算出两个日期之间的相隔天数，在屏幕上输出结果。

CalDay函数的原型定义如下：

`int CalDay(const Date &d1, const Date &d2) //d1:较小的日期赋给d1，d2:较大的日期`

输入说明 :

测试数据为2行，

第一行：开始日期（分别为年、月、日的值，值与值之间用空格分隔），例如：2010 4 7

第一行：结束日期（分别为年、月、日的值，值与值之间用空格分隔），例如：2017 4 7

注意：开始日期在结束日期之前

输出说明 :

输出结果为截止日期与开始日期的相隔天数。

输入范例 :

```
2010 2 3
2017 3 17
```

输出范例 :2599

```cpp
#include <iostream>
using namespace std;

class Date{

     int year;

     int month;

     int day;

   public:

     Date(int y,int m,int d):year(y),month(m),day(d){};

     Date(){}

     int getYear() const {return year;}

     int getMonth() const {return month;}

     int getDay() const {return day;}

     int CalDay(const Date &d1, const Date &d2);

     int dayOfYear(int year,int month,int day);

     bool IsLeap(int year);


};

bool Date::IsLeap(int year)
{
    if(year%400==0||year%4==0&&year%100!=0)
        return true;
    else
        return false;
}

int Date::dayOfYear(int year,int month,int day)
{
    int dist;

    int days[2][12]={{31,29,31,30,31,30,31,31,30,31,30,31},{31,28,31,30,31,30,31,31,30,31,30,31}};

    if(IsLeap(year))
    {
        if(month==1) dist=day;
        else
        {
            int sum=0;
            for(int i=0;i<month-1;i++)
                sum+=days[0][i];
            dist=sum+day;

        }
    }
    else
    {
        if(month==1) dist=day;
        else
        {
            int sum=0;
            for(int i=0;i<month-1;i++)
                sum+=days[1][i];
            dist=sum+day;

        }
    }
    return dist;
}




int Date::CalDay(const Date &d1, const Date &d2)
{
    int total;
    if(d1.getYear()==d2.getYear())
    {
        total=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay())-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
    }
    else if(d2.getYear()-d1.getYear()==1)
    {
        if(IsLeap(d1.getYear()))
        {
            total+=366-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay())+dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
        else
        {
            total+=365-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay())+dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
    }
    else
    {
        if(IsLeap(d1.getYear()))
        {
            total+=366-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
            for(int i=d1.getYear()+1;i<d2.getYear();i++)
            {
                if(IsLeap(i))
                    total+=366;
                else
                    total+=365;
            }
            total+=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
        else
        {
            total+=365-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
            for(int i=d1.getYear()+1;i<d2.getYear();i++)
            {
                if(IsLeap(i))
                    total+=366;
                else
                    total+=365;
            }
            total+=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
    }
    return total;
}

int main(){

    int y1,m1,d1,y2,m2,d2;

    cin>>y1>>m1>>d1;

    cin>>y2>>m2>>d2;

    Date date1(y1,m1,d1);

    Date date2(y2,m2,d2);

    cout<<CalDay(date1,date2);

    return 0;

}
```

上面的程序报错E:\cpp\ClassDesign\main1.cpp|137|error: 'CalDay' was not declared in this scope|

在`main`函数中，您需要使用类的实例来调用成员函数`CalDay`。由于`CalDay`是`Date`类的成员函数，您需要使用实例对象来调用它。以下是修改后的代码：

```cpp
int main() {
    int y1, m1, d1, y2, m2, d2;
    cin >> y1 >> m1 >> d1;
    cin >> y2 >> m2 >> d2;
    Date date1(y1, m1, d1);
    Date date2(y2, m2, d2);
    cout << date1.CalDay(date1, date2); // 使用实例对象调用 CalDay 函数
    return 0;
}
```

在`cout`语句中，使用`date1.CalDay(date1, date2)`来调用`CalDay`函数。

这样修改后，您的程序应该能够成功编译和运行，不再报错。如果您还有其他问题，请随时提问。

```cpp
#include <iostream>
using namespace std;

class Date{

     int year;

     int month;

     int day;

   public:

     Date(int y,int m,int d):year(y),month(m),day(d){};

     Date(){}

     int getYear() const {return year;}

     int getMonth() const {return month;}

     int getDay() const {return day;}

     int CalDay(const Date &d1, const Date &d2);

     int dayOfYear(int year,int month,int day);

     bool IsLeap(int year);


};

bool Date::IsLeap(int year)
{
    if(year%400==0||year%4==0&&year%100!=0)
        return true;
    else
        return false;
}

int Date::dayOfYear(int year,int month,int day)
{
    int dist=0;

    int days[2][12]={{31,29,31,30,31,30,31,31,30,31,30,31},{31,28,31,30,31,30,31,31,30,31,30,31}};

    if(IsLeap(year))
    {
        if(month==1) dist=day;
        else
        {
            int sum=0;
            for(int i=0;i<month-1;i++)
                sum+=days[0][i];
            dist=sum+day;

        }
    }
    else
    {
        if(month==1) dist=day;
        else
        {
            int sum=0;
            for(int i=0;i<month-1;i++)
                sum+=days[1][i];
            dist=sum+day;

        }
    }
    return dist;
}




int Date::CalDay(const Date &d1, const Date &d2)
{
    int total=0;
    if(d1.getYear()==d2.getYear())
    {
        total=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay())-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
    }
    else if(d2.getYear()-d1.getYear()==1)
    {
        if(IsLeap(d1.getYear()))
        {
            total+=366-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay())+dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
        else
        {
            total+=365-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay())+dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
    }
    else
    {
        if(IsLeap(d1.getYear()))
        {
            total+=366-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
            for(int i=d1.getYear()+1;i<d2.getYear();i++)
            {
                if(IsLeap(i))
                    total+=366;
                else
                    total+=365;
            }
            total+=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
        else
        {
            total+=365-dayOfYear(d1.getYear(),d1.getMonth(),d1.getDay());
            for(int i=d1.getYear()+1;i<d2.getYear();i++)
            {
                if(IsLeap(i))
                    total+=366;
                else
                    total+=365;
            }
            total+=dayOfYear(d2.getYear(),d2.getMonth(),d2.getDay());
        }
    }
    return total;
}

int main() {
    int y1, m1, d1, y2, m2, d2;
    cin >> y1 >> m1 >> d1;
    cin >> y2 >> m2 >> d2;
    Date date1(y1, m1, d1);
    Date date2(y2, m2, d2);
    cout << date1.CalDay(date1, date2); // 使用实例对象调用 CalDay 函数
    return 0;
}
```

注意：定义变量要赋初值

### 14 对象数组和对象指针

问题描述 :

要求：在给定的Student类的基础上建立一个对象数组，内放n个学生的数据（学号，分数）。请设计一个用户函数max，用指向对象的指针作为函数参数。max函数的功能是找出这n个学生中成绩最高者（假定无相同的成绩），并输出其学号。

输入说明 :

第一行：学生数目n。

第二行至第n+1行：每行输入：学号 分数。 二者之间以空格分隔，行与行之间无空行。

输出说明 :

最高分的学生学号 分数。二者之间以空格分隔

输入范例 :

```
5
1001 70.5
1002 78
1003 68
1004 82.5
1005 81
```

输出范例 :

```
1004 82.5
```

```cpp
#include <iostream>
using namespace std;

class Student{

   public:

      void Set_StuNum(int stu_num)
      {
          this->stu_num=stu_num;
      }

      int Get_StudNum()
      {
          return stu_num;
      }

      void Set_Score(float score)
      {
          this->score=score;
      }

      float Get_Score()
      {
          return score;
      }

   private:

      int stu_num;

      float score;

};


void max(Student *ptr, int n, int & max_stu_num, float & max_score)
{
    max_stu_num=(*ptr).Get_StudNum();
    max_score=(*ptr).Get_Score();
    for(int i=0;i<n;i++)
    {
        if(max_score<(*ptr).Get_Score())
        {
            max_stu_num=(*ptr).Get_StudNum();
            max_score=(*ptr).Get_Score();
        }
        ptr++;
    }
    cout<<max_stu_num<<" "<<max_score;
}




int main(){

  int n, stu_num, max_stu_num;

  float score, max_score;

  cin>>n;



  Student stu[n];

  for( int i = 0; i < n; i++ ){

    cin>>stu_num>>score;

    stu[i].Set_StuNum(stu_num);

    stu[i].Set_Score(score);

  }

  max(stu, n, max_stu_num, max_score);

  return 0;

}
```

### 15 学生成绩转换（友元函数）

问题描述 :

描述：有一个学生类Student,包括学号、成绩（百分制）。要求设计一个友元函数Score_Trans，将百分制成绩转换成对应的等级输出到屏幕上：大于等于90：优；80~90：良；70~79：中；60~69：及格；小于60：不及格。

输入说明 :

第一行：学生数目n。

第二行至第n+1行：每行输入：学号 分数。 二者之间以空格分隔，行与行之间无空行。

输出说明 :

第一行之n行：学生学号 分数登机。二者之间以空格分隔，行与行之间无空行

输入范例 :

```
5
1001 70.5
1002 98
1003 68
1004 82.5
1005 58
```

输出范例 :

```
1001 中
1002 优
1003 及格
1004 良
1005 不及格
```

```cpp
#include <iostream>
using namespace std;

class Student{

   public:

      void Set_StuNum(int stu_num)
      {
          this->stu_num=stu_num;
      }

      int Get_StudNum()
      {
          return stu_num;
      }

      void Set_Score(float score)
      {
          this->score=score;
      }

      float Get_Score()
      {
          return score;
      }
      friend void Score_Trans(Student &s)
      {
          if(s.Get_Score()<=100&&s.Get_Score()>=90)
          {
                cout<<s.Get_StudNum()<<" "<<"优";
          }
          else if(s.Get_Score()<=89&&s.Get_Score()>=80)
          {
                cout<<s.Get_StudNum()<<" "<<"良";
          }
          else if(s.Get_Score()<=79&&s.Get_Score()>=70)
          {
                cout<<s.Get_StudNum()<<" "<<"中";
          }
          else if(s.Get_Score()<=69&&s.Get_Score()>=60)
          {
                cout<<s.Get_StudNum()<<" "<<"及格";
          }
          else
          {
                cout<<s.Get_StudNum()<<" "<<"不及格";
          }
      }

   private:

      int stu_num;

      float score;

};

int main(){

  int n, i, stu_num, max_stu_num;

  float score, max_score;

  cin>>n;
  
  Student stu[n];

  for( i = 0; i < n; i++ ){

    cin>>stu_num>>score;

    stu[i].Set_StuNum(stu_num);

    stu[i].Set_Score(score);

  }

  for( i = 0; i < n; i++ ){

    Score_Trans(stu[i]);

    if(i < n - 1) cout<<endl;

  }
  return 0;
}
```

### 16 计算学生总评成绩并排序（友元函数）

问题描述 :

问题描述：试定义一个实现计算学生课程成绩的类Student，对学生学期总评成绩进行计算并排序。具体要求如下：

(1)私有数据成员:

```
int norm, ex, final,overall：分别表示学生的平时成绩、实验成绩、期末考试和总评成绩 

char name[15]：学生姓名
```

(2)公有成员函数:  

```
void init(char *name1, int nor1, int ex1, int fin1); //用参数name1,nor1,exp1,fin1分别初始化数据成员name，norm, ex, final

void fun( ); //计算学生的总评成绩。计算方法为：总评成绩=平时成绩占*20%+实验成绩占*25%+期末成绩占*55%。总评成绩计算时要求四舍五入，并且期末考试成绩不足50分时，则期末考试成绩即为总评成绩。  

void print( ); //输出该学生信息。 
```

(3)友元函数：

`friend void sort(Student st[], int n); 友元函数，对st按总评成绩进行从大到小排序`

```cpp
#include <iostream>
#include <cstring>
#include <cmath>
using namespace std;

class Student{

   public:

      void init(char *name1, int nor1, int ex1, int fin1)
      {
          strcpy(name,name1);
          norm_score=nor1;
          ex_score=ex1;
          final_score=fin1;
      }
      void fun( )
      {
          if(final_score<50)
            overall_score=round(final_score);
          else
            overall_score=(round)(norm_score*0.2+ex_score*0.25+final_score*0.55);
      }
      void print( )
      {
          cout<<name<<" "<<norm_score<<" "<<ex_score<<" "<<final_score<<" "<<overall_score<<endl;
      }
      int Get_overall_score()
      {
          return overall_score;
      }

   private:

      int norm_score,ex_score, final_score,overall_score;

      char name[15];

};

void sort(Student stu[],int n)
{
    Student tmp;
    int k=0;
    for(int i=0;i<n-1;i++)
    {
        k=i;
        for(int j=i+1;j<n;j++)
        {
            if(stu[k].Get_overall_score()<stu[j].Get_overall_score())
            {
                k=j;
            }
        }
        tmp=stu[i];
        stu[i]=stu[k];
        stu[k]=tmp;
    }
}

int main(){

  int n, i;

  int norm, ex, final;

  char name[15];

  cin>>n;
  
  Student stu[n];

  for( i = 0; i < n; i++ ){

    cin>>name>>norm>>ex>>final;

    stu[i].init(name,norm,ex,final);

    stu[i].fun();

  }

  sort(stu, 5);

  for(i = 0;i < n; i ++){

    stu[i].print();

  }

  return 0;
}
```

### 17 身份证类(对象数组)（求助GPT）

问题描述 :

问题描述：判断某人是否为青年的标准是男性不超过35周岁或女性不超过40周岁。已知身份证号从第7位开始的连续8位表示持证人的出生年月日，身份证号的第17位为奇数表示持证人为男性，身份证号第17位数字为偶数表示持证人为女性。例如：身份证号为32110219830103191X的持证人出生年月为1983年1月3日，性别为男性。试定义一个类ID，根据身份证号判断持证人截止到2015年10月1日是否为青年。具体要求如下：

(1) 私有数据成员：

```
char *id; 保存18位身份证号

int year, month, date; y,m,d分别表示持证人的出生年、月、日

char sex; 持证人的性别（”M”或”F”） M代表男性，F代表女性
```

(2) 公有成员函数:

```
set_ID(char * s); 用参数s初始化成员id（需申请动态内存），并将year,month,date初始化为0

void fun( );  根据身份证号计算持证人的出生年月和性别，并判断其是否为青年，并将获得的信息存储到对应的数据成员中

void print( ); 输出持证人的信息

~ID(); 析构函数，进行必要的操作
```

输入说明 :

第一行：身份证数目T

第二行至第T+1行：输入身份证id，行与行之间无多余的空行  

输出说明 :

输出T组身份证的信息，组与组之间的信息有一空行

每组的信息如下：

身份证id

year.month.date  

M/F  M：男   F：女

Y/N  Y：青年 N：非青年  

输入范例 :

```
6
321102197504011201
321102196103011213
11010119801001315X
110101198510016381
130102198509306242
513436198511019834
```

输出范例 :

```
321102197504011201
1975.4.1
F
N

321102196103011213
1961.3.1
M
N

11010119801001315X
1980.10.1
M
Y

110101198510016381
1985.10.1
F
Y

130102198509306242
1985.9.30
F
Y

513436198511019834
1985.11.1
M
Y

```

```cpp
#include <iostream>
#include <cstring>
#include <string>
using namespace std;

class ID
{
private:
    string id;
    int year, month, date;
    char sex;
public:
    set_ID(string s)
    {
        int len=s.length();
        id=new char[len+1];
        id=s;
        year=0;
        month=0;
        date=0;
    }
    void fun( )
    {
        year=stoi(id.substr(7,4));
        cout<<year<<endl;
        month=stoi(id.substr(11,2));
        date=stoi(id.substr(13,2));
        if(id[16]%2!=0)
            sex='M';
        else
            sex='F';


    }
    void print( )
    {
        if(sex=='M'&&(year>1980||year==1980&&month>=10)||sex=='F'&&(year>1975||year==1975&&month>=10))
           cout<<"Y"<<endl;
        else
            cout<<"N"<<endl;
    }
    ~ID()
    {
        if(id!=NULL)
        {
            delete []id;
            id=NULL;
        }
    }

};


int main(){
   int T, i;
   char id[19];

   cin>>T;
   ID person[T];

   for(i = 0; i < T; i++){
      if(i> 0 && i < T) cout<<endl;
      cin>>id;
      person[i].set_ID(id);
      person[i].fun();
      person[i].print();
   }

   return 0;
}
```

上面的程序报错`error: no match for 'operator!=' (operand types are 'std::__cxx11::string {aka std::__cxx11::basic_string<char>}' and 'long long int')`

在给类`ID`定义成员函数`set_ID`时，存在几个问题导致编译错误：

1. 函数名应该为`ID`而不是`set_ID`。
2. `id`应该是一个`std::string`类型的成员变量，而不是一个字符数组。
3. 在构造函数中，应该使用成员初始化列表来初始化成员变量。

以下是修正后的代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

class ID
{
private:
    string id;
    int year, month, date;
    char sex;

public:
    ID(string s) : id(s), year(0), month(0), date(0)
    {
    }
    ID(){}

    void fun()
    {
        year = stoi(id.substr(6, 4));
        month = stoi(id.substr(10, 2));
        date = stoi(id.substr(12, 2));
        if (id[16] % 2 != 0)
            sex = 'M';
        else
            sex = 'F';
    }

    void print()
    {
        cout<<id<<endl;
        cout<<year<<"."<<month<<"."<<date<<endl;
        cout<<sex<<endl;
        if ((sex == 'M' && (year > 1980 || (year == 1980 && month >= 10))) || (sex == 'F' && (year > 1975 || (year == 1975 && month >= 10))))
            cout << "Y" << endl;
        else
            cout << "N" << endl;
    }
};

int main()
{
    int T;
    cin >> T;
    ID person[T];

    for (int i = 0; i < T; i++)
    {
        if (i > 0 && i < T)
            cout << endl;
        string id;
        cin >> id;
        person[i] = ID(id);
        person[i].fun();
        person[i].print();
    }

    return 0;
}
```

在修改后的代码中，`set_ID`函数被改为类的构造函数`ID`，使用成员初始化列表来初始化成员变量。另外，将字符数组`id`改为`std::string`类型的成员变量。此外，对于`print`函数中的条件判断，也进行了调整以解决编译错误。

请尝试使用修正后的代码运行，并检查是否仍然存在问题。如果还有其他问题，请随时提问。


### 18 长方形?

问题描述 :

实验目的：学习友元的使用。

实验内容：

定义一个Point类，包括两个私有成员：int x, int y，它们分别表示一个点的x和y座标。

再定义构造函数：

Point(int x, int y)，即传两个参数，构造一个点对象。

定义一个Rectangle类，包括4个私有成员：Point topLeft, topRight,bottomLeft, bottomRight，它们分别表示长方形4个顶点的座标。

注意：在计算机系统里，坐标系如下定义：屏幕的左上角的座标是（0,0），x轴是横轴，屏幕的最右端x值最大，y轴是纵轴，屏幕的最下方y值最大。

再定义构造函数：

Rectangle(Point topLeft, Point topRight, Point bottomLeft, Point bottomRight)

以及实例方法：

bool isRectangle()  //判断4个顶点构成的图形是不是长方形，是则返回true，否则返回false。这个方法只在本类中调用，所以可声明为private的。

int getArea()    //如果是长方形则返回长方形的面积，否则返回0

bool isIn(Point p)   //如果是长方形则判断传入的点是否在该图形之内（不包括边界），如果在内部返回true，不在内部则返回false。如果不是长方形，则一律返回false。

说明：由于在Rectangle类中有大量的语句需要使用到Point类的私有成员x和y，因此，使用友元可直接访问x和y，从而可减少编程中的麻烦。

使用main函数测试以上getArea方法和isIn方法。

输入说明 :

第一行输入长方形r的信息，包括四个顶点x座标及y座标，顶点的输入顺序为左上、右上、左下、右下。

第二行输入一个点p的信息，包括其x座标和y座标。

所有输入都为非负整数，之间以一个空格分隔。无多余空格或空行。

输出说明 :

输出两行，第一行输出长方形面积，第二行输出点p是否位于长方形r之内，如果在内部，则输出“In”，否则输出“Not in”。

输入范例 :

```
1 1 5 1 1 3 5 3
2 2
```

输出范例 :

```
8
In
```

```cpp
class Rectangle
{
private:
    Point topLeft;
    Point topRight;
    Point bottomLeft;
    Point bottomRight;

public:
    Rectangle(Point(topLeftX, topLeftY), Point(topRightX, topRightY), Point(bottomLeftX, bottomLeftY), Point(bottomRightX, bottomRightY))
    {
        this->topLeft=Point(topLeftX, topLeftY);
        this->topRight=Point(topRightX, topRightY);
        this->bottomLeft=Point(bottomLeftX, bottomLeftY);
        this->bottomRight=Point(bottomRightX, bottomRightY);
    }
};
```

我定义的这个类会报下面的错误

```
E:\cpp\ClassDesign\main1.cpp|46|error: expected ')' before ',' token|
E:\cpp\ClassDesign\main1.cpp|46|error: expected ')' before ',' token|
E:\cpp\ClassDesign\main1.cpp|46|error: expected ';' at end of member declaration|
E:\cpp\ClassDesign\main1.cpp|46|error: expected unqualified-id before ')' token|
```

在定义 `Rectangle` 类的构造函数时，您在参数列表中使用了 `Point` 类型的对象作为参数。然而，这样的写法是不正确的。正确的做法是使用合适的类型名称和参数名称。以下是修正后的代码：

```cpp
class Rectangle
{
private:
    Point topLeft;
    Point topRight;
    Point bottomLeft;
    Point bottomRight;

public:
    Rectangle(Point topLeft, Point topRight, Point bottomLeft, Point bottomRight)
    {
        this->topLeft = topLeft;
        this->topRight = topRight;
        this->bottomLeft = bottomLeft;
        this->bottomRight = bottomRight;
    }
};
```

在构造函数的参数列表中，直接使用 `Point` 类型的参数名称即可，无需指定类型。修改后的代码应该能够成功编译。如果您还有其他问题，请随时提问。

```cpp
#include <iostream>
using namespace std;

class Point
{
    friend class Rectangle;
private:
    int x;
    int y;

public:
    Point(){}// 添加默认构造函数
    Point(int x, int y)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
};

class Rectangle
{
private:
    Point topLeft;
    Point topRight;
    Point bottomLeft;
    Point bottomRight;
    bool isRectangle()
    {
        if((topLeft.getX()==bottomLeft.getX())&&(topLeft.getY()==topRight.getY())&&(topRight.getX()==bottomRight.getX())&&(bottomLeft.getY()==bottomRight.getY()))
            return true;
        else
            return false;
    }

public:
    Rectangle(Point topLeft, Point topRight, Point bottomLeft, Point bottomRight)
    {
        this->topLeft = topLeft;
        this->topRight = topRight;
        this->bottomLeft = bottomLeft;
        this->bottomRight = bottomRight;
    }

    int getArea()
    {
        if(isRectangle())
        {
            return (topRight.getX()-topLeft.getX())*(bottomLeft.getY()-topLeft.getY());
        }
        else
            return 0;
    }

    bool isIn(Point p)
    {
        if (isRectangle()&&p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + (topRight.getX()-topLeft.getX())&& p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + (bottomLeft.getY()-topLeft.getY()))
            return true;
        else
            return false;
    }
};






int main()
{
   int topLeftX, topLeftY, topRightX, topRightY, bottomLeftX, bottomLeftY, bottomRightX, bottomRightY;
   int px, py;

   cin >> topLeftX >> topLeftY >> topRightX >> topRightY >> bottomLeftX >> bottomLeftY >> bottomRightX >> bottomRightY;
   cin >> px >> py;

   Point p(px, py);
   Rectangle r(Point(topLeftX, topLeftY), Point(topRightX, topRightY), Point(bottomLeftX, bottomLeftY), Point(bottomRightX, bottomRightY));
   cout << r.getArea() << endl;
   if (r.isIn(p))
        cout << "In" << endl;
   else
        cout << "Not in" << endl;

   return 0;
}
```

### 19 统计字符串个数

问题描述 :

实验目的：静态成员、构造函数、析构函数、等于号的使用。

实验内容：

实现一个自己的字符串类MyString，要求包含以下函数：

构造函数：

```
MyString(unsigned n,char c)：将字符c重复n次得到字符串

MyString(char *p)：根据传入的字符数组得到字符串
```

根据需要，还需要设计默认构造函数、拷贝构造函数等其它函数。

其中，MyString类需要提供一个静态方法GetCount，功能为获取到本程序在运行的过程中某时刻有多少个MyString的对象。

输入说明 :

可输入多组测试数据，每组测试数据包含两行：

第一行输入一个操作的种类,

第二行输入所需要的参数：

对于第1个操作和第2个操作，第二行输入一个整数。

对于第3个操作，第二行输入一个整数及一个字符。

对于第4个操作，第二行输入一个字符串。

输出说明 :

具体输出见函数中的输出语句及输出范例。

输入范例 :

```
1
3
2
3
1
3
3
10 *
4
abcd
```

输出范例 :

```
5
5
8
7
**********
**********
5
abcd

```

```cpp
#include <iostream>
#include <string>
using namespace std;

class MyString
{
private:
    string s;
public:
    MyString()
    {
        count++;
    }
    MyString(unsigned n,char c)
    {
        for(int i=0;i<n;i++)
            s.push_back(c);
        count++;
        count++;
    }
    MyString(char *p)
    {
        while(*p!='\0')
        {
            s+=*p;
            p++;
        }
        count++;
    }
    ~MyString()
    {
        count--;
    }
    static int GetCount();
    static int count;
    void ShowStr()
    {
        cout<<s;
    }
};

int MyString::count=0;

int MyString::GetCount()
{
    return count;
}

void fun1(int n)
{
    MyString strArr[n];
    MyString *pStr;
    cout<<strArr[0].GetCount()<<endl;
}
void fun2(int n)
{
    MyString *pStr=new MyString[n];
    cout<<MyString::GetCount()<<endl;
}
void fun3(MyString &s1, MyString s2)
{
    MyString s3;
    s3=s1=s2;
    cout<<MyString::GetCount()<<endl;
    s3.ShowStr();
    cout<<endl;
}
int main( )
{
 MyString s1;
 MyString s2;
    int n;
    char charArr[20];
 int op;

    while (cin >> op)
    {
        switch (op)
        {
            case 1:
            {
                cin>>n;
                fun1(n);
                break;
            }
            case 2:
            {
                cin>>n;
                fun2(n);
                break;
            }
            case 3:
            {
                int m;
                char ch;
                cin>>m>>ch;
                s2=MyString(m,ch);
                fun3(s1,s2);
                s1.ShowStr();

                cout<<endl;

                break;
            }
            case 4:
            {
                cin >> charArr;
                s1=MyString(charArr);
                cout<<MyString::GetCount()<<endl;
                s1.ShowStr();
                cout<<endl;
                break;
            }
        }
    }

    return 0;
}
```

### 20 提醒队列

问题描述 :

实验目的：学习拷贝构造函数、析构函数的使用以及重载等于号。

实验内容：

设计一个类Note（提醒），包含时间和事件内容，时间由年月日时分秒组成，事件内容用字符串表示。类的编码大致如下：

```cpp
class Note

{

int year, month, day, hour, minute, second;

char *event;  //本题要求event必须为一个字符串指针，不能为字符数组或string字符串

//以下只说明了两个构造函数，可根据需要自己增加构造函数的重载

Note(char * msg, int year, int month, int day, int hour=0, int minute=0, int second=0);

Note(const Note & note);

~Note();

//还需要重载等于号，还可根据需要设计ShowNote()方法，用来显示“提醒”的时间和内容

}
```

再设计一个提醒列表类：NoteList，

私有数据成员包含一个Note数组（如果可能，最好使用vector代替数组）

还有以下成员函数：

插入提醒信息（插入后保持按时间升序排序，如果两个提醒信息时间完全相同，则后插入的排在后）

删除数组中第0个提醒信息并作为函数值返回（因为是按时间排序，所以第0个肯定是时间最早的一个）

输出所有提醒信息

获得提醒信息的数量

NoteList的成员大致为：

数据成员：

一个Note数组：noteArr

一个int成员：noteCount

函数成员：

构造函数

AddNote(Note n)：插入提醒信息（插入后保持按时间升序排序）

Note DeleteFirst(): 删除数组中第0个提醒信息，并将其作为函数值返回

PrintAll()：输出所有提醒信息

GetNoteCount()：获得提醒信息的数量

可根据自己需要再增加其它成员。

输入说明 :

可输入多组测试数据，每组测试数据包含一行或者两行：

第一行输入一个操作的种类：

1：输入一个提醒信息并插入

2：输出并删除提醒列表中时间最早的信息

3：输出所有提醒信息。

第二行输入所需要的参数：

对于第1个操作，第二行输入年月日时分秒及提醒信息字符串，以一个空格分隔各数据，提醒信息中可包含空格。

对于第2个操作和第3个操作，不需要输入额外数据。

输入中无多余空格或空行，两组测试数据之间也无空行。

输出说明 :

第1个操作无输出。

第2个操作输出一个提醒事件的具体信息，格式如下：

2020-01-01 08:10:10 go to class

其中，年月日之间以一个减号分隔，时分秒之间以一个冒号分隔，日期后及秒钟后跟一个空格，最后是提醒事件的内容（字符串），注意不要包含多余空格。

月日及时分秒的输出均占两位，如果不足两位，在前面补“0”。

第3个操作输出所有提醒事件的信息，格式如下：

2 notes:

2020-01-01 08:10:10 go to class

2020-01-01 10:00:00 go to library

第一行输出共有多少个notes，然后跟n行，

每个提醒信息占一行，输出格式见第2个操作的描述。

输出中无多余空格，也无多余空行。

输入范例 :

```
1
2010 1 1 9 0 0 go to class
1
2010 1 1 7 0 0 get up
1
2010 1 1 7 0 0 call zhang san
3
2
2
3
```

输出范例 :

```
3 notes:
2010-01-01 07:00:00 get up
2010-01-01 07:00:00 call zhang san
2010-01-01 09:00:00 go to class
2010-01-01 07:00:00 get up
2010-01-01 07:00:00 call zhang san
1 notes:
2010-01-01 09:00:00 go to class
```

```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cstdio>
using namespace std;

class Note
{
    friend class NoteList;
    friend bool cmp(Note a,Note b);
private:
    int year, month, day, hour, minute, second;
    char *event;

public:
    Note(char * msg, int year, int month, int day, int hour=0, int minute=0, int second=0)
    {
        event=new char[200];
        strcpy(event,msg);
        this->year=year;
        this->month=month;
        this->day=day;
        this->hour=hour;
        this->minute=minute;
        this->second=second;
    }

    Note(const Note & note)
    {
        event=new char[100];
        strcpy(event,note.event);
        this->year=note.year;
        this->month=note.month;
        this->day=note.day;
        this->hour=note.hour;
        this->minute=note.minute;
        this->second=note.second;
    }
    Note(){}

    ~Note(){}

    void ShowNote()
    {
        printf("%02d-%02d-%02d %02d:%02d:%02d %s\n",year,month,day,hour,minute,second,event);
    }

};


bool cmp(Note a,Note b)
{
    if(a.year==b.year)
    {
        if(a.month==b.month)
        {
            if(a.day==b.day)
            {
                if(a.hour==b.hour)
                {
                    if(a.minute==b.minute)
                    {
                        return a.second<b.second;
                    }
                    else
                        return a.minute<b.minute;
                }
                else
                    return a.hour<b.hour;
            }
            else
                return a.day<b.day;
        }
        else
            return a.month<b.month;
    }
    else
        return a.year<b.year;

}
class NoteList
{
private:
    vector<Note> noteArr;
    int noteCount=0;
public:
    void AddNote(Note n)
    {
        noteArr.push_back(n);
        sort(noteArr.begin(),noteArr.end(),cmp);
        noteCount++;
    }
    Note DeleteFirst()
    {
        Note n=noteArr[0];
        for(int i=1;i<noteArr.size();i++)
        {
            noteArr[i-1]=noteArr[i];
        }
        noteCount--;
        return n;
    }
    void PrintAll()
    {
        for(int i=0;i<noteCount;i++)
        {
            noteArr[i].ShowNote();
        }
    }
    int GetNoteCount()
    {
        return noteCount;
    }


};


int main()
{
 char eventMsg[100];
 Note n2;
 int year,month,day,hour,minute,second;
 int i,n;
 NoteList notes;
 int op;
    while (cin >> op)
    {
        switch (op)
        {
            case 1:
            {
                cin>>year;
                cin>>month;
                cin>>day;
                cin>>hour;
                cin>>minute;
                cin>>second;
                cin.get();
                cin.getline(eventMsg,90);
                Note nt(eventMsg,year,month,day,hour,minute,second);
                notes.AddNote(nt);
                break;
            }
            case 2:
            {
                if (notes.GetNoteCount()>0)
                {
                    Note nt=notes.DeleteFirst();
                    nt.ShowNote();
                }
                break;
            }
            case 3:
            {
                int cnt = notes.GetNoteCount();
                cout<<cnt<<" notes:"<<endl;
                notes.PrintAll();
                break;
            }
        }
    }
 return 0;
}
```

### 21 统计单词（求助GPT）

问题描述 :

实验目的：string、vector、类的综合应用。

实验内容：

从键盘输入一篇文章，统计其中单词出现的次数（不区分大小写），并输出出现次数排名第一的单词及其次数。注意：可能有多个单词并列第一，需要全部输出。输出时，如果有多个单词排名并列，则按其在文章中出现的先后顺序输出，先出现的先输出。

说明：为简单起见，单词的含义是空白字符分隔开的连续字符串。比如“I love China!”这句话包含三个单词，第三个单词是“China!”（包括其中的感叹号），再如“Hi !”，这句话包含两个单词，第二个单词仅为一个感叹号。

参考以下main函数：

```cpp
int main()

{

        vector<WordCount> vwc;

        string str;

         int i;

         while(cin>>str)

         {

             str = ToLower(str);

             CountWord(vwc, str);

         }

         DisplayResult(vwc);

         return 0;

}
```

其中：

1. WordCount类：存储单词及其出现次数
    
2. ToLower函数：传入一个字符串，将其中大写英文字母转换为小写、其余字符保持不变，返回转换后的结果。
    
3. CountWord函数：传入一个vector和一个单词，在vector中查找该单词是否已存在（注意：vector中的元素为WordCount对象，该对象有一个属性为单词字符串），如果已存在，则将其出现次数加1，否则在vector中添加一个元素（WordCount对象），该元素存储这个新的单词及其出现次数（此时为1）。
    
4. DisplayResult函数：传入一个vector，输出其中出现次数最高的单词及其次数。

请实现以上定义的WordCount类及三个函数。

输入说明 :

输入一篇文章，其中包含可见字符及空白字符（可能有换行）。

输出说明 :

每个单词占一行，如果有n个单词，则输出n行，

每行首先输出单词（以小写字母形式输出），然后输出一个空格，再输出单词的出现次数。

单词输出的顺序按照在文章中出现的先后顺序。

输入范例 :

```
abc Abc, ABC. 
abc!
abc, def
DEf
```

输出范例 :

```
abc, 2
def 2
```


```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <vector>
using namespace std;

class WordCount
{
private:
    string word;
    int count;
public:
    string ToLower(string s)
    {
        string lowcase;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]<='Z'&&s[i]>='A')
                s[i]=s[i]-'A'+'a';
            lowcase.push_back(s[i]);
        }
        return lowcase;
    }
    void CountWord(vector<WordCount> arr, string insert_word)
    {
        for(int i=0;i<arr.size();i++)
        {
            if(strcmp(arr[i].word,insert_word)==0)
            {
                arr[i].count++;
                break;
            }
        }
        arr.push_back(word,1);

    }
    void DisplayResult(vector<WordCount> arr)
    {
        int max-arr[0].count;
        string required_word;
        for(int i=0;i<arr.size();i++)
        {
            if(arr[i].count>max)
            {
                max=arr[i].count;
                required_word=arr[i].word;
            }
        }
        for(int i=0;i<arr.size();i++)
        {
            if(arr[i].count==max)
            {
                cout<<required_word=arr[i].word<<" "<<arr[i].count<<endl;
            }
        }

    }

};


int main()

{

        vector<WordCount> vwc;

        string str;

         int i;



         while(cin>>str)

         {

             str = ToLower(str);

             CountWord(vwc, str);

         }

         DisplayResult(vwc);



         return 0;

}
```

上面的程序报错`error: cannot convert 'std::__cxx11::string {aka std::__cxx11::basic_string<char>}' to 'const char*' for argument '1' to 'int strcmp(const char*, const char*)'`

错误的原因是在`WordCount`类的`CountWord`函数中使用了`strcmp`函数，但`strcmp`函数接受的参数是C风格的字符串（`const char*`），而不是C++的`std::string`。这导致编译器报错。为了解决这个问题，我们可以使用`==`运算符来比较两个`std::string`对象是否相等，而无需使用`strcmp`函数。

另外，在`ToLower`函数中，需要将`word[i]`改为`s[i]`，因为`word`是`WordCount`类的成员变量，而在`ToLower`函数中，我们需要操作传入的字符串`s`。

以下是修改后的代码：

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class WordCount {
private:
    string word;
    int count;

public:
    string ToLower(string s) {
        string lowcase;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] <= 'Z' && s[i] >= 'A')
                s[i] = s[i] - 'A' + 'a';
            lowcase.push_back(s[i]);
        }
        return lowcase;
    }

    void CountWord(vector<WordCount>& arr, string insert_word) {
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i].word == insert_word) {
                arr[i].count++;
                return;
            }
        }
        WordCount wc;
        wc.word = insert_word;
        wc.count = 1;
        arr.push_back(wc);
    }

    void DisplayResult(const vector<WordCount>& arr) {
        int max_count = arr[0].count;
        string required_word;
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i].count > max_count) {
                max_count = arr[i].count;
                required_word = arr[i].word;
            }
        }
        for (int i = 0; i < arr.size(); i++) {
            if (arr[i].count == max_count) {
                cout << arr[i].word << " " << arr[i].count << endl;
            }
        }
    }
};

int main() {
    vector<WordCount> vwc;
    string str;

    while (cin >> str) {
        WordCount wc;
        str = wc.ToLower(str);
        wc.CountWord(vwc, str);
    }

    WordCount wc;
    wc.DisplayResult(vwc);

    return 0;
}
```

在修改后的代码中，我们将`CountWord`函数的参数`arr`改为引用类型`vector<WordCount>&`，以便在函数内部修改`arr`。

此外，我们还将`DisplayResult`函数的参数`arr`改为`const vector<WordCount>&`，以避免在函数内部修改`arr`。

请尝试运行修改后的代码，应该不会再出现相同的错误。

### 22 重载<<输出圆

问题描述 :

定义一个圆类（Circle），其中：  

属性包括：  半径(radius)、周长(perim)和面积(area)

方法包括：  构造函数（以半径为参数，默认值为0，周长和面积在构造函数中生成）、重载运算符<<：输出半径、周长和面积。输出的格式为： “radius:2;perim:12.56;area:12.56”

输入说明 :

可输入多组数据，每组数据占一行，包含一个半径值。

输出说明 :

对于每个输入的半径，输出对应的圆的信息，

输出格式形如：radius:2;perim:12.56;area:12.56

```cpp
#include <iostream>
using namespace std;

const double PI=3.14;

class Circle
{
private:
    double radius,perim,area;
public:
    Circle(double r=0)
    {
        radius=r;
        perim=2*PI*r;
        area=PI*r*r;
    }
    friend ostream & operator<<(ostream &os, const Circle &obj)
    {
        os<<"radius:"<<obj.radius<<";perim:"<<obj.perim<<";area:"<<obj.area;
        return os;
    }

};

int main()
{
    double r;
    while(cin>>r)
    {
        if (r>0)
        {
           Circle c1(r);
           cout<<c1<<endl;
        }
        else
        {
           Circle c2;
           cout<<c2<<endl;
        }
    }
   return 0;
}
```

### 23 长方形(类的实现)

问题描述 :

实验目的：学习组合对象的使用。

实验内容：

定义一个Point类，包括两个私有属性：int x, int y，它们分别表示一个点的x和y座标。

再定义构造函数：

Point(int x, int y)，即传两个参数，构造一个点对象。

注意，本题要求Point类不得定义缺省构造函数，也就是只定义以上所说的构造函数。  

定义一个Rectangle类，包括三个私有属性：Point topLeft, int width, int height，它们分别表示长方形左上角顶点的座标，以及横向的宽度和纵向的高度。

注意：在计算机系统里，座标系如下定义：屏幕的左上角的座标是（0,0），x轴是横轴，屏幕的最右端x值最大，y轴是纵轴，屏幕的最下方y值最大。

再定义构造函数：

Rectangle(int x, int y, int width, int height)

以及实例方法：

int getArea()    //获取该图形的面积

bool isIn(Point p)   //判断传入的点是否在该图形之内（不包括边界），如果在内部返回true，否则返回false

使用main函数测试以上getArea方法和isIn方法。

输入说明 :

第一行输入长方形r的信息，包括左上角顶点x座标、左上角顶点y座标、宽度、高度。

第二行输入一个点p的信息，包括其x座标和y座标。

所有输入都为非负整数，之间以一个空格分隔。无多余空格或空行。

输出说明 :

输出两行，第一行输出长方形面积，第二行输出点p是否位于长方形r之内，如果在内部，则输出“In”，否则输出“Not in”。

输入范例 :

```
10 20 50 80 
20 30
```

输出范例 :

```
4000
In
```

```cpp
#include <iostream>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:

    Point(int x=0, int y=0)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
};

class Rectangle
{
private:
    Point topLeft;
    int width;
    int height;

public:
    Rectangle(int topLeftX, int topLeftY, int width,int height)
    {
        this->topLeft = Point(topLeftX, topLeftY);
        this->width = width;
        this->height = height;
    }

    int getArea()
    {
        return height*width;

    }

    bool isIn(Point p)
    {
        if (p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width&& p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height)
            return true;
        else
            return false;
    }
};

int main()

{

       int topLeftX, topLeftY, width, height;

       int px, py;



       cin>>topLeftX>>topLeftY>>width>>height;

       cin>>px>>py;



    Point p(px, py);

    Rectangle r(topLeftX, topLeftY, width, height);

    cout<<r.getArea()<<endl;

    if(r.isIn(p))

        cout<<"In"<<endl;

    else

        cout<<"Not in"<<endl;



       return 0;

}
```

### 24 某年龄段内的学生

问题描述 :

实验目的：组合对象、静态成员的使用。

实验内容：

设计一个Date类，包含：

1、私有实例属性年月日。

2、私有静态属性maxYear和minYear，

3、公有静态方法设置maxYear和minYear的值，如：

```cpp
static void SetMaxYear(int maxY)

{

   maxYear = maxY;

}
```

设计一个Student类，数据成员包含int类型的学号、string类型的姓名、Date类型的生日。

设计一个StudentList类，包含：

1、私有属性：Student对象数组，可声明大小为100，即保存不超过100个元素

2、私有属性：数组中实际保存的元素个数

3、公有方法：AddStudent(Student stu)，将传入的形参stu增加到数组中

4、公有方法：DeleteStudent(int num)，根据传入的学号num从数组中删除学生

5、公有方法：StudentList GetStudent(int year1, int year2)，其中：

形参：包括两个int型值year1和year2，并且year1<=year2

功能：查找Student对象数组中所有出生年在year1和year2之间（含year1和year2）的学生

返回值：返回符合条件的学生，用一个StudentList对象返回

6、公有方法：Print()，输出Student对象数组中所有学生的信息，包括学号、姓名、生日（年月日）。如果数组中有多个元素（学生），则一个元素输出一行。如果数组中没有元素，则输出“No result.”

以上三个类只规定了必要的几个方法，其它的方法请自行设计，包括构造函数。

下面解释Date类中静态成员maxYear和minYear的作用：

由于学生入学年龄有限制，比如，规定大学生必须在13岁到45岁之间。因此，如果现在是2020年，则入学学生中，maxYear为2020-13=2007，minYear为2020-45=1975。

程序运行时，首先由用户输入maxYear和minYear，并存储到Date类中。

当创建Student对象时，如果发现学生的出生年份大于maxYear，则设置该学生的出生年为maxYear；如果发现学生的出生年份小于minYear，则设置该学生的出生年为minYear。

输入学生生日时，不需要检查日期是否合法。

输入说明 :

首先输入两个整数maxYear和minYear。并保证maxYear>=minYear。

然后输入多组测试数据，每组测试数据包含两行：

第一行输入一个操作的种类：

1：增加一个学生

2：删除一个学生

3：输入两个年份，输出出生日期在这两年（包含这两年）之间的所有学生的信息。

第二行输入所需要的参数：

对于第1个操作，第二行输入学生的信息，包括学号、姓名（中间无空格）、出生年、出生月、出生日。

对于第2个操作，第二行输入一个编号num

对于第3个操作，第二行输入两个year：year1和year2，并保证year1<=year2。

所有输入数据之间以一个空格分隔。无多余空格或空行，两组测试数据之间也无空行。

在输入时，将保证不会向学生列表中添加一个学号（num）已经存在的学生。

输出说明 :

仅第3个操作有输出，因此，测试数据中必然包含第3个操作。

第3个操作输出符合条件的所有学生的信息，包括学号、姓名、出生年、出生月、出生日。

每个学生的输出占一行，输出的数据项之间以一个空格分隔。

如果没有符合条件的学生，则输出一行“No result.”，不包括引号。

如果有多个学生，输出学生的顺序为学生加入的顺序。

输出中无多余空格，也无多余空行。

输入范例 :

```
2007 1990 
1 
1 Rose 2002 1 1 
1 
2 Kevin 1992 1 1 
1 
3 John 2012 1 1 
3 
1992 2010 
2 
2 
1 
2 Tom 1987 1 1 
3 
1987 2010
```

输出范例 :

```
1 Rose 2002 1 1
2 Kevin 1992 1 1
3 John 2007 1 1
1 Rose 2002 1 1
3 John 2007 1 1
2 Tom 1990 1 1
```

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class Date
{
private:
    int year,month,day;
    static int minYear,maxYear;
public:
    Date(int birthYear, int birthMonth,int birthDay)
    {
        if(birthYear<maxYear)
            birthYear=maxYear;
        if(birthYear>minYear)
            birthYear=minYear;
        year=birthYear;
        month=birthMonth;
        day=birthDay;

    }
    static void SetMaxYear(int maxY)
    {
       maxYear = maxY;
    }
    static void SetMinYear(int minY)
    {
       minYear = minY;
    }
    int GetYear()
    {
        return year;
    }
    int GetMonth()
    {
        return month;
    }
    int GetDay()
    {
        return day;
    }
};

class Student
{
private:
    int No;
    string name;
    Date birthday;
public:
    Student(int num,string  name, Date D ):birthday(D)
    {
        No=num;
        this->name=name;
    }

    int GetNo()
    {
        return No;
    }
    string GetName()
    {
        return name;
    }
    int GetBirthYear()
    {
        return birthday.GetYear();
    }
    int GetBirthMonth()
    {
        return birthday.GetMonth();
    }
    int GetBirthDay()
    {
        return birthday.GetDay();
    }

};

class StudentList
{
private:
    Student students[100];
    int count;
    vector<Student> stulist;
public:
    void setcount()
    {
        count=0;
    }
    void AddStudent(Student stu)
    {
        students[count]=stu;
        count++;
    }
    void DeleteStudent(int num)
    {

        if(students[count-1].GetNo()==num)
            count--;
        for(int i=0;i<count-1;i++)
        {
            if(students[i].GetNo()==num)
            {
                for(int j=num;j<count;j++)
                {
                    students[j]=students[j+1];
                    count--;
                }
            }
        }
    }
    StudentList GetStudent(int year1, int year2)
    {
        for(int i=0;i<count;i++)
        {
            if(students[i].birthday.GetYear()<=year2&&students[i].birthday.GetYear()>=year1)
                stulist.push_back(students[i]);
        }
        return stulist;
    }
    void Print()
    {
        if(stulist.size()==0)
            cout<<"No result."<<endl;
        for(int i=0;i<stulist.size();i++)
        {
            cout<<stulist[i].GetNo()<<" "<<stulist[i].GetName()<<" "<<stulist[i].GetBirthYear()<<" "<<stulist[i].GetBirthMonth()<<" "<<stulist[i].GetBirthDay()<<endl;
        }
    }
};


int main()
{
   int num, birthYear, birthMonth, birthDay;
   int maxYear, minYear, year1, year2;
   int op;
   string name;
   StudentList sl;
   Student stu;

   cin >> maxYear >> minYear;
   Date::SetMaxYear(maxYear);
   Date::SetMinYear(minYear);
   while (cin >> op)
   {
        switch (op)
        {
            case 1:
                cin >> num >> name >> birthYear >> birthMonth >> birthDay;
                stu = Student(num, name, Date(birthYear, birthMonth, birthDay));
                sl.AddStudent(stu);
                break;
            case 2:
                cin >> num;
                sl.DeleteStudent(num);
                break;
            case 3:
                cin >> year1 >> year2;
                StudentList temp = sl.GetStudent(year1, year2);
                temp.Print();
                break;
       }
   }
   return 0;
}
```

上面的代码报错`error: 'Date Student::birthday' is private`

在类`Student`中，成员变量`birthday`被声明为私有（private），因此在类外部无法直接访问它。在`StudentList`类的成员函数`GetStudent`中，尝试通过`students[i].birthday.GetYear()`访问`birthday`成员变量时就会导致编译错误。

为了解决这个问题，可以在`Student`类中添加一个公有（public）的成员函数，用于返回`birthday`对象的引用。然后，可以通过该函数来访问和获取`birthday`的成员变量。

请将以下代码添加到`Student`类中：

```cpp
const Date& GetBirthday() const
{
    return birthday;
}
```

修改后的`Student`类代码如下所示：

```cpp
class Student
{
private:
    int No;
    string name;
    Date birthday;
public:
    Student(int num, string name, Date D): birthday(D)
    {
        No = num;
        this->name = name;
    }

    int GetNo()
    {
        return No;
    }
    string GetName()
    {
        return name;
    }
    const Date& GetBirthday() const
    {
        return birthday;
    }
};
```

通过添加`GetBirthday`函数，我们现在可以在`StudentList`类的`GetStudent`函数中使用`students[i].GetBirthday().GetYear()`等来访问`birthday`的成员变量。

此外，在`GetStudent`函数的开头，应该清空`stulist`，以便每次调用时都能重新填充正确的学生列表。通过添加`stulist.clear()`可以实现该目的。

以下是修改后的`StudentList`类的`GetStudent`函数的代码：

```cpp
StudentList GetStudent(int year1, int year2)
{
    stulist.clear(); // 清空stulist
    for (int i = 0; i < count; i++)
    {
        if (students[i].GetBirthday().GetYear() <= year2 && students[i].GetBirthday().GetYear() >= year1)
            stulist.push_back(students[i]);
    }
    return stulist;
}
```

对于其他部分的代码，没有发现其他错误。你可以尝试运行修改后的代码，应该不会再报关于`Date Student::birthday`私有访问的错误了。

上面的代码都是错误的。保留只是为了让自己找出自己思维的盲区。

能AC的完整代码如下：

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

class Date {
private:
    int year;
    int month;
    int day;
    static int maxYear;
    static int minYear;

public:
    Date() {
        year = 0;
        month = 0;
        day = 0;
    }

    Date(int y, int m, int d) {
        year = y;
        month = m;
        day = d;
    }

    static void SetMaxYear(int maxY) {
        maxYear = maxY;
    }

    static void SetMinYear(int minY) {
        minYear = minY;
    }

    friend class StudentList;
};

int Date::maxYear = 0;
int Date::minYear = 0;

class Student {
private:
    int id;
    string name;
    Date birthday;

public:
    Student(){}
    Student(int i, string n, Date b) {
        id = i;
        name = n;
        birthday = b;
    }

    friend class StudentList;
};

class StudentList {
private:
    int count=0;
    Student students[100];

public:

    void AddStudent(Student stu) {
        if(stu.birthday.year<Date::minYear)
            stu.birthday.year=Date::minYear;
        if(stu.birthday.year>Date::maxYear)
            stu.birthday.year=Date::maxYear;
        students[count]=stu;
        count++;
    }

    void DeleteStudent(int num) {
        if(students[count-1].id==num)
            count--;
        for(int i=0;i<count;i++)
        {
            if(students[i].id==num)
            {
                for(int j=num;j<count;j++)
                {
                    students[i]=students[i+1];
                    count--;
                }
                break;
            }
        }
    }

    StudentList GetStudent(int year1, int year2)
    {
        StudentList stulist;
        for(int i=0;i<count;i++)
        {
            if(students[i].birthday.year>=year1&&students[i].birthday.year<=year2)
            {
                stulist.students[stulist.count++]=students[i];
            }
        }
        return stulist;
    }

    void Print()
    {
        if (count==0) {
            cout << "No result." << endl;
        }
        for(int i=0;i<count;i++)
        {
            cout<<students[i].id<<" "<<students[i].name<<" "<<students[i].birthday.year<<" "<<students[i].birthday.month<<" "<<students[i].birthday.day<<endl;
        }
    }
};

int main()
{
   int num, birthYear, birthMonth, birthDay;
   int maxYear, minYear, year1, year2;
   int op;
   string name;
   StudentList sl;
   Student stu;

   cin >> maxYear >> minYear;
   Date::SetMaxYear(maxYear);
   Date::SetMinYear(minYear);
   while (cin >> op)
   {
        switch (op)
        {
            case 1:
                cin >> num >> name >> birthYear >> birthMonth >> birthDay;
                stu = Student(num, name, Date(birthYear, birthMonth, birthDay));
                sl.AddStudent(stu);
                break;
            case 2:
                cin >> num;
                sl.DeleteStudent(num);
                break;
            case 3:
                cin >> year1 >> year2;
                StudentList temp = sl.GetStudent(year1, year2);
                temp.Print();
                break;
       }
   }
   return 0;
}
```


### 25 从Point继承的Rectangle

问题描述 :

实验目的：学习继承的编程方法

实验内容：

定义一个Point类，包括：

两个私有数据成员：int x, int y，它们分别表示一个点的x和y座标。

构造函数：

Point(int x, int y)，即传两个参数，构造一个点对象。

注意，本题要求Point类不得定义缺省构造函数，也就是只定义以上所说的构造函数。

成员函数：

Move(int dx, int dy)，将Point对象移动dx,dy的距离。 

定义一个Rectangle类，继承Point类，基类对象的x和y表示长方形左上角的坐标。

Rectangle类包括：

两个私有数据成员：int width, int height，它们分别表示长方形的横向的宽度和纵向的高度。

构造函数：

Rectangle(int x, int y, int width, int height)。

成员函数：

int getArea ()    //获取该图形的面积

bool isIn(Point p)   //判断传入的点是否在该图形之内（不包括边界），如果在内部返回true，否则返回false

使用main函数测试以上getArea方法和isIn方法。

输入说明 :

第一行输入长方形r的信息，包括左上角顶点x座标、左上角顶点y座标、宽度、高度。

第二行输入一个点p的信息，包括其x座标和y座标。

第三行输入长方形移动的距离，分别为在x方向和在y方向移动的距离。

所有输入都为整数，之间以一个空格分隔。无多余空格或空行。

输出说明 :

输出三行：

第一行输出长方形面积。

第二行输出点p是否位于长方形r之内，如果在内部，则输出“In”，否则输出“Not in”。

第三行输出点p移动后是否位于长方形r之内，如果在内部，则输出“In”，否则输出“Not in”。

输入范例 :

```
1 0 10 9
11 3
2 0
```

输出范例 :

```
90
Not in
In
```

```cpp
#include <iostream>
using namespace std;

class Point
{
private:
    int x;
    int y;

public:
    Point(int x=0, int y=0)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
    void move(int dx, int dy)
    {
        x=x+dx;
        y=y+dy;
    }
};

class Rectangle:public Point
{
private:
    int width;
    int height;
    Point topLeft;

public:
    Rectangle(int topLeftX,int topLeftY, int width,int height)
    {
        this->topLeft = Point(topLeftX, topLeftY);
        this->width = width;
        this->height = height;
    }

    int getArea()
    {
        return height*width;

    }

    bool isIn(Point p)
    {
        if (p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width&& p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height)
            return true;
        else
            return false;
    }
    void move(int dx, int dy)
    {
        this->topLeft = Point(getX()+dx,getY()+dy);
    }
};







int main()

{

       int topLeftX, topLeftY, width, height;

       int px, py, dx, dy;



       cin>>topLeftX>>topLeftY>>width>>height;

       cin>>px>>py;

       cin>>dx>>dy;



    Point p(px, py);

    Rectangle r(topLeftX, topLeftY, width, height);

    cout<<r.getArea()<<endl;

    if(r.isIn(p))

        cout<<"In"<<endl;

    else

        cout<<"Not in"<<endl;

    r.move(dx,dy);

    if(r.isIn(p))

        cout<<"In"<<endl;

    else

        cout<<"Not in"<<endl;

       return 0;

}
```

### 26 计算周长

问题描述 :

已定义一个Shape抽象类、常量PI以及main函数。  

请在Shape的基础上派生出矩形Rectangle和圆形Circle类，二者都有 GetPerim（）函数计算并返回对象的周长。  

请编写这两个类的代码，使得在main函数中正确输出两个对象的周长。

输入说明 :

输入共两行，第一行输入一个半径，第二行输入矩形的宽和高，用空格进行分隔。

输出说明 :

共输出两行，第一行输出圆的周长，第二行输出矩形的周长。

输入范例 :

```
10
6 4
```

输出范例 :

```
62.8
20
```

```cpp
#include <iostream>
using namespace std;
const double PI=3.14;
class Shape
{
public:
    Shape() {}
    ~Shape() {}
    virtual float GetPerim()=0;
};
class Rectangle:public Shape
{
private:
    double width;
    double height;
public:
    Rectangle(double  w=0,double h=0)
    {
        width=w;
        height=h;
    }
    float GetPerim()
    {
        return 2*(width+height);
    }
};

class Circle:public Shape
{
private:
    double radius;
public:
    Circle(double r=0)
    {
        radius=r;
    }
    float GetPerim()
    {
        return 2*PI*radius;
    }
};
int main()
{
    Shape * sp;
    double r,width,height;
    cin>>r;
    sp=new Circle(r);
    cout<<sp->GetPerim ()<<endl;
    cin>>width>>height;
    sp=new Rectangle(width,height);
    cout<<sp->GetPerim()<<endl;
    return 0;
}
```

### 27 面积和

问题描述 :

实验目的：多态的应用

实验内容：

定义类Point，包括：

两个私有数据成员：int x, int y，它们分别表示一个点的x和y座标。

构造函数：

Point(int x, int y)，即传两个参数，构造一个点对象。

注意，本题要求Point类不得定义缺省构造函数，也就是只定义以上所说的构造函数。

虚成员函数：

double getArea ()    //获取该图形的面积

bool isIn(Point p)   //判断传入的点是否在该图形之内（不包括边界），如果在内部返回true，否则返回false

定义一个Rectangle类，继承Point类，基类对象的x和y表示长方形左上角的坐标。

Rectangle类包括：

两个私有数据成员：int width, int height，它们分别表示长方形的横向的宽度和纵向的高度。

构造函数：

Rectangle(int x, int y, int width, int height)。

成员函数：

实现double getArea ()  和bool isIn(Point p) 函数。

定义一个Circle类，继承Point类，基类对象的x和y表示圆心的坐标。

Circle类包括：

一个私有数据成员： double r，表示圆的半径。

构造函数：

Circle(double x, double y, double r)

成员函数：

实现double getArea ()  和bool isIn(Point p) 函数。计算圆的面积时，PI=3.14。

使用以下main函数测试。测试内容为：首先输入一个点p的信息，然后输入若干长方形及圆形，Point类型的ppArr指针数组里的元素指向这些对象。最后遍历ppArr数组，判断p位于哪些对象之内，然后计算这些对象的面积之和并输出。

输入说明 :

第一行输入两个整数，表示点p的x和y座标

其后若干行，每行为一个对象的信息，具体如下：

首先输入一个整数1或2，

如果输入1，表示本行后面将输入4个整数，分别表示长方形左上角x和y座标及长方形宽度、高度。

如果输入2，表示本行后面将输入3个整数，分别表示圆形的圆心x和y座标及半径。

所有输入均为整数，中间以空格分隔。

输出说明 :

输出计算结果，类型为一个double型数。

输入范例 :

```
1 1
1 0 0 2 2
2 1 0 2
1 1 0 3 4
2 0 0 1
```

输出范例 :

```
16.56
```

```cpp
#include <iostream>
#include <cmath>
using namespace std;
const double PI=3.14;

class Point
{
private:
    int x;
    int y;

public:
    Point(int x=0, int y=0)
    {
        this->x = x;
        this->y = y;
    }

    int getX()
    {
        return x;
    }

    int getY()
    {
        return y;
    }
    virtual double getArea (){}

    virtual bool isIn(Point p) {}
};

class Rectangle:public Point
{
private:
    int width;
    int height;
    Point topLeft;

public:
    Rectangle(int topLeftX,int topLeftY, int width,int height)
    {
        this->topLeft = Point(topLeftX, topLeftY);
        this->width = width;
        this->height = height;
    }

    double getArea()
    {
        return height*width;

    }

    bool isIn(Point p)
    {
        if (p.getX() > topLeft.getX() && p.getX() < topLeft.getX() + width&& p.getY() > topLeft.getY() && p.getY() < topLeft.getY() + height)
            return true;
        else
            return false;
    }
};

class Circle:public Point
{
private:
    double radius;
    Point center;
public:
    Circle(double x=0, double y=0,double r=0)
    {
        radius=r;
        this->center=Point(x,y);
    }
    double getArea()
    {
        return PI*radius*radius;

    }

    bool isIn(Point p)
    {
        if ((p.getX()-center.getX()) * (p.getX()-center.getX())+(p.getY()-center.getY())*(p.getY()-center.getY())<radius*radius)
            return true;
        else
            return false;
    }
};


int main()

{

   int topLeftX, topLeftY, width, height;

   int px, py;

   int op, radius, count=0;

   Point *ppArr[100];  //声明一个指针数组，最多存放100个Point对象的指针

   double totalArea = 0;



   cin>>px>>py;

   Point p(px, py);



   while (cin >> op)

    {

        switch (op)

        {

            case 1:

            {//往数组里添加元素，指向长方形对象

             cin>>topLeftX>>topLeftY>>width>>height;

                 ppArr[count++] = new Rectangle(topLeftX, topLeftY, width, height);

                 break;

            }

            case 2:

            {//往数组里添加元素，指向圆形对象

                 cin>>px>>py>>radius;

                 ppArr[count++] = new Circle(px, py, radius);

                 break;

            }

        }

    }



    for(int i=0; i<count; i++)

    {//遍历ppArr数组，判断p位于哪些对象之内，然后计算这些对象的面积之和

        if (ppArr[i]-> isIn(p))

            totalArea += ppArr[i]->getArea();

    }

    cout<<totalArea<<endl;

    return 0;

}
```

### 28 发工资

问题描述 :

实验目的：多态的应用

实验内容：

公司有三类雇员：老板、销售员、实习生。  

老板每月固定5000元；销售员每月2000元底薪加提成，提成的计算方式为销售额的10%；实习生的工资按实习时间计算，每小时30元。

现输入若干雇员的信息，请输出一个月该发多少工资。

要求：

首先声明类employee，包含：

数据成员：

```
string name;

string role;

double salary;  
```

 以及

```
-  构造函数：employee(string name, string role)，并且仅声明这一个构造函数，无默认构造函数。
    
-  虚函数calcSalary
    
-  普通成员函数showInformation（该输出雇员的姓名、角色、工资信息）
    
-  普通成员函数getSalary（返回salary的值）
```

再声明三个employee的派生类：boss、salesman、intern，类中需要实现虚函数calcSalary。

在main函数中，首先输入若干雇员的信息，放入empList中，然后遍历empList，计算各雇员的工资，输出其信息，最后输出总工资。

输入说明 :

输入若干行，每行输入一个雇员的信息。  

每一行的输入形式为：

首先输入一个整数，表示雇员的种类，1为老板，2为销售员，3为实习生。

如果输入1，后面紧接着输入老板的姓名。

如果输入2，后面紧接着输入销售员的姓名及销售额。

如果输入3，后面紧接着输入实习生的姓名及实习小时数。

输入的姓名中无空格，销售额及实习小时数均为整数。

输出说明 :

如果共有n个雇员，则共输出n+1行，  

前n行输出雇员的姓名、角色及工资，以空格分隔。角色为：boss、salesman、intern。

第n+1行输出工资总额。

n个雇员的输出顺序按照输入的顺序。

输入范例 :

```
1 David 
2 Kevin 10000 
3 stu1 80 
2 John 10200 
3 stu2 102 
3 stu3 0 
```

输出范例 :

```
David boss 5000
Kevin salesman 3000
stu1 intern 2400
John salesman 3020
stu2 intern 3060
stu3 intern 0
total salary:16480
```

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class employee
{
    string name;
    string role;

public:
    double salary;
    employee(string name, string role)
    {
        this->name=name;
        this->role=role;
    }
    virtual void calcSalary(){}
    void showInformation()
    {
        cout<<name<<" "<<role<<" "<<salary<<endl;
    }
    double getSalary()
    {
        return salary;
    }
    //friend class boss;
    //friend class salesman;
    //friend class intern;
};

class boss:public employee
{

public:
    boss(string name):employee(name, "boss")
    {

    }
    void calcSalary()
    {
        salary=5000.0;
    }
};
class salesman:public employee
{
    int salesCount;
public:
    salesman(string name,int salesCount):employee(name,"salesman")
    {
        this->salesCount=salesCount;
    }
    void calcSalary()
    {
        salary=2000+salesCount*0.1;
    }
};
class intern:public employee
{
    int workHours;
public:
    intern(string name,int workHours):employee(name,"intern")
    {
        this->workHours=workHours;
    }
    void calcSalary()
    {
        salary=30.0*workHours;
    }
};

int main()

  {

    vector<employee *> empList;

    int op, salesCount, workHours;

    string name;

    while (cin >> op)

     {

        switch (op)

        {

            case 1:

            {

                cin>>name;

                employee *pe = new boss(name);

                empList.push_back(pe);

                break;

            }

            case 2:

            {

                cin>>name>>salesCount;

                employee *pe=new salesman(name, salesCount);

                empList.push_back(pe);

                break;

            }

            case 3:

            {

                cin>>name>>workHours;

                employee *pe=new intern(name, workHours);

                empList.push_back(pe);

                break;

            }

        }

     }



    double totalSalary = 0;

    for(int i=0; i<empList.size(); i++)

    {

        empList.at(i)->calcSalary();//先利用各派生类的多态性计算出工资

        totalSalary += empList.at(i)->getSalary();

        empList.at(i)->showInformation();

    }

    cout<<"total salary:"<<totalSalary<<endl;

    return 0;

 }
```

以下是上述C++程序的等价写法：

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

class employee
{
protected:
    string name;
    string role;
    double salary;

public:
    employee(string name, string role) : name(name), role(role), salary(0.0) {}

    virtual void calcSalary() = 0;

    void showInformation()
    {
        cout << name << " " << role << " " << salary << endl;
    }

    double getSalary()
    {
        return salary;
    }
};

class boss : public employee
{
public:
    boss(string name) : employee(name, "boss")
    {
    }

    void calcSalary()
    {
        salary = 5000.0;
    }
};

class intern : public employee
{
    int workHours;

public:
    intern(string name, int workHours) : employee(name, "intern"), workHours(workHours)
    {
    }

    void calcSalary()
    {
        salary = 30.0 * workHours;
    }
};

class salesman : public employee
{
    int salesCount;

public:
    salesman(string name, int salesCount) : employee(name, "salesman"), salesCount(salesCount)
    {
    }

    void calcSalary()
    {
        salary = 2000 + salesCount * 0.1;
    }
};

int main()
{
    vector<employee *> empList;

    int op, salesCount, workHours;
    string name;

    while (cin >> op)
    {
        switch (op)
        {
        case 1:
            cin >> name;
            empList.push_back(new boss(name));
            break;
        case 2:
            cin >> name >> salesCount;
            empList.push_back(new salesman(name, salesCount));
            break;
        case 3:
            cin >> name >> workHours;
            empList.push_back(new intern(name, workHours));
            break;
        }
    }

    double totalSalary = 0;
    for (employee *emp : empList)
    {
        emp->calcSalary();
        totalSalary += emp->getSalary();
        emp->showInformation();
        delete emp; // 释放动态分配的内存
    }

    cout << "total salary:" << totalSalary << endl;

    return 0;
}
```

这个等价写法与原始代码的功能相同，只是稍微修改了一些语法和结构。主要的改动包括：

1. 将 `calcSalary()` 函数声明为纯虚函数，并在 `employee` 类中加入 `salary` 成员变量，这样可以统一在派生类中实现计算工资的方法。
2. 使用范围`for`循环 (`for (employee *emp : empList)`) 迭代遍历 `empList` 中的元素，而不是使用传统的索引循环。
3. 在循环结束后，释放动态分配的内存，避免内存泄漏。
### 29 企业经营税

问题描述 :

有两类企业：服务性企业及制造业企业。服务性企业按营业收入的5%征税，制造业企业按营业收入的17%征税。

现需编写程序，输入多个企业的类别及营业收入，计算并输出税收总额。

本题使用多态的特性完成，需要定义三个类：

Company类：基类

Service类：服务性企业类，由Company类派生

Manufacturer类：制造业企业类，由Company类派生

请完成以上三个类的代码，使得程序能按范例输入、输出。

输入说明 :

可输入多组数据，每组占一行。

每一行包含两部分，

第一部分为一个字母S或M，输入S表示服务性企业，输入M表示制造业企业。

第二部分为一个整数，表示企业的营业收入。

输出说明 :

输出一个数字，表示企业的税收总额。

输入范例 :

```
S 1005
M 2000
```

输出范例 :

```
390.25
```

```cpp
int main()
{
    char ch;
    int income;
    double totalTax=0;
    while(cin>>ch>>income)
    {
        if(ch=='S')
        {
            Company c=Service s(income);
            totalTax+=c.GetTax();


        }
        if(ch=='M')
        {
            Company c=Manufacturer m(income);
            totalTax+=c.GetTax();


        }
    }
    cout<<totalTax<<endl;
}

```

上面的代码报错`error: expected primary-expression before 's'`，这是什么原因？

代码报错的原因是在创建 `Company` 对象时，使用的是错误的语法。

在代码中，尝试创建 `Company` 对象并将其初始化为 `Service` 或 `Manufacturer` 类的对象。然而，这种写法是不正确的。正确的写法应该是先创建 `Service` 或 `Manufacturer` 对象，然后将其赋值给 `Company` 对象。

以下是修正后的代码：

```cpp
int main()
{
    char ch;
    int income;
    double totalTax = 0;

    while (cin >> ch >> income)
    {
        if (ch == 'S')
        {
            Service s(income);
            Company& c = s;
            totalTax += c.GetTax();
        }
        if (ch == 'M')
        {
            Manufacturer m(income);
            Company& c = m;
            totalTax += c.GetTax();
        }
    }

    cout << totalTax << endl;
}
```

修正后的代码将先创建 `Service` 或 `Manufacturer` 对象，然后将其赋值给 `Company` 对象的引用 `c`。这样就可以调用 `Company` 类中的成员函数 `GetTax()` 来获取税金。

请注意，这里假设 `Service` 和 `Manufacturer` 类都是 `Company` 类的派生类，并且 `Company` 类中有一个名为 `GetTax()` 的虚函数。

```cpp
#include <iostream>
using namespace std;

class Company
{
    char type;
    double tax;
    int income;
public:
    Company(char type,int income)
    {
        this->type=type;
        this->income=income;
    }
    virtual double GetTax(){}
    friend class Service;
    friend class Manufacturer;
};

class Service:public Company
{
public:
    Service(int income):Company('S',income)
    {

    }
    double GetTax()
    {
        tax=0.05*income;
        return tax;
    }
};

class Manufacturer:public Company
{
public:
    Manufacturer(int income):Company('M',income)
    {

    }
    double GetTax()
    {
        tax=0.17*income;
        return tax;
    }
};

int main()
{
    char ch;
    int income;
    double totalTax = 0;

    while (cin>>ch>>income)
    {
        getchar();
        if (ch == 'S')
        {
            Service s(income);
            Company& c = s;
            totalTax += c.GetTax();
        }
        if (ch == 'M')
        {
            Manufacturer m(income);
            Company& c = m;
            totalTax += c.GetTax();
        }
    }

    cout << totalTax << endl;
}
```

### 30 模板类练习：实现两个整数、浮点数和字符的比较

问题描述 :

请定义一个类模板，利用它分别实现两个整数、浮点数和字符串的比较。在main函数中应用并测试之。

输入说明 :

每组输出分3行：  

第一行：标志行（'i'代表输入两个整数进行比较；'f'代表输入两个浮点数进行比较；'s'代表输入两个字符串进行比较；'e'代表输入结束。）

第二行和第三行分别对应进行比较的两个数据

输入行之间无多余的空行，每行的开头和结尾无多余的空格

输入可连续进行。

输出说明 :

每组输入数据对应一行输出数据，为2个比较数据之中的较大者。  

组与组的输出行之间无多余的空行，每行的开头和结尾无多余的空格。

输入范例 :

```
i
212
323
f
1.1
0.51
s
China
china
i
3243
253
e
```

输出范例 :

```
323
1.1
china
3243
```

```cpp
#include <iostream>

using namespace std;

template<class T>
class Cmp
{
private:
    T x,y;
public:
    Cmp(T x,T y)
    {
        this->x=x;
        this->y=y;
    }
    T Compare()
    {
        return (x>y?x:y);
    }
};

int main()
{
    char ch;
    while(cin>>ch&&ch!='e')
    {
        if(ch=='i')
        {
            int x,y;
            cin>>x>>y;
            Cmp<int>c(x,y);
            cout<<c.Compare()<<endl;
        }
        if(ch=='f')
        {
            float x,y;
            cin>>x>>y;
            Cmp<float>c(x,y);
            cout<<c.Compare()<<endl;
        }
        if(ch=='s')
        {
            string x,y;
            cin>>x>>y;
            Cmp<string>c(x,y);
            cout<<c.Compare()<<endl;
        }
    }
}

```







