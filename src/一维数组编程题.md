# 一维数组编程题

<!-- toc -->

## 4.1一维数组->简单

### 奇妙的数字

问题描述 :

有一种自然数，它的各位数字之和能被17整除。这个数的后继数（即这个数加1）的各位数字之和也能被17整除。求所有自然数中，从小到大第n个这样的数。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据占一行，其中仅有一个整数n（1≤n≤10）。在行首和行尾没有多余的空格。所有数据前后没有多余的空行，两组数据之间也没有多余的空行。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。每组答案占一行，每行中仅有一个整数，即题目描述中的第n个数。在行首和行尾不要输出多余的空格。在所有数据的前后，以及两组数据之间不要输出多余的空行。

输入范例 :

```
1
3
```

输出范例 :

```
8899
17899
```

```cpp
#include <iostream>

using namespace std;


int main() {

    const int MAX=100;
    int num[MAX];
    int i = 0;
    const int MAX2=100000;
    int num2[MAX2]={0};

    while(cin>>num[i])
    {
        i++;
    }

    //cout<<i<<endl;//2
    //cout<<num[1]<<endl;//3
    int no=0;
    for(int p=2000;p<999999;p++)
        {
            //cout<<no<<p<<endl;
            int sum1=p/100000+p/10000%10+p/1000%10+p/100%10+p/10%10+p%10;
            int sum2 = (p+1)/100000+(p+1)/10000%10+(p+1)/1000%10+(p+1)/100%10+(p+1)/10%10+(p+1)%10;
            if((sum1%17==0)&&(sum2%17==0))
            {

                num2[no]=p;
                no++;
                //cout<<p<<" "<<sum1<<" "<<sum2<<endl;
                continue;

                /*if(num[j]==no)
                {
                    cout<<num[j]<<endl;//1
                    cout<<j<<endl;//0
                    cout<<no<<" "<<p<<endl;//1 8899
                }
            }
            break;*/
        }
        }
    //cout<<num2[0]<<endl;
    for(int k=0;k<i;k++)
    {
        if(num2[num[k]-1]!=0) cout<<num2[num[k]-1]<<endl;
    }

    return 0;
}
```


### 卖鸭子

问题描述 :

有一个养鸭专业户，赶了一大群鸭子出去卖。他每经过一个村庄，卖出当时所有赶的鸭子的一半再多一只（他没有劈开过鸭子...），这样他经过七个村庄后，还剩下两只鸭子，那么请算一下他经过第N个村庄时卖出多少只鸭子，还有多少只鸭子。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组一行，每行数据包含一个整数N，1≤N≤7。两组数据之间没有多余的空行。在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。每组输出数据由一行组成，该行中包含两个整数，第一个代表在第N个村庄卖出了多少鸭子，第二个代表还剩下多少鸭子。两组数据之间也没有多余的空行。在行首和行尾没有多余的空格。

输入范例 :

```
3
7
```

输出范例 :

```
64 62
4 2
```

```cpp
#include <iostream>
using namespace std;

const int MAX=10;

int main()
{
    int num[MAX]={0};
    int left[MAX];
    int sold[MAX];
    int i=0;
    while(cin>>num[i])
        i++;

    left[6]=2;
    sold[6]=4;
    for(int j=6;j>=0;j--)
    {
        left[j-1]=left[j]*2+2;
        sold[j]=left[j-1]-left[j];
    }
    for(int t=0;t<i;t++)
        if(num[t]!=0)
        {
            cout<<sold[num[t]-1]<<" "<<left[num[t]-1]<<endl;
        }

    return 0;
}
```

### 求完美数

问题描述 :

如果一个自然数的所有小于自身的因子之和等于该数，则称为完美数。设计算法，打印1-9999之间的所有完美数。

输入说明 :

无输入  

输出说明 :

参见范例  

输入范例 :

输出范例 :

```
6
28
496
8128
```


```cpp
#include <iostream>
using namespace std;

const int MAX=20;

int main()
{
    int num[MAX]={0};
    int n=0;
    for(int i=4;i<10000;i+=2)
    {
        int sum=0;
        for(int j=1,t=0;j<i&&t<200;j++)
        {
            if(i%j==0)
            {
            t++;
            sum+=j;
            }
        }
        if(sum==i)
        {
            num[n]=i;
            n++;
        }
    }

    for(int t=0;t<n;t++)
    {
        if(num[t]!=0)
        {
            cout<<num[t]<<endl;
        }
    }
    return 0;
}
```

### 删除数组元素（求助GPT）

问题描述 :

已有一维数组，存储不超过100个整型数据，由用户输入一个元素值，从数组中删除与该值相等的所有元素（考虑到元素值可能重复，因此可能删除多个元素），并输出结果数组。

输入说明 :

用户可输入多组数据，每组数据由三行组成：

第一行：数组元素的个数n

第二行：n个数组元素，由空格分隔

第三行：需要删除的元素

输出说明 :

对于每组输入，输出最后的结果，整数之间以空格分隔。每行的开头与结尾无多余空格。

每组输出占一行。

如果结果数组为空，则输出“Empty array!”。

输入范例 :

```
5
1 2 3 4 5
3
20
1 2 3 1 2 3 4 5 6 7 1 2 3 1 2 3 4 5 6 7
2
```

输出范例 :

```
1 2 4 5
1 3 1 3 4 5 6 7 1 3 1 3 4 5 6 7
```

```cpp
#include <iostream>
using namespace std;

const int MAX=1000;

int main()
{
    int t=0;
    while(cin!=EOF)
    {
        int n;
        cin>>n;
        int a[n];
        int i=0;
        while(i<n)
        {
            cin>>a[i];
            i++;
        }
        cin>>del[t];
        t++;
    }
    
    return 0;
}
```

GPT4实现（注：可以读取一行，输出一行，可以AC，这道题最难的部分就在这里了。如果先把数据全读进去、存储再删除输出即全部的输出和全部的输入分开，暂时仍旧实现不了。）

以下是一个简单的C++程序，它根据您给出的问题构建并测试：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n;
    while(std::cin >> n) {
        std::vector<int> arr(n);
        for(int i = 0; i < n; ++i) {
            std::cin >> arr[i];
        }
        
        int target;
        std::cin >> target;
        
        arr.erase(std::remove(arr.begin(), arr.end(), target), arr.end());
        
        if(arr.empty()) {
            std::cout << "Empty array!" << std::endl;
        }
        else {
            for(size_t i = 0; i < arr.size(); ++i) {
                if(i > 0) {
                    std::cout << " ";
                }
                std::cout << arr[i];
            }
            std::cout << std::endl;
        }
    }
    return 0;
}
```

这个程序首先读取数组的大小`n`，然后读取`n`个元素并将它们存储在`std::vector`中。然后，它读取要删除的目标元素`target`。`std::remove`函数用于移动所有`target`之外的元素到数组的开始部分，并返回一个指向新“结束”的迭代器。然后，`erase`函数删除这个新“结束”迭代器之后的所有元素。

如果数组为空，则输出“Empty array!”。否则，输出数组的所有元素。

这个程序在您提供的输入范例上进行了测试，并产生了期望的输出范例。

### 只出现一次的数字（求助GPT）

问题描述 :

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

输入说明 :

所写的程序要求从标准输入设备中读入测试数据作为程序的输入数据。标准输入设备中有多组测试数据，每组测试数据占两行。第一行输入数据个数n，n大于等于1并且不超过100；第二行输入包含n个数字，除一个数字外，其余数字均出现两次，每个数字大小不超出int的范围。

输出说明 :

输出唯一出现一次的数字。注意：每组运算结果单独形成一行数据，每组测试数据与其后一组测试数据之间没有空行，第一组测试数据前面没有任何空行。

输入范例 :

```
3
2 2 1
5
4 1 2 1 2
```

输出范例 :

```
1
4
```

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int MAX=100;

int main()
{
    int t=0;
    int num[MAX]={0};
    //int a[MAX];
    int n;
    cin>>n;
    //while(scanf("%d",&n)!=EOF)
    //{
    int a[n]={0};
    int i=0;
    while(i<n)
    {
        cin>>a[i];
        //cout<<a[i]<<endl;
        i++;
    }

    //}
    for(int j=0;j<100;j++){
        num[a[j]]++;
        cout<<num[a[j]]<<endl;

    }
    for(int t=0;t<100;t++)
    {
        if(num[a[t]]==1) cout<<a[t]<<endl;
    }

    return 0;
}
```

可以使用数组来实现计数的功能，数组下标表示数字，数组元素表示该数字出现的次数。以下是使用数组实现的 C++ 程序代码：

```c++
#include <iostream>
#include <vector>

using namespace std;

const int MAXN = 100005;

int main() {
    int n;
    while (cin >> n) {
        vector<int> nums(n);
        int count[MAXN] = {0};
        for (int i = 0; i < n; i++) {
            cin >> nums[i];
            count[nums[i]]++;
        }
        for (int i = 0; i < n; i++) {
            if (count[nums[i]] == 1) {
                cout << nums[i] << endl;
                break;
            }
        }
    }
    return 0;
}
```

解释如下：

1. 包含必要的头文件 `iostream` 和 `vector`。

2. 定义常量 `MAXN` 表示最大数字范围，本题数据中数字大小不超出 `int` 的范围，因此可以设 `MAXN = 100005`。

3. 进入主函数，通过 `while` 循环不断读入多组测试数据。每组测试数据占两行，第一行是数据的个数 `n`，第二行包含 `n` 个数字，除了一个数字外，其余数字均出现两次。

4. 在每组测试数据的处理过程中，使用一个大小为 `MAXN` 的数组 `count` 来统计每个数字出现的次数，使用 `vector` 来保存输入的数字。

5. 读入 `n` 个数字并统计出现次数。

6. 遍历保存的数字，如果发现某个数字出现次数为 1，则输出该数字并跳出循环。

7. 循环结束后回到 `while` 循环的开始，等待下一组测试数据。

### 排序（求助GPT）

问题描述 :

给你N个整数, 将他们排序后输出.

输入说明 :

输入数据第一行包含一个数T ( T <=10 )，接下有T行，每行一组测试数据. 第一个数是一个整数 N , 接下来有 N 个整数.N <= 10000

输出说明 :

对于每组测试数据，将他们排序后输出, 数字间用一个空格隔开

输入范例 :

```
3
3 1 -10000 44
1 47
2 2 6
```

输出范例 :

```
-10000 1 44
47
2 6
```

```cpp
#include <iostream>

using namespace std;

void bubble_sort(int array[]) {

    int i,j,tmp,n=10000;
    bool flag;


    for(j=0;j<n-1;j++){
        flag=false;
        for(i=0;i<n-1-j;i++)
            if(array[i]>array[i+1])
            {
                tmp=array[i];
                array[i]=array[i+1];
                array[i+1]=tmp;
                flag=true;
            }
        if(!flag) break;
    }
}

int main()
{
    int N,num;
    cin>>N;
    int array[N][10000]={0};
    for(int i=0;i<N;i++)
    {
        cin>>num;
        for(int j=0;j<num;j++)
        {
            cin>>array[i][j];
        }
        bubble_sort(array[i]);
    }
    for(int i=0;i<N;i++)
    {

        if(array[i][0]!=0)
            cout<<array[i][0];

        for(int j=1;j<10000;j++)
        {
            if(array[i][j]!=0)
            {
                cout<<" "<<array[i][j];
            }
        }
        cout<<endl;

    return 0;
}

```


以下是使用C++编程语言实现的解决方案。这个程序首先读取测试案例的数量，然后对每个测试案例进行处理。对于每个测试案例，它首先读取数字的数量，然后读取这些数字并将它们存储在一个向量中。然后，它使用 `std::sort` 对向量进行排序，最后输出排序后的数字。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int T;
    std::cin >> T;

    for (int t = 0; t < T; ++t) {
        int N;
        std::cin >> N;

        std::vector<int> nums(N);
        for (int i = 0; i < N; ++i) {
            std::cin >> nums[i];
        }

        std::sort(nums.begin(), nums.end());

        for (int i = 0; i < N; ++i) {
            if (i != 0)
                std::cout << " ";
            std::cout << nums[i];
        }
        std::cout << "\n";
    }

    return 0;
}
```

在终端/命令行运行此程序并输入提供的范例输入，将得到范例输出。

要注意的一点是，这个程序使用了C++的标准模板库(STL)中的`std::sort`函数，这是一个非常强大的排序函数，它使用快速排序，堆排序，插入排序的混合排序算法，被称为intro sort。

### 平均值问题（求助GPT）

问题描述 :

从键盘上输入一个整数n，之后输入n 个实数，输出这n个实数的平均值，并统计平均值以上(含平均值) 的实数个数。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组测试数据数据占两行，第一行表示输入数据的个数（大于零，小于等于80），第二行是输入的数据，其中每个数据都是实数。

输出说明 :

对每组测试数据，你的程序需要向标准输出文件（通常为启动该程序的终端）输出一个答案。每个答案占一行。说明：计算结果小数点后保留六位。

输入范例 :

```
9
12.2   34.0  4.8  23.0  34.9  45.3  18.0  3.0  11.0
```

输出范例 :

```
20.688889 4
```

以下是满足题目要求的C++程序代码，可以在标准输入设备中读入多组测试数据，对每组测试数据输出平均值和平均值以上的实数个数。

```c++
#include <iostream>
#include <vector>
#include <iomanip>

using namespace std;

int main() {
    int n;
    while (cin >> n) {
        vector<double> nums(n);
        double sum = 0, average = 0;
        int count = 0;
        for (int i = 0; i < n; i++) {
            cin >> nums[i];
            sum += nums[i];
        }
        average = sum / n;
        for (int i = 0; i < n; i++) {
            if (nums[i] >= average) {
                count++;
            }
        }
        cout << fixed << setprecision(6) << average << " " << count << endl;
    }
    return 0;
}
```

程序的主要思路就是根据题目要求，先在循环中读入n个实数，并计算它们的和，然后再计算平均值，最后再次循环统计平均值以上的实数个数。这里使用了vector作为存储n个实数的数据结构。

需要注意的是，为了保证输出结果精度，需要使用`fixed`和`setprecision`函数，将小数点后保留6位。同时，为了能够读入多组测试数据，需要使用while循环，并在循环中读入每组测试数据的n和实数。

```cpp
#include <iostream>
using namespace std;

const int MAX=20;

int main()
{
    int num[MAX]={0};
    int n=0;
    int number;
    cin>>number;
    for(int i=4;i<=number;i+=2)
    {
        int sum=0;
        for(int j=1,t=0;j<i&&t<200;j++)
        {
            if(i%j==0)
            {
            t++;
            sum+=j;
            }
        }
        if(sum==i)
        {
            num[n]=i;
            n++;
        }
    }

    for(int t=0;t<n;t++)
    {
        if(num[t]!=0)
        {
            cout<<num[t]<<endl;
        }
    }
    return 0;
}
```

## 4.2一维数组->中等

### 三艘船

问题描述 :

明明由于工作的关系，经常需要坐船到某地出差办事。久而久之，明明就对这两地之间船的班次情况相当了解，他会根据办事的具体情况选择不同班次的船出行。这两地的船一共分为三个班次：特快船、快船、慢船，三个班次的船在同一天的0点从港口出发，并沿着同一路线匀速航行，只是它们到达目的地的时刻不同。 你作为明明的好朋友，有一次和明明在闲聊，问到他出差时船的航行距离有多少时，明明没有正面回答你这个问题，而只是把三艘船（特快、快、慢）的速度，以及它们到达目的地的时间是几点钟（并不知道分别是哪一天，只知道三艘船都在100天以内到达了终点）告诉了你，要你推算出两地间的距离长度。你作为一位程序设计专家，自然不会被明明的这个问题所难倒，于是你决定写一个程序，来求解这个看似困难其实简单的问题。 明明的问题可以归结为：给出三艘船的速度，以及它们到达目的地时是几点钟（并不知道分别是哪一天，只知道三艘船都在100天以内到达了终点），求两地间的距离到底有多少。若有多组解，只输出最小的那组解。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据占二行，第一行有3个正整数a、b、c，代表3艘船的到达港口那天的时间是几点钟（0≤a、b、c≤23）。第二行有3个正整数d、e、f代表3艘船的速度（0<d、e、f<30000），速度的单位是单位距离每小时。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果由一个整数构成，代表路程的长度，若有多组解，只输出最小的那组解。每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。

输入范例 :

```
4 2 20
5 10 13
18 12 21
6 9 12
```

输出范例 :

```
260
540
```

```cpp
#include <iostream>

using namespace std;

int main()
{
    int a,b,c,d,e,f;
    while(cin>>a>>b>>c&&cin>>d>>e>>f)
    {

        for(int i=1;i<20000;i++)
        {
            if(i%(24*d)==d*a&&i%(24*e)==b*e&&i%(24*f)==c*f)
            {
                cout<<i<<endl;
                break;
            }
        }
    }

    return 0;
}
```

### 求数列项

问题描述 :

数列是数学世界中一种非常有趣的数字排列规则，它使一串数字相互之间产生了某种联系，变幻无穷。很多数学家对数列产生了浓厚的兴趣，花了很多时间对其进行研究，明明就是其中的一位。一天，他又专注于一种新的数列排列规则，该排列规则满足以下条件：

1. 该数列的第一个数为1。

2. 该数列的第二个数为5。

3. 该数列的第i （其中i > 2）个数为第i - 1个数的数值加上(i - 3) × 3 + 7。

明明很快就推算出了这个数列的前三项数字：

1. 第一项为1。

2. 第二项为5。

3. 第三项为12。（第三项的数字为第二项的数字加上(3 - 3) × 3 + 7，即第三项的数为：5 + (3 - 3) × 3 + 7 = 12）

但是当明明还想继续把数列往下推算的时候，他发现计算量越来越大，计算难度越来越高，计算速度也越来越慢。于是，明明就求助于你这位程序设计专家，帮他写一个程序，计算出数列的前50项，然后当明明需要知道数列中的哪一项的数字时，你就把那一项的数字告诉明明。 明明的问题可以归结为：根据一个正整数n，要求你输出题目中所描述的数列的第n项数值。

输入说明 :

你写的程序需要从标准输入设备（通常为键盘）中读入多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数n（1 ≤ n ≤ 50）。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序需要计算出一组相应的运算结果，并将每组运算结果依次写入到标准输出设备（通常为启动该程序的文本终端，例如Windows中的命令行终端）中。每组运算结果为一个整数，即题目中所描述的数列的第n项数值。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。

输入范例 :

```
1
2
```

输出范例 :

```
1
5
```

```cpp
#include <iostream>

using namespace std;

int Seq(int n)
{
    if(n==1) return 1;
    if(n==2) return 5;
    return Seq(n-1)+(n-3)*3+7;
}


int main()
{
    int n;
    while(cin>>n)
    {
        cout<<Seq(n)<<endl;
    }

    return 0;
}
```

### 数列1（求助GPT）

问题描述 :

思维的严密性是相当重要的，尤其是在程序设计中，一个小小的错误，就可能导致无法想象的后果。明明的爸爸是一名富有经验的程序设计专家，深知思维严密的重要性。于是在明明很小的时候，就通过游戏的方式训练明明的思维严密性。今天，明明的爸爸和明明做了一个数列的游戏。

这个游戏很简单，就是有一数列，现在需要在数列中选出一个或者连续若干个数，要求这些数的和能被11整除。明明的爸爸想锻炼明明思维的严密性，因此要求明明尽可能多的找出符合条件的数列来，最好一个也不要漏掉。 例如有一数列为“11 22 33”，其中11可以被11整除，22可以被11整除，33可以被11整除，11+22=33能被11整除，22+33=55能被11整除，11+22+33=66能被11整除。所以以上一数列能被11整除的情况一共有六种。（注：虽然11+33也能被11整除，但是11和33在数列中没有连续出现，因此不算一种合理的情况。） 明明对这个游戏很感兴趣，高兴地玩了起来。由于粗心，明明总是无法一次就把所有的情况都找出来，这使得他爸爸不是很满意。于是明明爸爸决定先降低游戏的难度，事先告诉明明某一数列总共有多少种符合条件的选择数的方法，然后再让明明去选。明明的爸爸请你帮一个忙，他不想自己找出所有的情况，因此请你写一个程序，用程序来找出一共有多少种符合选数的情况，并把结果告诉他。 明明爸爸的问题可以归结为：给你一个数列，从中选出1个或连续若干个数，要求这些数的和能被11整除，问这样的选数方法一共有多少种。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有两行，每组测试数据的第一行有一个整数n(0<n≤50)，表示数字串中有多少个整数，每组测试数据的第二行有n个整数，整数大于等于0且小于等于100，整数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表示一共有多少种选数方法。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
10
1 1 1 1 1 1 1 1 1 1
2
11 22
```

输出范例 :

```
0
3
```

这是一个需要使用动态规划解决的问题。这个问题的关键是如何设计一个有效的状态转移方程。

整个问题可以被分解为以下两个步骤：

1. 遍历所有可能的子序列。
1. 检查子序列的和是否能被11整除。

我们可以使用一个二维数组`dp[i][j]`表示前`i`个数中，和模上11为`j`的数量。

状态转移方程可以描述为：

- 如果不选择第i个数，那么`dp[i][j] = dp[i-1][j]`
- 如果选择第i个数，那么`dp[i][j] = dp[i-1][(j-arr[i])%11]`

最后，我们要找的答案就是`dp[n][0] - 1`，减去1是因为不取任何数也能得到和为0。

下面是完整的C++代码：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        vector<int> arr(n);
        for (int i = 0; i < n; ++i) {
            cin >> arr[i];
            arr[i] %= 11;  // 取余数，方便后续计算
        }

        vector<vector<int>> dp(n+1, vector<int>(11, 0));
        dp[0][0] = 1;  // 初始状态，没有数，和为0

        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < 11; ++j) {
                // 状态转移方程
                dp[i][j] = dp[i-1][(j+11-arr[i-1])%11] + dp[i-1][j];
            }
        }
        cout << dp[n][0] - 1 << endl;  // 输出结果，减去1是因为不取任何数也能得到和为0
    }
    return 0;
}
```

注意：这个程序只能处理输入数据在正确格式下的情况，如果输入数据格式错误，这个程序可能会出现未定义的行为。

GPT4写的这个程序遇见下面的结果时报错

```
50
3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 3 8 1 1 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7 4 7
//输出结果1083005198
//正确结果288
```

让ChatGPT改了好多次也没改成功，哎！正确代码如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main() {

    int n,i,sum,count,j,k,out;
    int a[51];
    while(scanf("%d",&n)!=EOF)
    {
        for(i=0;i<n;i++)
            cin>>a[i];
        count=0;
        for(i=1;i<=n;i++)
        {
            for(j=0;j<n;j++)
            {
                sum=0;
                for(k=j;k<=j+i-1;k++)
                {
                    out=0;
                    if(k>=n)
                    {
                        out=1;
                        break;
                    }
                    sum+=a[k];
                }
                if(sum>0&&sum%11==0&&out!=1)
                    count++;
            }
        }
        cout<<count<<endl;

    }
    return 0;
}
```

### 删除数组重复元素（求助GPT）

问题描述 :

已有一维数组，存储不超过100个整型数据，其中有些元素的值存在重复，从数组中删除所有重复的元素（每个元素只保留一个），并输出结果数组。

输入说明 :

已有一维数组，存储不超过100个整型数据，其中有些元素的值存在重复，从数组中删除所有重复的元素（每个元素只保留一个），并输出结果数组。

输出说明 :

对于每组输入，输出最后的结果，整数之间以空格分隔。每行的开头与结尾无多余空格。

每组输出占一行。

输入范例 :

```
10
1 5 4 3 2 9 7 8 6 10
10
1 5 5 3 2 9 7 8 6 10
```

输出范例 :

```
1 5 4 3 2 9 7 8 6 10
1 5 3 2 9 7 8 6 10
```

自己学着用unordered_set处理这个问题，但被暴击了，尴尬！

我用c++中的unordered_set对vector元素进行去重操作，但输出结果的顺序存在很大的问题，帮我找出原因，改正程序，前面是代码，后面是测试数据和结果                     
 ```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

int main()
{
    int n;
    while(cin>>n)
    {
        vector<int> vec(n);
        for(int i=0;i<vec.size();i++)
            {
                cin>>vec[i];
            }
        unordered_set<int>s(vec.begin(),vec.end());
        //for(auto it:s)
            //cout<<it<<" ";
        vec.assign(s.begin(),s.end());
        //vec.insert(vec.end(),s.begin(),s.end());
        for(int i=1;i<vec.size();i++)
            cout<<vec[i]<<" ";
        cout<<vec[0]<<endl;
    }
}
```

```
5
1 2 3 5 4
1 2 3 5 4
10
1 5 5 3 2 9 7 8 6 10
6 8 7 9 2 3 5 1 10
```

在使用`unordered_set`进行去重操作后，输出结果的顺序可能会发生变化，因为`unordered_set`是基于哈希表实现的，它不保证元素的顺序。因此，你需要使用`set`来保持元素的有序性。

修改你的程序如下：

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int main()
{
    int n;
    while(cin >> n)
    {
        vector<int> vec(n);
        for(int i = 0; i < vec.size(); i++)
        {
            cin >> vec[i];
        }
        set<int> s(vec.begin(), vec.end());
        vec.assign(s.begin(), s.end());
        for(int i = 0; i < vec.size() - 1; i++)
            cout << vec[i] << " ";
        cout << vec[vec.size() - 1] << endl;
    }
}
```

使用以上修改后的代码，输入测试数据和结果如下：

```
5
1 2 3 5 4
1 2 3 4 5
10
1 5 5 3 2 9 7 8 6 10
1 2 3 5 6 7 8 9 10
```

现在，输出结果按升序排列，并且保持了原始顺序中的相对顺序。使用`set`容器可以确保元素的有序性。

如果你不希望对元素进行排序，但仍然想对元素进行去重操作，你可以使用`std::unordered_set`来实现。`std::unordered_set`是一个基于哈希表的容器，它可以在常数时间内插入和查找元素。

以下是修改后的代码示例：

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

int main()
{
    int n;
    while(cin >> n)
    {
        vector<int> vec(n);
        for(int i = 0; i < vec.size(); i++)
        {
            cin >> vec[i];
        }
        unordered_set<int> s;
        vector<int> result;
        for(const auto& num : vec)
        {
            if(s.find(num) == s.end()) // 如果集合中不存在该元素
            {
                s.insert(num);
                result.push_back(num);
            }
        }
        for(int i = 0; i < result.size() - 1; i++)
            cout << result[i] << " ";
        cout << result[result.size() - 1] << endl;
    }
}
```

使用以上修改后的代码，输入测试数据和结果如下：

```
5
1 2 3 5 4
1 2 3 5 4
10
1 5 5 3 2 9 7 8 6 10
1 5 3 2 9 7 8 6 10
```

现在，输出结果中的顺序与输入保持一致，且元素已经被去重。这是通过使用`std::unordered_set`和辅助的`std::vector`容器来实现的。

除了使用`std::unordered_set`之外，还可以使用以下两种方法在不排序的情况下对元素进行去重：

1. 使用`std::set`容器：`std::set`是一个有序容器，它会自动对元素进行排序，并且保证元素的唯一性。你可以将元素插入到`std::set`中，然后将`std::set`中的元素复制回原始的`std::vector`，这样就可以实现去重。

下面是示例代码：

```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

int main()
{
    int n;
    while(cin >> n)
    {
        vector<int> vec(n);
        for(int i = 0; i < vec.size(); i++)
        {
            cin >> vec[i];
        }
        set<int> s(vec.begin(), vec.end());
        vec.assign(s.begin(), s.end());
        for(int i = 0; i < vec.size(); i++)
             cout << vec[i] << " ";
        cout << endl;
    }
}
```

使用以上代码，输入测试数据和结果如下：

```
5
1 2 3 5 4
1 2 3 4 5
10
1 5 5 3 2 9 7 8 6 10
1 2 3 5 6 7 8 9 10
```

   这种方法会对元素进行排序，但你可以得到去重后的有序结果。

2. 使用自定义去重函数和`std::remove_if`算法：你可以自定义一个去重的谓词函数，并使用`std::remove_if`算法将重复元素移到容器的末尾，然后使用`std::vector`的`erase`函数将重复元素从容器中移除。

下面是示例代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

bool isDuplicate(int num)
{
    // 自定义的去重谓词函数
    // 返回 true 表示元素是重复的，需要移除
    // 返回 false 表示元素是唯一的，保留
    // 这里假设元素值小于等于 1000
    return (num <= 1000);
}

int main()
{
    int n;
    while(cin >> n)
    {
        vector<int> vec(n);
        for(int i = 0; i < vec.size(); i++)
        {
            cin >> vec[i];
        }
        vec.erase(remove_if(vec.begin(), vec.end(), isDuplicate), vec.end());
        for(int i = 0; i < vec.size(); i++)
             cout << vec[i] << " ";
        cout << endl;
    }
}
```

使用以上代码，输入测试数据和结果如下：

```
5
1 2 3 5 4
1 2 3 5 4
10
1 5 5 3 2 9 7 8 6 10
6 8 7 9 2 3 5 1 10
```

这种方法不会对元素进行排序，但是你无法保证元素的顺序，只能保证去重后的元素在容器中的相对顺序不变。

下面是根据题目信息完成的C++程序：

```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }

        unordered_set<int> uniqueSet;
        vector<int> result;
        for (int i = 0; i < n; i++) {
            if (uniqueSet.find(arr[i]) == uniqueSet.end()) {
                uniqueSet.insert(arr[i]);
                result.push_back(arr[i]);
            }
        }

        for (int i = 0; i < result.size(); i++) {
            cout << result[i];
            if (i != result.size() - 1) {
                cout << " ";
            }
        }
        cout << endl;
    }

    return 0;
}
```

这段代码使用了`unordered_set`来辅助去重操作。每次读入整数数组后，遍历数组元素，如果元素不存在于`unordered_set`中，则将其插入`unordered_set`并将其添加到结果数组中。最后，输出结果数组的元素。

使用以上代码，输入测试数据和输出结果如下：

输入：

```
10
1 5 4 3 2 9 7 8 6 10
10
1 5 5 3 2 9 7 8 6 10
```

输出：

```
1 5 4 3 2 9 7 8 6 10
1 5 3 2 9 7 8 6 10
```

### 谁是老二？（求助GPT）

问题描述 :

一维数组中存储不超过100个整型数据，请找出其中第二大的元素，输出这些元素的值以及它们的下标。

注意，由于元素值可能相同，因此具有最大值的元素个数可能不只一个，第二大的元素是比它们小的那些元素。

输入说明 :

用户可输入多组数据，每组数据由两行组成：

第一行：数组元素的个数n

第二行：n个数组元素，由空格分隔

输出说明 :

对于每组输入，输出一行，包含第二大的元素的值以及它们的下标（都是整数），整数之间以空格分隔。如果有多个下标，则下标按从小到大的顺序输出。每行的开头与结尾无多余空格。

每组输出占一行。

如果不存在第二大的元素，则输出"none"（不包含引号）

输入范例 :

```
3
2 5 4
10
1 3 5 2 4 3 7 5 7 7
5
2 2 2 2 2
```

输出范例 :

```
4 2
5 2 7
none
```

自已想出来的复杂实现1：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int FindMax(vector<int> &a,int n)
{
    int MaxValue=a[0];
    for(int i=0;i<n;i++)
    {
        if(a[i]>MaxValue)
            MaxValue=a[i];
    }
    return MaxValue;
}

int FindMin(vector<int> &a,int n)
{
    int MinValue=a[0];
    for(int i=0;i<n;i++)
    {
        if(a[i]<MinValue)
            MinValue=a[i];
    }
    return MinValue;
}
//上面的函数可以直接用排序算法或使用max_element()确定最大值进而确定第二大值
int main()
{
    int n;
    while(cin>>n)
    {
        vector<int> nums(n);
        for(int i=0;i<n;i++)
            cin>>nums[i];

        int MaxValue,SecondMaxValue,MinValue;
        MaxValue=FindMax(nums,n);
        MinValue=FindMin(nums,n);
        vector<int> vec;
        for(int i=0;i<n;i++)
        {
            if(nums[i]!=MaxValue)
                vec.push_back(nums[i]);
        }
        if(MaxValue==MinValue)
            cout<<"none"<<endl;
        else
        {
            SecondMaxValue=FindMax(vec,vec.size());
            cout<<SecondMaxValue<<" ";
            vector<int> SMV;
            for(int j=0;j<nums.size();j++)
            {
                if(nums[j]==SecondMaxValue)
                   SMV.push_back(j);
            }
            for (int i = 0; i < SMV.size(); i++) {
            cout << SMV[i];
            if (i != SMV.size() - 1) {
                cout << " ";
                }
            }
            cout << endl;

        }
    }
    return 0;
}
```

下面是ChatGPT根据题目信息完成的C++程序：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }

        int maxVal = arr[0];
        int secondMaxVal = INT_MIN;
        vector<int> indices;

        for (int i = 1; i < n; i++) {
            if (arr[i] > maxVal) {
                secondMaxVal = maxVal;
                maxVal = arr[i];
                indices.clear();
            } else if (arr[i] < maxVal && arr[i] > secondMaxVal) {
                secondMaxVal = arr[i];
            }
        }

        if (secondMaxVal == INT_MIN) {
            cout << "none" << endl;
        } else {
            for (int i = 0; i < n; i++) {
                if (arr[i] == secondMaxVal) {
                    indices.push_back(i);
                }
            }

            cout << secondMaxVal << " ";
            for (int i = 0; i < indices.size(); i++) {
                cout << indices[i];
                if (i != indices.size() - 1) {
                    cout << " ";
                }
            }
            cout << endl;
        }
    }

    return 0;
}
```

这段代码使用了两个变量`maxVal`和`secondMaxVal`来记录最大值和第二大值。遍历数组时，根据当前元素的大小更新这两个变量的值。同时，使用`vector`来记录第二大值的下标。

最后，根据第二大值是否存在输出相应的结果。

使用以上代码，输入测试数据和输出结果如下：

输入：

```
3
2 5 4
10
1 3 5 2 4 3 7 5 7 7
5
2 2 2 2 2
```

输出：

```
4 2
5 2 7
none
```

**对不起，我之前的回答有误。确实没有使用 `<algorithm>` 头文件中的任何函数。感谢你的指正。**

以下是修正后的代码：

```cpp
#include <iostream>
#include <vector>
#include <limits>
using namespace std;

int main() {
    int n;
    while (cin >> n) {
        vector<int> arr(n);
        for (int i = 0; i < n; i++) {
            cin >> arr[i];
        }

        int maxVal = numeric_limits<int>::min();
        int secondMaxVal = numeric_limits<int>::min();
        vector<int> indices;

        for (int i = 0; i < n; i++) {
            if (arr[i] > maxVal) {
                secondMaxVal = maxVal;
                maxVal = arr[i];
            } else if (arr[i] > secondMaxVal && arr[i] < maxVal) {
                secondMaxVal = arr[i];
            }
        }

        if (secondMaxVal == numeric_limits<int>::min()) {
            cout << "none" << endl;
        } else {
            for (int i = 0; i < n; i++) {
                if (arr[i] == secondMaxVal) {
                    indices.push_back(i);
                }
            }

            cout << secondMaxVal << " ";
            for (int i = 0; i < indices.size(); i++) {
                cout << indices[i];
                if (i != indices.size() - 1) {
                    cout << " ";
                }
            }
            cout << endl;
        }
    }

    return 0;
}
```

我已经更新了代码，确保没有使用 `<algorithm>` 头文件中的函数。再次抱歉给你带来的困惑。

### 特殊四位数

问题描述 :

数学一直是明明很喜欢的一门学科，不但上课认真听讲，而且还自己钻研。有一次，老师在课上讲了一种特殊的四位整数，这种整数有两个特性：

第一，它是某一个自然数的平方；

第二，它的千位数字与十位数字之和等于百位数字与个位数字之积。

然后老师就举了一个例子：1156，1156是34的平方，且1156的千位数字1加上十位数字5等于百位数字1乘以个数数字6，即1+5=1\*6。

然后老师告诉同学，这是最小的一个符合以上两个特性的四位整数，接着老师就留下了作业，要让同学们回家后尽量多的找出符合这两个特性的特殊四位数。明明回家后，就开始找了起来，1157、1158、1159、……、3136，直到到了3136（3136=56\*56，3+3=1\*6），明明才找到了第二个这样的特殊四位数。明明觉得这样找下去不是办法，后面还有好几千个数字要一个一个试下来，这样一定无法在睡觉前完成。于是明明就求助于你，帮他写一个程序，从小到大求出所有的这样的特殊四位数，然后当明明想要第几个这样的特殊四位数时，你就能够很快的告诉他。 如果把上述所有的特殊四位数按从小到大的顺序排列后记为S1，S2，…，Sn，…，即排在第1个位置上的特殊四位数记为S1，排在第2个位置上的特殊四位数记为S2，…，排在第n个位置上的特殊四位数记为Sn，那么明明的问题可以归结为：假如一个特殊四位数排在第n个位置上，那么这个特殊四位数Sn等于多少呢？

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅有一个正整数n（n不大于特殊四位数的个数），表示要求第n个特殊四位数Sn。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个正整数，表示与输入数据n相对应的那个特殊四位数Sn，每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
1
2
```

输出范例 :

```
1156
3136
```

```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

bool IsRequried(int n)
{
    int w=sqrt(n);
    if((n/1000+n%100/10)==(n/100%10)*(n%10)&&w*w==n)
        return true;
    return false;
}

int main()
{
    vector<int> nums;
    int n;
    for(int i=1001;i<10000;i++)
    {
        if(IsRequried(i))
            nums.push_back(i);
    }
    while(cin>>n)
    {
        cout<<nums[n-1]<<endl;
    }
}
```

### Huffuman树（求助GPT）

问题描述 :

Huffman树在编码中有着广泛的应用。在这里，我们只关心Huffman树的构造过程。  

给出一列数{_pi_}={_p_0, _p_1, …, _pn_-1}，用这列数构造Huffman树的过程如下：  

1. 找到{_pi_}中最小的两个数，设为_pa_和_pb_，将_pa_和_pb_从{_pi_}中删除掉，然后将它们的和加入到{_pi_}中。这个过程的费用记为 _pa_ + _pb_。  

2. 重复步骤1，直到{_pi_}中只剩下一个数。  

在上面的操作过程中，把所有的费用相加，就得到了构造Huffman树的总费用。  
　　
本题任务：对于给定的一个数列，现在请你求出用该数列构造Huffman树的总费用。  
  
例如，对于数列{_pi_}={5, 3, 8, 2, 9}，Huffman树的构造过程如下：  

1. 找到{5, 3, 8, 2, 9}中最小的两个数，分别是2和3，从{_pi_}中删除它们并将和5加入，得到{5, 8, 9, 5}，费用为5。  

2. 找到{5, 8, 9, 5}中最小的两个数，分别是5和5，从{_pi_}中删除它们并将和10加入，得到{8, 9, 10}，费用为10。  

3. 找到{8, 9, 10}中最小的两个数，分别是8和9，从{_pi_}中删除它们并将和17加入，得到{10, 17}，费用为17。  

4. 找到{10, 17}中最小的两个数，分别是10和17，从{_pi_}中删除它们并将和27加入，得到{27}，费用为27。  

5. 现在，数列中只剩下一个数27，构造过程结束，总费用为5+10+17+27=59。

输入说明 :

输入的第一行包含一个正整数_n_（_n_<=100）。  

接下来是_n_个正整数，表示_p_0, _p_1, …, _pn_-1，每个数不超过1000。

输出说明 :

输出用这些数构造Huffman树的总费用。

输入范例 :

```
5
5 3 8 2 9
```

输出范例 :`59`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;


int main()
{
    int n;

    cin>>n;

    vector<int> nums(n);
    for(int i=0;i<n;i++)
        cin>>nums[i];

    int cost=0;
    for(int j=nums.size()-1;nums.size()>1;j--)
    {
        int sum=0;
        int minValue=*min_element(nums.begin(),nums.end());
        sum+=minValue;
            //int  minPosition=min_element(nums.begin(),nums.end())-nums.begin();
        nums.erase(remove(nums.begin(),nums.end(),minValue));
        minValue=*min_element(nums.begin(),nums.end());
        sum+=minValue;
            //int  minPosition=min_element(nums.begin(),nums.end())-nums.begin();
        nums.erase(remove(nums.begin(),nums.end(),minValue));
        nums.push_back(sum);
        cost+=sum;

    }
    cout<<cost<<endl;

    return 0;

}
```

OJ结果：

```
5
335 501 170 725 479 
0
```

本地测试结果：

```
5
335 501 170 725 479
4925
```

这不是OJ系统的错！！是因为读入值的代码没有赋初值，哎！

以下是根据题目信息编写的C++程序：

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int n;
    cin >> n;

    priority_queue<int, vector<int>, greater<int>> pq;  // 使用最小堆存储数列中的数

    for (int i = 0; i < n; i++) {
        int num;
        cin >> num;
        pq.push(num);
    }

    int cost = 0;

    while (pq.size() > 1) {
        int a = pq.top();  // 取出最小的两个数
        pq.pop();
        int b = pq.top();
        pq.pop();

        int sum = a + b;  // 计算和
        cost += sum;     // 累加费用
        pq.push(sum);    // 将和加入最小堆中
    }

    cout << cost << endl;

    return 0;
}
```

以上代码使用最小堆（`priority_queue`）来存储数列中的数，将数列中的数依次加入堆中。然后，循环从堆中取出最小的两个数，计算它们的和，并将和加入堆中。在每次取出最小的两个数时，累加费用。当堆中只剩下一个数时，循环结束，输出总费用。

使用以上代码，输入示例数据并得到输出结果为：

输入：

```
5
5 3 8 2 9
```

输出：

```
59
```

下面是另一种方式完成上述程序的C++代码：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n;

    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }

    sort(nums.begin(), nums.end());  // 对数列进行排序

    int cost = 0;

    while (nums.size() > 1) {
        int a = nums[0];  // 取出最小的两个数
        int b = nums[1];

        int sum = a + b;  // 计算和
        cost += sum;     // 累加费用

        nums.erase(nums.begin(), nums.begin() + 2);  // 删除最小的两个数
        nums.insert(lower_bound(nums.begin(), nums.end(), sum), sum);  // 将和插入到合适位置
    }

    cout << cost << endl;

    return 0;
}
```

以上代码使用了`vector`来存储数列中的数，并使用`sort`函数对数列进行排序。然后，循环从数列中取出最小的两个数，计算它们的和，并将和插入到合适的位置。在每次取出最小的两个数时，累加费用。当数列中只剩下一个数时，循环结束，输出总费用。

使用以上代码，输入示例数据并得到输出结果为：

输入：

```
5
5 3 8 2 9
```

输出：

```
59
```

### 发工资咯

问题描述 :

作为需要养家糊口的人，最盼望的日子就是每月发工资的日子，呵呵

但是对于财务处的工作人员来说，这一天则是很忙碌的一天，财务处的小胡最近就在考虑一个问题：如果每个员工的工资额都知道，最少需要准备多少张人民币，才能在给每位员工发工资的时候都不用员工找零呢？

这里假设员工的工资都是正整数，单位元，人民币一共有100元、50元、20元、10元、5元、2元和1元七种。

输入说明 :

首先输入一个T，表示包含T组测试数据，

每组测试数据的第一行是一个整数n（n<100），表示员工的人数，

第二行是n个员工的工资。

输出说明 :

对于每组测试数据输出一个整数x，表示至少需要准备的人民币张数。

每个输出占一行，行首与行尾无多余空格，前后也无多余空行。

输入范例 :

```
3
1
299
2
299 197
5
123 4567 89 10 12345
```

输出范例 :

```
8
14
186
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int T;
    cin >> T;

    while(T--)
    {
        int n;
        cin>>n;
        vector<int> nums(n);
        int count=0;
        for(int i=0;i<n;i++)
        {
            cin>>nums[i];
            int sum=nums[i];
            count+=sum/100;
            sum%=100;
            count+=sum/50;
            sum%=50;
            count+=sum/20;
            sum%=20;
            count+=sum/10;
            sum%=10;
            count+=sum/5;
            sum%=5;
            count+=sum/2;
            sum%=2;
            count+=sum;
        }
        cout<<count<<endl;
    }

    return 0;
}
```

### 最大值（求助GPT）

问题描述 :

为了培养明明对数学的热爱，明明的爸爸经常想出一些简单有趣且富有数学思想的游戏给明明玩。有一次，明明的爸爸在纸上写了N个数字，有正整数、负整数和0。明明的爸爸给明明一个范围，他可以选大于等于L1个且小于等于L2个的数字（L1≤L2），且这些数字必须是连续的。但是要求明明选出的数的和最大，这样说明明可能不太明白，于是明明爸爸就举了一个简单的例子。 例如有5个数字为“1”、“2”、“3”、“4”、“5”，明明可以选择大于等于1个且小于等于2个的数字，也就是说明明可以选择1个数字，或者连续的2个数字。通过观察数字串，最后我们会选2个数字，4和5，他们的和最大，为9。 明明明白爸爸的意思后，就开始玩起游戏来。但是他发现，这个游戏看似简单，其实还是有相当的难度，因为数字越多，选择数字个数范围越大，则题目越难，到后面明明有些不想玩了。于是明明就求助于你，请你帮他写一个程序，来求出和的最大值。 明明的问题可以归结为：有N个数字，从中选择出连续的M(L1≤M≤L2)个数，求出它们之和的最大值。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有两行，每组测试数据的第一行有三个整数N(0<N≤20)、L1、L2(0<L1≤L2≤N)，N表示数字串中有多少个整数，L1、L2表示可选数字个数的范围，每组测试数据的第二行有N个整数，整数大小的绝对值都小于等于100，整数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即所求的最大值。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
4 1 2
-1 0 1 2
5 1 2
-1 -2 -3 -4 -5
```

输出范例 :

```
3
-1
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int N, L1, L2;
    while (cin >> N >> L1 >> L2) {
        vector<int> nums(N);
        for (int i = 0; i < N; ++i) {
            cin >> nums[i];
        }

        int maxSum = INT_MIN;
        for (int i = 0; i <= N - L1; ++i) {
            for (int j = L1; j <= L2 && i + j <= N; ++j) {
                int sum = 0;
                for (int k = i; k < i + j; ++k) {
                    sum += nums[k];
                }
                maxSum = max(maxSum, sum);
            }
        }

        cout << maxSum << endl;
    }

    return 0;
}
```

该程序使用了嵌套的循环来遍历所有可能的连续数的组合，计算它们的和并找到最大值。外层循环控制起始位置，内层循环控制连续的数字个数。在每一次迭代中，计算当前组合的数字之和，并更新最大和。最后，输出最大和。

这个程序的目标是在给定的数字串中选择连续的 M 个数，并计算它们的和的最大值。它的实现思路如下：

1. 首先，读取输入数据，包括数字串的长度 N，选择数字个数范围的下限 L1 和上限 L2，以及数字串本身。

2. 接下来，使用一个嵌套的循环结构来遍历所有可能的连续数的组合。外层循环控制起始位置，内层循环控制连续的数字个数。

3. 在每一次迭代中，使用一个变量 `sum` 来记录当前组合的数字之和。通过内层循环中的起始位置和连续的数字个数，计算出当前组合的结束位置。然后，使用一个额外的循环来遍历从起始位置到结束位置的数字，并将它们累加到 `sum` 变量中。

4. 在每一次迭代中，使用 `maxSum` 变量来记录当前的最大和。如果当前的 `sum` 大于 `maxSum`，则更新 `maxSum`。

5. 最后，完成所有的迭代后，输出 `maxSum`，即为所求的最大和。

这样的实现方式能够穷举所有可能的连续数的组合，并计算它们的和，找到其中的最大值。通过嵌套的循环来遍历所有起始位置和连续数字个数的组合，确保了算法的完备性。这样的实现方式相对简单，并且能够满足题目的要求。

当然，这个程序还有优化的空间。例如，可以使用动态规划的思想来避免重复计算，从而提高算法的效率。但是，根据题目的要求和输入数据的规模，这个简单的实现已经足够满足需求，并且易于理解和实现。

## 4.3一维数组->较难

### 数列2（求助网络）

问题描述 :

思维的严密性是相当重要的，尤其是在程序设计中，一个小小的错误，就可能导致无法想象的后果。明明的爸爸是一名富有经验的程序设计专家，深知思维严密的重要性，于是在明明很小的时候，就通过游戏的方式，训练明明的思维严密性。今天，明明的爸爸和明明做了一个数列的游戏。这个游戏很简单，就是有一数列，现在需要在这数列中选出一个或者若干个数（可以不连续），要求这些数的和能被11整除。明明的爸爸想锻炼明明思维的严密性，因此要求明明尽可能多的找出符合条件的数列来，最好一个也不要漏掉。 例如一数列为“11 22 33”，其中11可以被11整除，22可以被11整除，33可以被11整除，11+22=33能被11整除，22+33=55能被11整除，11+33=44能被11整除，11+22+33=66能被11整除。所以以上一数列能被11整除的情况一共有7种。 明明对于这个游戏很感兴趣，高兴地玩了起来。由于粗心，明明总是无法一次就把所有的情况都找出来，这使得他爸爸不是很满意。于是明明爸爸决定先降低游戏的难度，事先告诉明明某一数列总共有多少种符合条件的选择数字的方法，然后再让明明去选。明明的爸爸请你帮一个忙，他不想自己找出所有的情况，因此请你写一个程序，用程序来找出一共有多少种符合选数的情况，并把结果告诉他。 

明明爸爸的问题可以归结为：给你一个数列，从中选出1个或若干个数（可以不连续），要求这些数的和能被11整除，问这样的选数方法一共有多少种。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有两行，每组测试数据的第一行有一个整数n(1≤n≤15)，表示数列中有多少个整数，每组测试数据的第二行有n个整数，整数的大小都大于等于0且小于等于100，整数之间用一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表示一共有多少种选数方法。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
1
11
3
11 22 33
```

输出范例 :

```
1
7
```

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;
int main()
{
	int n;
	while (scanf("%d", &n) != EOF)
	{
		int m, sum = 0;
		vector<int> vi;
		vector<int> num;//开两个数组，一个存放输入的数，一个存放组合结果，不断扩展
		for (int i = 0; i < n; i++)
		{
			scanf("%d", &m);
			vi.push_back(m);
		}
		sort(vi.begin(), vi.end());
		int length = vi.size();
		num.push_back(*(vi.begin()));
		for (int i = 1; i < length; i++)
		{
			int len = num.size();
			num.push_back(vi[i]);
			for (int j = 0; j < len; j++)
			{
				num.push_back(num[j] + vi[i]);
			}
		}
		int count = 0;
		for (vector<int>::iterator it = num.begin(); it != num.end(); it++)
		{
			if (*it % 11 == 0)
			{
				count++;
			}
		}
		printf("%d\n", count);
	}
	return 0;
}
```

### 孪生素数

问题描述 :

孪生素数就是指相差2的素数对，例如3和5，5和7，11和13…。这个猜想正式由希尔伯特在1900年国际数学家大会的报告上第8个问题中提出，可以这样描述：存在无穷多个素数p，使得p + 2是素数。素数对（p, p + 2）称为孪生素数。

现在给定任何正整数 N (< 10 ^ 5), 请你计算不大于 N 的孪生素数的对数。

输入说明 :

你的程序必须从标准输入中读取测试用例。输入文件由几组测试用例组成。每组测试用例占一行, 其中包含一个整数 N。当输入的 N为负数表示结束输入。

输出说明 :

对于每组测试数据，输出一行，包括一个整数，表示不大于 N 的孪生素数的对数

输入范例 :

```
5
7
13
8 
15
-16
```

输出范例 :

```
1
2
3
2
3
```

```cpp
#include<iostream>
#include <cmath>
using namespace std;

bool IsPrime(int n)
{
    if(n<=1) return false;
    if(n==2) return true;
    if(n%2==0) return false;
    if(n>=3)
    {
        for(int i=3;i<=sqrt(n);i+=2)
        {
            if(n%i==0)
            {
                return false;
            }
        }
    }
    return true;
}

int main()
{
    int n;
    while(cin>>n&&n>0)
    {
        int count=0;
        for(int i=3;i<=n-2;i+=2)
        {
            if(IsPrime(i)&&IsPrime(i+2))
            {
                count++;
            }
        }
        cout<<count<<endl;
    }
}
```

### 骑士斗恶龙（求助网络）

问题描述 :

你的王国里有一条n个头的恶龙，你希望雇佣一些骑士把它杀死（也就是砍掉所有的头）。

村里有m个骑士可以雇佣，一个能力值为 x 的骑士可以砍掉恶龙一个直径不超过 x 的头，且需要报酬 x 个金币。

如何雇佣骑士才能砍掉恶龙所有的头，并且支付最小的金币？

注意，一个骑士只能砍一个头并且仅能被雇佣1次。

输入说明 :

输入包含多组测试数据。

每组测试数据的第一行输入两个整数n和m（m和n都在1到20000 之间）, n表示龙拥有的头的数目 , m表示王国中的骑士数。

接下来的 n 个整数为龙头的直径，再接下来m个整数为骑士的能力值。

输出说明 :

对于每组测试数据, 输出一行包含国王杀死龙需要支付的最低数量的金币。如果骑士不可能杀死龙, 输出一行：

“Lose!”（输出不包含引号）

输入范例 :

```
2 3
5
4
7
8
4
2 1
5
5
10
```

输出范例 :

```
11
Lose!
```

**就测试数据而言，一个头只能被一个骑士砍。**

贪心思想：两个数组升序排列，两个指针追逐，直到超过边界。如果头的指针不到边界，则失败。

```cpp
#include<iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    int n,m;
    while(cin>>n>>m)
    {
        vector<int> dragons;
        vector<int> knights;
        int cost=0;
        for(int i=0;i<n;i++)
        {
            int dragon;
            cin>>dragon;
            dragons.push_back(dragon);
        }
        for(int i=0;i<m;i++)
        {
            int knight;
            cin>>knight;
            knights.push_back(knight);
        }
        sort(dragons.begin(),dragons.end());
        sort(knights.begin(),knights.end());
        int sum=0,d_idx=0,k_idx=0;
        while(d_idx<n&&k_idx<m){
            if(dragons[d_idx]<=knights[k_idx]){
                sum+=knights[k_idx];
                d_idx++;
                k_idx++;
            }else{
                k_idx++;
            }
        }
        if(d_idx<n){
            cout<<"Lose!"<<endl;
        }else{
            cout<<sum<<endl;
        }

    }
}
```

### 寂寞的数

问题描述 :

对于任意正整数n，我们定义d(n)的值为为n加上组成n的各个数字的和。例如，d(23)=23+2+3=28, d(1481)=1481+1+4+8+1=1495。  

因此，给定了任意一个n作为起点，你可以构造如下一个递增序列：n,d(n),d(d(n)),d(d(d(n)))....例如，从33开始的递增序列为：33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...  

我们把n叫做d(n)的生成元，在上面的数列中，33是39的生成元，39是51的生成元，等等。有一些数字甚至可以有两个生成元，比如101，可以由91和100生成。但也有一些数字没有任何生成元，如42。我们把这样的数字称为寂寞的数字。

输入说明 :

一行，一个正整数n。

n<=10000

输出说明 :

按照升序输出小于n的所有寂寞的数字，每行一个。

输入范例 :40

输出范例 :

```
1
3
5
7
9
20
31
```

```cpp
#include<iostream>
#include <vector>
using namespace std;

int f(int n)
{
    int sum=n;
    if(n<10)
    {
        return 2*n;
    }
    else
    {
        while(n>=0)
        {
            sum+=n%10;
            if(n<10)
                break;
            n/=10;
        }
    }
    return sum;
}

int main()
{
    int n;
    cin>>n;
    bool IsRight=false;
    vector<int> nums;
    for(int i=1;i<n;i++)
    {
        nums.push_back(f(i));
    }
    for(int i=1;i<n;i++)
    {
        IsRight=false;
        for(int j=0;j<nums.size();j++)
        {
            if(i==nums[j])
            {
                IsRight=true;
                break;
            }
        }
        if(IsRight)
            continue;
        else
        {
            cout<<i<<endl;
            continue;
        }

    }
    return 0;
}
```

### 质数的乘积

问题描述 :

Torry从小喜爱数学。一天，老师告诉他，像2、3、5、7……这样的数叫做质数。Torry突然想到一个问题，前10、100、1000、10000……个质数的乘积是多少呢？他把这个问题告诉老师。老师愣住了，一时回答不出来。于是Torry求助于会编程的你，请你算出前n个质数的乘积。不过，考虑到你才接触编程不久，Torry只要你算出这个数模上50000的值。

输入说明 :

仅包含一个正整数n，其中n<=100000。

输出说明 :

输出一行，即前n个质数的乘积模50000的值。

输入范例 :3

输出范例 :30

```cpp
#include<iostream>
using namespace std;

bool IsPrime(int n)
{
    if(n<=1) return false;
    if(n==2) return true;
    if(n%2==0) return false;
    if(n>=3)
    {
        for(int i=3;i<=sqrt(n);i+=2)
        {
            if(n%i==0)
            {
                return false;
            }
        }
    }
    return true;
}

int main()
{
    unsigned long long int n,multi=1,count=0;
    cin>>n;
    for(unsigned long long int i=2;i<200000000;i++)
    {
        if(IsPrime(i))
        {
            count++;
            multi*=i;
            if(count==n)
                break;
        }
    }
    cout<<multi%50000<<endl;
    return 0;
}
```

测试数据失败如下：

```
1000
3074
//正确结果应该是1570
80000
19990
//正确结果应该是14630
```

就算我用上了unsigned long long int还是会溢出。

及时执行下面操作：multi%50000才能AC。

```cpp
#include<iostream>
using namespace std;

bool IsPrime(int n)
{
    if(n<=1) return false;
    if(n==2) return true;
    if(n%2==0) return false;
    if(n>=3)
    {
        for(int i=3;i<=sqrt(n);i+=2)
        {
            if(n%i==0)
            {
                return false;
            }
        }
    }
    return true;
}

int main()
{
    unsigned long long int n,multi=1,count=0;
    cin>>n;
    for(int i=2;count<n;i++)
    {
        if(IsPrime(i))
        {
            count++;
            multi*=i;
            multi%=50000;
        }
    }
    cout<<multi%50000<<endl;
    return 0;
}
```

### 分苹果（求助网络）

问题描述 :

小朋友排成一排，老师给他们分苹果。  

小朋友从左到右标号1..N。有M个老师，每次第i个老师会给第Li个到第Ri个，一共Ri-Li+1个小朋友每人发Ci个苹果。  

最后老师想知道每个小朋友有多少苹果。

输入说明 :

第一行两个整数N、M，表示小朋友个数和老师个数。  

接下来M行，每行三个整数Li、Ri、Ci，意义如题目表述。

N、M≤100 000，1≤Li≤Ri≤N，0≤Ci≤100。

输出说明 :

一行N个数，第i个数表示第i个小朋友手上的水果。

输入范例 :

```
5 3
1 2 1
2 3 2
2 5 3
```

输出范例 :

```
1 6 5 3 3 
```

我自己写的程序在输入`77951 80783...`报错超时TLE

```cpp
#include <iostream>
using namespace std;

int main() {
    int n,m;
    cin>>n>>m;
    int nums[n]={0};
    for(int i=1;i<=m;i++)
    {
        int li,ri,ci;
        cin>>li>>ri>>ci;
        for(int j=li;j<=ri;j++)
        {
            nums[j-1]+=ci;
        }
    }
    cout<<nums[0];
    for(int i=1;i<n;i++)
    {
        cout<<" "<<nums[i];
    }
    cout<<endl;
    return 0;
}
```

能AC的代码如下：

```cpp
#include <iostream>
using namespace std;
int nums[100005];
int main() {
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int li,ri,ci;
        cin>>li>>ri>>ci;
        nums[ri]+=ci;
        nums[li-1]-=ci;
    }
    for(int i=n-1;i>=1;i--)
        nums[i]+=nums[i+1];
    for(int i=1;i<=n;i++)
    {
        cout<<nums[i]<<" ";
    }
    return 0;
}
```

[# [蓝桥杯]分苹果（差分数组）](https://zhuanlan.zhihu.com/p/248338848)

分析：

最开始看到问题的时候下意识就是简单模拟，开一个数组用来统计每个小朋友收到的苹果数，读进来循环上限下限直接加上个数最后再输出即可。代码如下：

```cpp
#include<stdio.h>
#include<string>
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const int INF=0x3f3f3f3f, maxn=100005;

int main()
{
    int stu[maxn],n,m; 
    scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
    	stu[i]=0;
    int k=0;
    while(k<m)
    {
    	int a,b,c;
    	scanf("%d%d%d",&a,&b,&c);
    	for(int i=a;i<=b;i++)
    	    stu[i]+=c; 
    	k++;
    }
    for(int i=1;i<=n;i++)
        printf("%d ",stu[i]);
    printf("\n");
    return 0;
}  
```

结果就超时了，O(m\*n)确实比较复杂。看了一下题解基本使用树状数组来降低时间复杂度，但树状数组相对有些难理解。还看到一种很巧妙的做法，利用差分数组可以巧妙地降低时间复杂度，先上代码：

```cpp
#include<stdio.h>
#include<string>
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
const int INF=0x3f3f3f3f, maxn=100005;

int main()
{
    int stu[maxn],n,m; 
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n+1;i++)
    	stu[i]=0;
    int k=0;
    while(k<m)
    {
    	int a,b,c;
    	scanf("%d%d%d",&a,&b,&c);
    	stu[a]+=c;
    	stu[b+1]-=c;
    	k++;
    }
    for(int i=1;i<=n;i++)
    {
	stu[i]+=stu[i-1];
	printf("%d ",stu[i]);
    }
    printf("\n");
    return 0;
}
```

在第一种超时做法中，`stu[i]`用来记录第i个小朋友收到的苹果数，而在差分数组中stu[i]表示第i个小朋友比第i-1个小朋友多的苹果数。为了区分一下，我们用`apple[i]`来表示第i个小朋友收到的苹果数，那么差分数组中的`stu[i]=apple[i]-apple[i-1]`。

这样，在while循环段里，就有`stu[Li]=stu[Li]+c`也就是第i个老师发完苹果后，第Li个小朋友相比较第Li-1个小朋友在原基础上就多了c个苹果；同理右侧，`stu[Ri+1]=stu[Ri+1]-c`即第Ri+1个小朋友在第i个老师发完苹果后，就比第Ri个同学少了c个；而从Li-Ri中间的小朋友差值并没有变化。

那对于每一个差值而言，`stu[1]=apple[1]（数组从1开始，表示第一个小朋友）、stu[2]=apple[2]-apple[1]、stu[3]=apple[3]-apple[2]......利用裂项相消，apple[2]=stu[1]+stu[2]、apple[3]=stu[3]+stu[2]+stu[1]`......及每一个差值加上前一个差值就为当前这个小朋友所有的苹果数，故相加输出即为答案。

方法很巧妙，利用差值就将O(m\*n)降低为O(m)，没见过的话也不容易想到，向大佬们学习。

### 数的统计

问题描述 :

在一个有限的正整数序列中，有些数会多次重复出现在这个序列中。  

如序列：3，1，2，1，5，1，2。其中1就出现3次，2出现2次，3出现1 次，5出现1次。  

你的任务是对于给定的正整数序列，从小到大依次输出序列中出现的数及出现的次数。

输入说明 :

第一行正整数n，表示给定序列中正整数的个数。  

第二行是n 个用空格隔开的正整数x，代表给定的序列。

n<=1000；0<x<=1000,000。

输出说明 :

若干行，每行两个用一个空格隔开的数，第一个是数列中出现的数，第二个是该数在序列中出现的次数。

输入范例 :

```
12
8 2 8 2 2 11 1 1 8 1 13 13
```

输出范例 :

```
1 3
2 3
8 3
11 1
13 2
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n,num,max=0;
    cin>>n;
    vector<int> nums(n+1,0);
    for(int i=1;i<=n;i++)
    {
        cin>>num;
        if(num>max)
            max=num;
        nums[num]++;
    }
    for(int i=1;i<=max;i++)
    {
        if(nums[i]!=0)
            cout<<i<<" "<<nums[i]<<endl;
    }
    return 0;
}
```

### 错误票据

问题描述 :

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。

你的任务是通过编程，找出断号的ID和重号的ID。

假设断号不可能发生在最大和最小号。

输入说明 :

要求程序首先输入一个整数N(N<100)表示后面数据行数。

接着读入N行数据。

每行数据长度不等，是用空格分开的若干个（不大于100个）正整数（不大于100000），请注意行内和行末可能有多余的空格，你的程序需要能处理这些空格。

每个整数代表一个ID号。

输出说明 :

要求程序输出1行，含两个整数m n，用空格分隔。

其中，m表示断号ID，n表示重号ID

比如：  

输入

2  
5 6 8 11 9  
10 12 9

输出

7 9

输入范例 :

```
6
164 178 108 109 180 155 141 159 104 182 179 118 137 184 115 124 125 129 168 196
172 189 127 107 112 192 103 131 133 169 158
128 102 110 148 139 157 140 195 197
185 152 135 106 123 173 122 136 174 191 145 116 151 143 175 120 161 134 162 190
149 138 142 146 199 126 165 156 153 193 144 166 170 121 171 132 101 194 187 188
113 130 176 154 177 120 117 150 114 183 186 181 100 163 160 167 147 198 111 119
```

输出范例 :

```
105 120
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n,num,max=0,min=10000;
    cin>>n;
    vector<int> nums(100005,0);
    for(int i=1;i<=n;i++)
    {
        while(cin>>num)
        {
            if(num>max)
                max=num;
            if(num<min)
                min=num;
            nums[num]++;
        }

    }
    for(int i=min;i<=max;i++)
    {
        if(nums[i]==0)
            cout<<i<<" ";
    }
    for(int i=min;i<=max;i++)
    {
        if(nums[i]==2)
            cout<<i<<endl;
    }
    return 0;
}
```

### 最少拦截系统（求助网络）

问题描述 :

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能达到前一发的高度。

某天，雷达捕捉到敌国的导弹来袭，如果系统数量太少，将导致有可能不能拦截所有的导弹。所以，根据雷达捕捉到的导弹高度，需要预先准备相应数量的拦截系统。

比如导弹的高度依次为：

5 3 4 2 4 1

则一个拦截系统的第一发炮弹必须打到高度5的地方，第二发炮弹打到高度3的地方。

但第三发炮弹打不到高度4的地方（因为每一发炮弹不能达到前一发的高度），所以要使用第二套拦截系统。

第二套拦截系统发射的炮弹高度打到4和2的高度(实际上,要拦截高度为2的炮弹,使用第一套拦截系统或者第二套都可以)，

第三套拦截系统发射的炮弹高度打到4和1的高度(实际上,要拦截高度为1的炮弹,三套拦截系统都可以)。

因此，总共需要三套拦截系统。

再比如导弹的高度依次为：

5 3 4 2 3 1

则一个拦截系统的第一发炮弹必须打到高度5的地方，第二发炮弹打到高度3的地方。

但第三发炮弹打不到高度4的地方（因为每一发炮弹不能达到前一发的高度），所以要使用第二套拦截系统。

第二套拦截系统发射的炮弹高度打到4的高度。

再要拦截高度为2的炮弹,使用第一套拦截系统或者第二套都可以，但考虑到后面还需要拦截炮弹，我们这里使用第一套拦截系统（为什么不能用第二套，自己想啦）。

再要拦截高度为3的炮弹,我们使用第二套拦截系统。

再拦截高度为1的炮弹，第一套和第二套系统都可以，我们就使用第二套吧。

因此，总共仅需要两套拦截系统，第一套拦截的是5 3 2，第二套拦截的是4 3 1。

请根据给定的高度数据，帮助计算一下最少需要多少套拦截系统。

输入说明 :

输入数据首先包括一个整数T (1<=T<= 100)，,表示测试数据的组数。

每组测试数据的第一行是一个整数N(1<= N <= 1000)，代表着导弹总个数(正整数), 接下来用N个数字代表着导弹依次飞来的高度，其中雷达给出的高度数据是不大于10000的正整数，用空格分隔。

输出说明 :

对应每组数据输出拦截所有导弹最少要配备多少套这种导弹拦截系统。

每组输出占一行，行首与行尾无空格。

输入范例 :

```
2
8 
389 207 155 300 299 170 158 65
5
100 50 200 300 400
```

输出范例 :

```
2
4
```

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int T;
    cin>>T;
    for(int i=0;i<T;i++)
    {
        int n,num,min[100],minimum,count=0;
        cin>>n;
        cin>>minimum;
        min[count]=minimum;
        count++;
        for(int i=1;i<n;i++)
        {
            cin>>num;
            if(num<minimum)
            {
                minimum=num;
                min[count]=num;
            }
            else
            {
                min[count++]=num;
                minimum=num;
            }

        }
        cout<<count<<endl;
    }

    return 0;
}
```

TLE：程序运行超时。可能的原因：1、程序中存在死循环 2、算法需要改进
具体信息如下:

测试用例ID为2575,运行超时

```cpp
#include <iostream>
#include<cstdio>
using namespace std;
int main()
{
    int T,n,i,j,num,h[1000],max[1000];
    cin>>T;
    while(T--)
    {
        num=0;
        cin>>n;
        num=0;
        for(i=0;i<n;++i)
        {
            scanf("%d",&h[i]);
            max[i]=1;
        }
        for(i=1;i<n;++i)
            for(j=0;j<i;++j)
            {
                if(h[j]<=h[i]&&max[j]+1>max[i])
                    max[i]=max[j]+1;
                if(num<max[i])
                    num=max[i];
            }
        printf("%d\n",num);
    }
    return 0;
}
```

解题思路：

应该求最长不降子序列。这样的长度才是 最少需要的套数，因为这个序列中的任何两个导弹都不能共用一个拦截系统 ，而且其余的导弹都能和这个最长序列中的某个导弹分为同一组。







