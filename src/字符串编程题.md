# 字符串编程题

<!-- toc -->

## 7.1字符串->简单

### 加密

问题描述 :

编写一个加密程序，用来加密一个字符串。加密规则如下：

1. 把字符串中的所有数字0、1 … 9分别换成小写英文字母a、b … j。
    
2. 把字符串中的所有小写英文字母a、b … j分别换成数字0、1 … 9。
    
3. 其它字符保持不变。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据占一行，其中只包含一个字符串，即需要被加密的字符串。该字符串包含不超过100个字符，只包含可见的ASCII字符，并且不包含空格、制表符或换行符。在行首和行尾没有多余的空格；所有数据前后没有多余的空行；两组数据之间没有多余的空行。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出一组对应的答案。每组答案占一行，其中只包含一个字符串，即问题描述中的加密结果。在行首和行尾不要输出多余的空格；在所有数据前后不要输出多余的空行；在两组数据之间不要输出多余的空行。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        for(int i=0;i<s.length();i++)
            {
                if((s[i]<='9')&&(s[i]>='0'))
                {
                    cout<<(char)(s[i]+49);
                }
                else if((s[i]>='a')&&(s[i]<='j'))
                {
                    cout<<(char)(s[i]-49);
                }
                else
                    cout<<s[i];
            }
            cout<<endl;
    }
}
```

### 字符串排序（调教GPT）

输入范例 :

```
asdf
shflsahfslfdjsldfsjd
```

输出范例 :

```
adfs
adddffffhhjjlllsssss
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        sort(s.begin(),s.end());
        cout<<s<<endl;
    }
    return 0;
}
```

以下是根据您提供的要求完成的C++程序：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    string input;
    while (getline(cin, input)) {
        sort(input.begin(), input.end());
        cout << input << endl;
    }
    return 0;
}
```

这个程序通过使用`getline()`函数来读取输入的多组测试数据，每次读取一行字符串并存储在`input`变量中。然后，使用`sort()`函数对字符串进行排序，最后将排序后的字符串输出到标准输出流中。

请注意，该程序假设每行输入的字符串都在合理的范围内，并且每组测试数据都以换行符结束。

如果您不想使用`sort()`函数进行字符串排序，可以使用其他方法来实现。以下是一个不使用`sort()`函数的示例程序：

```cpp
#include <iostream>
#include <string>
using namespace std;

string sortString(string input) {
    for (int i = 0; i < input.length() - 1; i++) {
        for (int j = i + 1; j < input.length(); j++) {
            if (input[i] > input[j]) {
                char temp = input[i];
                input[i] = input[j];
                input[j] = temp;
            }
        }
    }
    return input;
}

int main() {
    string input;
    while (getline(cin, input)) {
        string sortedString = sortString(input);
        cout << sortedString << endl;
    }
    return 0;
}
```

在这个程序中，我们定义了一个名为`sortString`的函数，该函数接受一个字符串作为参数，并使用冒泡排序算法对字符串进行排序。然后，在`main()`函数中，我们循环读取输入的多组测试数据，并将每行字符串传递给`sortString`函数进行排序，最后将排序后的字符串输出到标准输出流中。

请注意，这种方法并不高效，因为冒泡排序的时间复杂度为O(n^2)，而`sort()`函数使用的是更高效的排序算法。然而，如果您有特定要求不允许使用`sort()`函数，这个示例程序可以实现字符串排序的功能。

### 手机短号

问题描述 :

大家都知道，手机号是一个11位长的数字串，同时，作为学生，还可以申请加入校园网，如果加入成功，你将另外拥有一个短号。假设所有的短号都是“6”+手机号的后5位，比如号码为13512345678的手机，对应的短号就是645678。

现在，如果给你一个11位长的手机号码，你能找出对应的短号吗？

输入说明 :

输入数据的第一行是一个N(N <= 1000)，表示有N个数据，接下来的N行每一行为一个11位的手机号码。

输出说明 :

输出应包括N行，每行包括一个对应的短号，输出应与输入的顺序一致。

输入范例 :

```
2
70711457490
47810534444
```

输出范例：

```
657490
634444
```

二维字符数组实现

```cpp
#include <iostream>
using namespace std;

int main() {
    int N;
    cin>>N;
    char number[N][12];
    for(int i=0;i<N;i++)
        {
            for(int j=0;j<11;j++)
                {
                    cin>>number[i][j];
                }
        }

    for(int i=0;i<N;i++)
    {
        cout<<6;
        for(int j=6;j<11;j++)
            cout<<number[i][j];
        cout<<endl;
    }
    return 0;
}
```

一维字符串实现

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int N;
    cin>>N;
    string s[N];
    for(int i=0;i<N;i++)
        cin>>s[i];

    for(int i=0;i<N;i++)
    {
        cout<<6;
        for(int j=6;j<11;j++)
            cout<<s[i][j];
        cout<<endl;
    }
    return 0;
}
```

### 求绝对值（求助GPT）

问题描述 :

给你一个大整数（绝对值不超过1,000位数），请求出这个数字的绝对值。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据占一行，其中仅有一个整数N；N的绝对值不会超过1,000位数；输入的数据没有前导零；如果N是负数，则在负号和最左边一位数字之间不会有空格。每行的行首和行尾都没有多余的空格。在所有数据的前后，以及两组数据之间都没有多余的空行。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。每组答案占一行，其中仅有一个整数，即N的绝对值。在行首和行尾不要输出多余的空格。在所有数据的前后，以及两组数据之间不要输出多余的空行。

自己写的这个有溢出问题，只在部分数据上是AC。

```cpp
#include <iostream>
#include <sstream>
#include <cmath>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        stringstream geek(s);
        int x=0;
        geek>>x;

        cout<<abs(x)<<endl;
    }
    return 0;
}
```

```cpp
#include <iostream>
#include <sstream>
#include <cmath>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        cout<<abs(stoi(s))<<endl;
    }
    return 0;
}
```

根据题目的要求，我们可以用C++的`std::string`类来处理大数字。读取输入时，我们将数字当作字符串读取；然后，通过检查第一个字符是否为负号（'-'）来决定是否需要去掉它，从而得到绝对值。以下是一个可能的实现：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string num;
    while (std::cin >> num) {
        // 如果数字是负数，去掉负号
        if (num[0] == '-')
            num = num.substr(1);
        std::cout << num << std::endl;
    }
    return 0;
}
```

这个程序会继续读取输入，直到没有更多的数据可以读取（例如，如果你在终端里运行它，你可以通过按Ctrl+D来表示输入结束）。

注意，这个程序并没有处理可能的输入错误，例如如果输入的字符串中包含非数字字符。根据题目的描述，我们假定所有的输入都是有效的。

### 字符串统计

问题描述 :

对于给定的一个字符串，统计其中小写字母出现的次数。

输入说明 :

输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。

输出说明 :

对于每个测试实例，输出该串中数值的个数，每个输出占一行。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s;
    int N;
    cin>>N;
    while(N--)
    {
        cin>>s;
        int num=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]<='z'&&s[i]>='a')
                num++;
        }
        cout<<num<<endl;
    }
    return 0;
}
```

### 模拟登录

问题描述 :

编写程序模拟简单的密码登录（正确的密码是123456），首先从键盘输入用户名（用户名随意，不超过10个字符）

然后输入密码，若密码正确（即为123456）则给出问候语。

若密码不正确，则给出错误提示，并允许再次输入，

直到输入正确的密码或输入0结束。

输入说明 :

用户名，和若干次密码。

输出说明 :

若密码正确则输出:

Hello 用户名换行

并退出

若错误则输出:

Wrong Password!换行

并再次输入判断

若密码为0则在输出Wrong Password!后退出。

输入范例 :

```
tom
123
123456
```

输出范例 :

```
Wrong Password!
Hello tom
```

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string admin;
    cin>>admin;

    int password;

    while(cin>>password)
    {
        if(password!=123456&&password!=0)
            {
                cout<<"Wrong Password!"<<endl;
                continue;
            }
        else if(password!=123456&&password==0)
            {
                cout<<"Wrong Password!"<<endl;
                break;
            }
        else
            {
                cout<<"Hello"<<" "<<admin<<endl;
                break;
            }
    }

    return 0;
}
```

### 日期（调教GPT）

问题描述 :

输入星期日到星期六的英文缩写（Sun,Mon,Tue,Wed,Thu,Fri,Sat），输出其对应的完整单词。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每行输入相关单词，在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出从标准输入设备中读入的每一组测试数据对应的结果。所有数据前后没有多余的空行，两组数据之间也没有多余的空行。每组输出数据由一行组成，该行为该英文单词的全称。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s,s1,s2,s3,s4,s5,s6,s7;
    s1="Mon";
    s2="Tue";
    s3="Wed";
    s4="Thu";
    s5="Fri";
    s6="Sat";
    s7="Sun";

    while(cin>>s)
    {
        if(s.compare(s1)==0)
            {
                cout<<"Monday"<<endl;
                continue;
            }
        else if(s.compare(s2)==0)
            {
                cout<<"Tuesday"<<endl;
                continue;
            }
        else if(s.compare(s3)==0)
            {
                cout<<"Wednesday"<<endl;
                continue;
            }
        else if(s.compare(s4)==0)
            {
                cout<<"Thursday"<<endl;
                continue;
            }
        else if(s.compare(s5)==0)
            {
                cout<<"Friday"<<endl;
                continue;
            }
        else if(s.compare(s6)==0)
            {
                cout<<"Saturday"<<endl;
                continue;
            }
        else
            {
                cout<<"Sunday"<<endl;
                continue;
            }

    }

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

std::string getFullDay(const std::string& abbreviation) {
    if (abbreviation == "Sun") {
        return "Sunday";
    } else if (abbreviation == "Mon") {
        return "Monday";
    } else if (abbreviation == "Tue") {
        return "Tuesday";
    } else if (abbreviation == "Wed") {
        return "Wednesday";
    } else if (abbreviation == "Thu") {
        return "Thursday";
    } else if (abbreviation == "Fri") {
        return "Friday";
    } else if (abbreviation == "Sat") {
        return "Saturday";
    } else {
        return "Invalid abbreviation";
    }
}

int main() {
    std::string abbreviation;

    while (std::getline(std::cin, abbreviation)) {
        std::string fullDay = getFullDay(abbreviation);
        std::cout << fullDay << std::endl;
    }

    return 0;
}
```

在这个程序中，我们首先定义了一个`getFullDay`函数，用于根据输入的英文缩写返回完整的星期几的单词。在`getFullDay`函数中，我们使用`if-else`语句判断输入的缩写是哪一天，并返回对应的完整单词。

在`main`函数中，我们使用`std::getline`函数循环读取输入的每一行数据，将输入的缩写作为参数调用`getFullDay`函数得到完整单词，然后将其输出到标准输出设备。

请注意，根据您的问题描述，程序假设每组测试数据都在一行中，并且每组数据之间没有多余的空行。如果输入的缩写不在星期日到星期六的范围内，程序将输出"Invalid abbreviation"。

您可以根据需要自行扩展或修改`getFullDay`函数，以适应其他缩写或完整单词的映射关系。
### 删除字符（调教GPT）

问题描述 :

从键盘输入一个字符串和一个字符，将输入字符从字符串中删除，输出新的字符串。如果字符串中没有此字符，则原样输出字符串。

输入说明 :

输入两行，第一行输入一个字符串，第二行输入一个字符。

字符串最多允许输入20个任意字符。

输出说明 :

输出删除字符后的字符串。

输入范例 :

```
ab  ccdc
c
```

输出范例 :

```
ab  d
```

自己写的程序存在PE错误

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{
    string s;
    getline(cin,s);
    char ch;
    cin>>ch;

    s.erase(remove(s.begin(),s.end(),ch),s.end());
    cout<<s<<endl;

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    char ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::cin >> ch;

    // 删除字符
    std::string result;
    for (char c : str) {
        if (c != ch) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在这个程序中，我们使用了`std::string`来存储输入的字符串和输出的结果。首先，我们使用`std::getline`函数来读取一行输入字符串，然后使用`std::cin`来读取一个字符。接下来，我们使用一个循环遍历输入的字符串，如果当前字符不等于要删除的字符，就将它添加到结果字符串中。最后，我们输出结果字符串。

请注意，根据您的问题描述，删除字符是区分大小写的。如果您希望删除字符时不区分大小写，可以使用`std::tolower`函数或`std::toupper`函数将字符转换为统一的大小写后进行比较。

抱歉，我之前提供的程序确实没有正确处理空格、换行和制表符等特殊字符。为了解决这个问题，我们可以使用`std::getline`函数读取输入字符串，并使用`std::getline`函数的第三个参数指定定界符为空格字符。

以下是更新后的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    char ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::cin >> ch;
    std::cin.ignore(); // 忽略换行符

    // 删除字符
    std::string result;
    for (char c : str) {
        if (c != ch) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在更新后的程序中，我们使用了`std::getline`函数来读取输入的字符串，同时将空格字符作为定界符，这样可以正确读取包含空格的字符串。然后，我们使用`std::cin.ignore()`来忽略输入中的换行符，以确保后续的字符输入不受影响。

现在，程序应该能够正确处理空格、换行和制表符等特殊字符。请再次尝试并检查结果是否正确。

非常抱歉出现了这个问题。我注意到在之前的程序中，我们使用了`std::cin`来读取输入的字符。然而，`std::cin`在读取字符时会忽略空格、换行和制表符等空白字符。为了解决这个问题，我们可以改用`std::getline`函数来读取输入的字符，将空格字符作为定界符。

以下是更新后的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    std::string ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::getline(std::cin, ch);

    // 删除字符
    std::string result;
    for (char c : str) {
        if (ch.find(c) == std::string::npos) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在这个更新后的程序中，我们使用`std::getline`函数来读取输入的字符串和字符。我们将输入的字符存储在`std::string`类型的变量`ch`中。然后，我们使用`std::string`的`find`函数来判断字符串中是否包含要删除的字符。如果字符不在字符串中，我们将其添加到结果字符串中。

请再次尝试并检查程序是否能够正确处理空格、换行和制表符等特殊字符。如果问题仍然存在，请提供更多的详细信息，我将尽力帮助您解决问题。

### 倒序（调教GPT）

问题描述 :

编写程序，把一串字符以倒序的方式输出。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。第一行输入字符串的个数n。之后就有n组输入数据，每组输入为一行字符串，该串由ASCII字符的任意组合构成，它们之间可能有一个或多个空格，在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出从标准输入设备中读入的每一组测试数据对应的结果，使其成为输入串的倒序。所有数据前后没有多余的空格，两组数据之间也没有多余的空行。

输入范例：

```
2
abcd-ef
I love ACM!
```

输出范例：

```
fe-dcba
!MCA evol I
```

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    int N;
    cin>>N;
    cin.get();
    string s;
    while(N--)
    {
        getline(cin,s);
        string result;
        for(int i=s.length();i>=0;i--)
        {
            result += s[i];
        }
        if (result[0] == '\0')
            result = result.substr(1);
        cout<<result<<endl;
    }

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    int n;
    std::cin >> n;
    std::cin.ignore(); // 忽略换行符

    for (int i = 0; i < n; i++) {
        std::string str;
        std::getline(std::cin, str);

        // 倒序输出字符串
        for (int j = str.length() - 1; j >= 0; j--) {
            std::cout << str[j];
        }
        std::cout << std::endl;
    }

    return 0;
}
```

在这个程序中，我们首先读取一个整数`n`，表示要输入的字符串个数。然后使用`std::cin.ignore()`来忽略输入中的换行符。

接下来，我们使用一个循环来读取每组测试数据。对于每组数据，我们使用`std::getline`函数来读取输入的字符串。然后，我们使用一个循环从字符串的最后一个字符开始，倒序输出每个字符。

最后，我们在每组数据输出完成后输出一个换行符。

请注意，根据您的问题描述，程序假设输入的每组数据都在一行中，并且每组数据之间没有多余的空行。

## 7.2字符串->中等

### 加法器（求助GPT）

问题描述 :

明明读小学的时候，不喜欢数学，尤其是不喜欢做加法，一做加法就头疼，这样导致明明长大后数学依然不好，而且对数字产生了抵触心理。可是不巧的是，明明进了一家会计公司，每天都要计算很多数据，在这些计算中加法运算居多，而且这些加法不只是是两个数之间的加法，更有多个数的连加。 例如：1+2+3的正确答案是6。 这给明明造成了很大的麻烦。你是明明的好朋友，看到明明如此痛苦，就产生了帮助明明的想法。你想帮明明写一个程序，这个程序能计算一串正整数的连加，从而帮助明明摆脱数字的困扰。 明明的问题可以归结为：给你一串正整数的连加表达式，完成这个表达式的计算。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅有一行，每行有一个表达式，表达式由正整数和加号（“+”）组成，不含其他任何符号，表达式中的数字小于等于30000,表达式的长度不超过1000，具体格式见输入样例。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表达式的值。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
1+2+3
5+111
```

输出范例 :

```
6
116
```

```cpp
#include <iostream>
#include <sstream>

using namespace std;

int calculateSum(const string& expression) {
    stringstream ss(expression);
    int sum = 0;
    int num;
    char op;

    // 从流中读取数字和操作符，并进行计算
    ss >> num;
    sum = num;
    while (ss >> op >> num) {
        if (op == '+')
            sum += num;
    }

    return sum;
}

int main() {
    string expression;
    while (getline(cin, expression)) {
        int sum = calculateSum(expression);
        cout << sum << endl;
    }

    return 0;
}

```

### 翻译字符串

问题描述 :

在现代战争中，情报战越来越显示出它的重要性，敌我双方都想方设法得到对方的情报，然后一举歼灭对方。然而，随着加密技术的出现，对情报进行加密变得越来越频繁，想破解敌方的情报也越来越难。明明是一名富有经验的情报工作人员，他的主要任务就是破解敌方的情报，从而得到对己方有利的信息。在一次破解情报任务中，明明再次成功地破解了敌方的情报。明明的破解方法如下：一串以‘@’为结束标志的字符串，从左至右对其进行翻译，若字符串中当前字符是整数n（0≤n≤9），则表示将后一个字符重复n+1次，不论后一个字符是否为数字，且后一个字符无需再次翻译；若当前字符非数字，则表示自己，无需翻译，直接输出即可。最后，输出翻译完的字符串。

例如字符串为：2d352d@，因为第一个字符为数字2，则将后一个字符d输出3次，而d则不需再翻译，然后翻译3，3也是一个数字，则将后一个字符5输出4次，而5则不需再翻译，然后翻译2，2也是一个数字，将后一个字符d输出3次，而d则不需再翻译，最后一个字符为@，表示自己，直接输出即可，最后的输出为：ddd 555 5dd d@；（注：在翻译时，‘@’)当作字符处理。） 这样翻译字符串的方法虽然简单，但是由于敌方的文件巨大，仅仅靠手工翻译是很难在短时间内完成的。于是明明就求助于你这位程序专家，按照明明提供的破译方法写一个程序，帮助明明快速把敌方文件翻译完成。

明明的问题可以归结为：按照文中提供的破译情报的方法，对字符串进行翻译，然后输出翻译后的字符串。

输入说明 :

你写的程序要求从标准输入设备（通常，键盘为标准输入设备）中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行包含一个以‘@’为结束标志的字符串，字符串由数字、小写字母以及‘@’组成，中间不包含空格，字符串长度不大于10。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备（通常，显示屏为标准输出设备）中。每组运算结果为经过翻译的字符串，字符串中的字符以三个为一组输出，每组字符之间用一个空格隔开。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。

输入范例 :

```
a1b2c3d4@ 
2d352d@ 
dsegweg@
```

输出范例 :

```
abb ccc ddd d@@ @@@
ddd 555 5dd d@
dse gwe g@
```

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    string expression;
    vector<char> result;
    while (getline(cin, expression)) {

            for(int i=0;i<expression.length();i++)
            {

                if(expression[i]<='z'&&expression[i]>='a')
                    result.push_back(expression[i]);
                if(expression[i]<='9'&&expression[i]>='0')
                {
                    for(int j=0;j<=expression[i]-'0';j++)
                        result.push_back(expression[i+1]);
                    i++;
                }
                if((expression[i-1]<='z'&&expression[i-1]>='a'&&expression[i]=='@')||expression[0]=='@')
                {
                    result.push_back(expression[i]);
                }

            }

            for(int i=0;i<result.size()-1;i++)
            {
                cout<<result[i];
                if((i+1)%3==0) cout<<" ";
            }
            cout<<result[result.size()-1]<<endl;
            result.clear();
    }

    return 0;
}
```

根据题目要求，我们需要编写一个程序来实现字符串的翻译。下面是相应的C++程序：

```cpp
#include <iostream>
#include <string>

using namespace std;

string translateString(const string& str) {
    string translatedStr;
    int len = str.length();
    int i = 0;

    while (i < len) {
        if (isdigit(str[i])) {
            int count = str[i] - '0';  // 计算重复次数
            char ch = str[i + 1];      // 获取下一个字符
            translatedStr.append(count, ch);
            i += 2;
        } else if (str[i] == '@') {
            translatedStr.push_back('@');
            i++;
        } else {
            translatedStr.push_back(str[i]);
            i++;
        }
    }

    return translatedStr;
}

int main() {
    string str;
    while (getline(cin, str, '@')) {
        string translatedStr = translateString(str);
        int len = translatedStr.length();
        for (int i = 0; i < len; i += 3) {
            cout << translatedStr.substr(i, 3) << ' ';
        }
        cout << endl;
    }

    return 0;
}
```

在上述程序中，我们定义了一个`translateString`函数，用于实现字符串的翻译。函数遍历输入字符串，根据题目提供的翻译规则进行处理，将翻译后的字符追加到`translatedStr`字符串中。

在`main`函数中，我们使用`getline`函数从标准输入读取以`@`为结束标志的字符串。然后，我们调用`translateString`函数对字符串进行翻译，并将结果输出到标准输出。为了满足输出格式要求，我们将每三个字符以一组输出，并在每组字符之间添加一个空格。

请尝试运行程序，并输入相应的字符串进行测试。程序将对字符串进行翻译并输出结果。

ChatGPT给出的程序是错误的，不过所用代码给了我不少启发，改写后的能AC的程序如下：

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string expression;
    string result;
    while (getline(cin, expression)) {

            for(int i=0;i<expression.length();i++)
            {

                if(expression[i]<='z'&&expression[i]>='a')
                    result.push_back(expression[i]);
                if(isdigit(expression[i]))
                {
                    int count=expression[i]-'0';
                    char ch=expression[i+1];
                    result.append(count+1,ch);
                    i++;
                }
                if((expression[i-1]<='z'&&expression[i-1]>='a'&&expression[i]=='@')||expression[0]=='@')
                {
                    result.push_back(expression[i]);
                }

            }
            int len=result.length();
            for(int i=0;i<len-1;i++)
            {
                cout<<result[i];
                if((i+1)%3==0) cout<<" ";
            }
            cout<<result[len-1]<<endl;
            result.clear();
    }

    return 0;
}
```

### 求字符串的起始位置

问题描述 :

在程序设计中，对字符串的处理是经常遇到的一个问题。

例如，将字符串中所有的英文字母变成大写，或者将一个字符串与另一个字符串连接构成一个新的字符串。

由于此类的操作非常普遍，因此，在设计程序语言的时候，设计者就已经把这类操作的代码写好了，如果编程人员要使用这些代码，只需把该类代码的头文件包含到自己的程序中，编程人员就可以很简单的调用，这样使编程节省了不少时间。

明明是一名项目经理，他现在负责一种新的程序设计语言的开发，现在需要预先实现大量的和处理字符串有关的功能方法，以后这些方法会包含到程序设计语言中，方便程序语言使用者的开发。你是明明手下的一名软件工程师，明明分配给你一个任务，在两个字符串中，找到一个字符串在另一个字符串中的起始位置。 例如，有两个字符串，一个字符串s= “abc”，另一个字符串subs=“bc”，现在就要找出“bc”在“abc”中的其实位置，在这个例子中，“bc”的起始位置为2。

明明的问题可以归结为：输入两串字符串s和subs，求s中subs的起始位置。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据两行，每组测试数据的第一行为字符串s，s的长度小于100，每组测试数据的第二行为字符串subs，subs的长度小于100，s和subs中仅包含小写字母和数字。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数m，即subs在s中的起始位置，如果在s中找不到subs这个子串，则m=0。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
abc 
bc 
aaa 
bbb
```

输出范例 :

```
2
0
```

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string s,subs;
    while(cin>>s>>subs)
    {
        if(s.find(subs)!=s.npos)
            cout<<s.find(subs)+1<<endl;
        else
            cout<<0<<endl;
    }
}
```

### 字符串统计（附GPT4实现）

问题描述 :

明明最近在做一个有关字符串的统计工作。两个由小写字母组成的字符串s1和s2，明明需要统计出以下四种关系：   

（1）在s1或s2中存在的字母（包括在s1和s2中都存在的字母）；   

（2）在s1中且在s2中的字母；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母；   

（4）不在s1中且也不在s2中的字母；   

例如两个字符串s1为“lkjsvoahs”，s2为“qglhskjdfg”：   

（1）在s1或者在s2或者s1、s2中都存在的字母：adfghjkloqsv；   

（2）在s1中且在s2中的字母：hjkls；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母：adfgoqv；   

（4）不在s1中且也不在s2中的字母：bceimnprtuwxyz；   

明明统计了很久，但是由于统计过程十分繁琐，且很容易出错，导致明明的进度非常慢，很有可能因为统计不完而错过了晚上的约会。因此明明想请你帮个忙，帮他写一个程序，用程序来统计出以上几项内容。   

明明的问题可以归结为：  

输入两串由小写字母组成的字符串s1和s2，比较其中的字母，输出以下四项，输出的字母以字典顺序排列：   

（1）在s1或s2中存在的字母（包括在s1和s2中都存在的字母）；   

（2）在s1中且在s2中的字母；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母；   

（4）不在s1中且也不在s2中的字母；   

例如字符串s1为sadf，s2为asdf，则需输出以下四行（注意输出的格式）：  

in s1 or s2:adfs   

in s1 and s2:adfs   

in s1 but not in s2 ,or in s2 but not in s1:   

not in s1 and s2:bceghijklmnopqrtuvwxyz

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据两行，每组测试数据的第一行为字符串s1，每组测试数据的第二行为字符串s2；s1和s2都由小写英文字母组成，且长度不超过26个字符。测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。

每组运算结果由四行组成： 

第一行为在s1或者在s2或者s1、s2中都存在的字母； 

第二行为在s1中且在s2中的字母； 

第三行为在s1中但不在s2中的字母，在s2中但不在s1中的字母； 

第四行为不在s1中且也不在s2中的字母； 

具体格式请参考样例输出。 

每组运算结果其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。 

注：通常，显示屏为标准输出设备。

输入范例 :

```
sadf 
asdf 
lkjsvoahs 
qglhskjdfg
```

输出范例 :

```
in s1 or s2:adfs
in s1 and s2:adfs
in s1 but not in s2 ,or in s2 but not in s1:
not in s1 and s2:bceghijklmnopqrtuvwxyz

in s1 or s2:adfghjkloqsv
in s1 and s2:hjkls
in s1 but not in s2 ,or in s2 but not in s1:adfgoqv
not in s1 and s2:bceimnprtuwxyz
```

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

void sort_string(string s )
{
    int len=s.length();
    char schar[len+1];
    strcpy(schar,s.c_str());
    char temp;
    for(int i=0;i<len-1;i++)
    {
        for(int j=i;j<len;j++)
        {
            if(schar[i]>schar[j])
            {
                temp=schar[i];
                schar[i]=schar[j];
                schar[j]=temp;
            }
        }
    }
    cout<<schar<<endl;

}

int main()
{
    string s1,s2,s3="abcdefghijklmnopqrstuvwxyz";
    bool firstline=true;
    while(cin>>s1>>s2)
    {
        string ins1ands2,notins1s2,ins1ors2,ins1butnotins2orins2butnotins1;
        if(!firstline)
            cout<<endl;
        firstline=false;
        for(int i=0;i<s1.length();i++)
        {
            for(int j=0;j<s2.length();j++)
            {
                if(s1[i]==s2[j]&&ins1ands2.find(s1[i])==ins1ands2.npos)
                    ins1ands2.push_back(s1[i]);
            }
        }

        for(int j=0;j<s1.length();j++)
        {
            if(ins1ands2.find(s1[j])==ins1ands2.npos&&ins1butnotins2orins2butnotins1.find(s1[j])==ins1butnotins2orins2butnotins1.npos)
                ins1butnotins2orins2butnotins1.push_back(s1[j]);
        }
        for(int j=0;j<s2.length();j++)
        {
            if(ins1ands2.find(s2[j])==ins1ands2.npos&&ins1butnotins2orins2butnotins1.find(s2[j])==ins1butnotins2orins2butnotins1.npos)
                ins1butnotins2orins2butnotins1.push_back(s2[j]);
        }
        for(int j=0;j<ins1ands2.length();j++)
        {
            ins1ors2.push_back(ins1ands2[j]);
        }
        for(int j=0;j<ins1butnotins2orins2butnotins1.length();j++)
        {
            ins1ors2.push_back(ins1butnotins2orins2butnotins1[j]);
        }
        for(int j=0;j<s3.length();j++)
        {
            if(ins1ors2.find(s3[j])==ins1ors2.npos)
                notins1s2.push_back(s3[j]);
        }

        cout<<"in s1 or s2:";sort_string(ins1ors2);

        cout<<"in s1 and s2:";sort_string(ins1ands2);

        cout<<"in s1 but not in s2 ,or in s2 but not in s1:";sort_string(ins1butnotins2orins2butnotins1);

        cout<<"not in s1 and s2:";sort_string(notins1s2);

    }
}
```

这个问题可以通过使用set数据结构在C++中解决。set数据结构可以自动排序并且不会有重复元素。这是一个示例解决方案：

```cpp
#include <iostream>
#include <set>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
    string s1, s2;
    bool isFirst = true; // 用于判断是否为第一次输入
    
    //while(getline(cin, s1) && getline(cin, s2))
    while(cin>>s1&&cin>>s2)
    {
        if(isFirst)
            isFirst = false; // 第一次输入后设置为false
        else
            cout << endl; // 在每组输入之间添加一个空行

        set<char> set1(s1.begin(), s1.end());
        set<char> set2(s2.begin(), s2.end());
        set<char> setOr, setAnd, setDiff, setNone;

        // 在s1或s2中存在的字母
        set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setOr, setOr.begin()));

        // 在s1中且在s2中的字母
        set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setAnd, setAnd.begin()));

        // 在s1中但不在s2中的字母，在s2中但不在s1中的字母
        set_symmetric_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setDiff, setDiff.begin()));

        // 不在s1中且也不在s2中的字母
        for(char ch = 'a'; ch <= 'z'; ++ch)
        {
            if(setOr.count(ch) == 0)
            {
                setNone.insert(ch);
            }
        }

        cout << "in s1 or s2:";
        for (char ch : setOr)
            cout << ch;
        cout << endl;

        cout << "in s1 and s2:";
        for (char ch : setAnd)
            cout << ch;
        cout << endl;

        cout << "in s1 but not in s2 ,or in s2 but not in s1:";
        for (char ch : setDiff)
            cout << ch;
        cout << endl;

        cout << "not in s1 and s2:";
        for (char ch : setNone)
            cout << ch;
    }

    return 0;
}
```

这个程序首先读取两个输入字符串s1和s2，然后创建两个set，分别用于存储s1和s2的字符。然后，程序使用set的操作函数（如`set_union`，`set_intersection`，`set_symmetric_difference`）来计算并打印所需的输出。

错误提示指出`set_union`未在当前作用域中声明，这是因为你没有包含所需的头文件。`set_union`函数位于`algorithm`头文件中，因此你需要在代码中包含该头文件。

请将以下行添加到你的代码中，以包含`algorithm`头文件：

```cpp
#include <algorithm>
```

### 十进制转换成其它进制（求助GPT）

问题描述 :

编写一个程序，将一个十进制数转换成任意的2~20以内的其他进制数。这些数据由数字0-9，字母A-J组成，其中A=10，B=11……J=19。例如90转换为16进制数为5A（90=5\*16+10\*1）。

输入说明 :

程序需要输入多组数据，每组数据一行，每行有两个数，用空格隔开，分别表示十进制数和转换成的进制数。输入数据不会超过10000，例如：90 16 表示将90转换成16进制数。

输出说明 :

对于每行输入数据需输出一个结果。每个结果包含为一个20以内的进制的数。输出的字母都为大写字母。例如：90 16需输出结果5A。

输入范例 :

```
127 2 
90 16
```

输出范例 :

```
1111111
5A
```

根据题目描述，我们需要编写一个程序将十进制数转换为指定进制的数。下面是一个完成此任务的 C++ 程序示例：

```cpp
#include <iostream>
#include <string>
#include <stack>
using namespace std;

string DecimalToBase(int decimal, int base) {
    stack<char> digits;

    while (decimal > 0) {
        int remainder = decimal % base;
        char digit;
        if (remainder < 10) {
            digit = '0' + remainder;
        } else {
            digit = 'A' + remainder - 10;
        }
        digits.push(digit);
        decimal /= base;
    }

    string result;
    while (!digits.empty()) {
        result += digits.top();
        digits.pop();
    }

    return result;
}

int main() {
    int decimal, base;
    while (cin >> decimal >> base) {
        string result = DecimalToBase(decimal, base);
        cout << result << endl;
    }

    return 0;
}
```

上述代码中，我们定义了 `DecimalToBase()` 函数，它将十进制数 `decimal` 转换为指定进制 `base` 的数。在函数中，我们使用了一个栈 `digits` 来存储每个位上的数字或字母。然后，我们通过不断取余和除法的操作，将十进制数转换为指定进制。最后，我们将栈中的数字或字母依次弹出，构成最终的转换结果。

在 `main()` 函数中，我们循环读取输入的十进制数和进制数，并调用 `DecimalToBase()` 函数进行转换，并输出结果。

请将上述代码保存到一个名为 `main.cpp` 的文件中，并使用编译器进行编译和运行。然后，根据题目要求输入数据，程序将输出对应的转换结果。例如，对于输入示例 `127 2`，输出将为 `1111111`；对于输入示例 `90 16`，输出将为 `5A`。

### 构造序列（求助GPT）

问题描述 :

序列是在数学世界中一种非常有趣的数字现象，它通过某一规则来产生数字，使数字变得有趣、变幻无穷。很多数学家对序列这种事物产生了浓厚的兴趣，花了很多时间对其进行研究，明明就是其中的一位。一天，他又在研究一种新的序列产生规则，该序列的规则如下：

1） 第1轮，写出两个1，即11；

2） 第2轮，在它们中间插入2，成为121；

3） 第3轮，在上面数中每两个相邻的和为3的数之间插入3，成为13231；

4） 以此类推下去，第n轮，在第n-1轮的数字的基础上，每两个相邻的和为n的数之间插入n。

明明根据这个规则开始构造序列。开始还觉得容易，但是越到后面，明明发现构造序列的计算量越来越大，计算难度也越来越高，计算速度也越来越慢。于是，明明就求助于你这位程序设计专家，能否帮他写一个程序，构造出序列的前9项，然后当明明需要知道序列中的哪一项的时，你就把那一项的数字告诉明明。

明明的问题可以归结为：根据题目描述中所描述的序列产生规则构造序列的前9项，然后告诉你一个正整数n，要求你输出序列的第n项。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数n（1≤n≤9），代表之后所要求的序列的第n项的值。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即所要求的序列中那一项的数值，每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
3 
4 
5
```

输出范例 :

```
13231
1432341
15435253451
```

自己写的程序只能搞定n=3的结果。。。。

```cpp
#include <string>
using namespace std;

string seq(int n)
{
    if(n==1) return "11";
    if(n==2) return "121";
    if(n>=3)
    {
        string s=seq(n-1);
        for(int i=0;i<n-1;i++)
        {
            if((seq(n-1)[i]-'0')+(seq(n-1)[i+1]-'0')==n)
            {
                int j=i;
                if(i!=0) j++;
                s.insert(j+1,string(1,(char)(n+'0')));
                //s.push_back(seq(n-1)[i]);
                //s.push_back(n+'0');
                //s.push_back(seq(n-1)[i+1]);
            }
            //s.push_back(seq(n-1)[i+1]);
        }
        return s;
    }
}

int main() {
    int n;
    while (cin >> n) {
        string result=seq(n);
        cout<<result<<endl;
    }

    return 0;
}
```

这个问题需要使用递归的方式来解决。下面是一个C++的解决方案：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<string> sequence(10);

void generate_sequence() {
    sequence[1] = "11";
    for(int i = 2; i <= 9; ++i) {
        string tmp = "";
        for(int j = 0; j < sequence[i - 1].size(); ++j) {
            tmp += sequence[i - 1][j];
            if(j < sequence[i - 1].size() - 1 && sequence[i - 1][j] + sequence[i - 1][j + 1] - 2 * '0' == i)
                tmp += to_string(i);
        }
        sequence[i] = tmp;
    }
}

int main() {
    generate_sequence();

    int n;
    while(cin >> n) {
        cout << sequence[n] << endl;
    }

    return 0;
}
```

这段程序首先会生成一个全局变量`sequence`，这个变量是一个字符串的向量，用于存储生成的序列。然后，`generate_sequence`函数会被调用来生成前9个序列。

在`generate_sequence`函数中，我们首先设定序列的第一个元素为"11"。然后，对于每一个序列的元素，我们遍历前一个元素中的每一个字符。如果当前字符和下一个字符的和等于当前的序列号，我们就在这两个字符之间插入当前的序列号。

在`main`函数中，我们首先调用`generate_sequence`函数来生成序列。然后，我们读取输入，对于每一个输入的整数n，我们打印出序列的第n个元素。

能AC的简化版如下：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<string> sequence={"11","121","13231","1432341","15435253451","1654352534561","1765473572753745671","18765473857275837456781","19876594738579297583749567891"};

int main() {

    int n;
    while(cin >> n) {
        cout << sequence[n-1] << endl;
    }

    return 0;
}
```

### A == B ?

问题描述 :

给你两个非负实数A和B，如果A等于B，输出 "YES", 否则输出"NO"

输入说明 :

第一行N，表示有N组测试数据。

以下N行，每行两个非负实数 A和B。每个实数不超过1000位，且可能在前面和后面有0存在。

输出说明 :

对于每组测试数据，如果A和B相等则输出 "YES"， 否则输出 "NO"。

每组测试数据占一行，两组测试数据之间无空行。行首与行尾均无空格。

输入范例 :

```
2
100.0 00100
0100.1234576 00000000100.123457
```

输出范例：

```
YES
NO
```

```cpp
#include <iostream>
#include <string>
#include <sstream>

using namespace std;


int main()
{

    int n;
    cin>>n;
    while(n--)
    {
        string sa,sb;
        cin>>sa>>sb;
        stringstream geek(sa);
        double xa=0;
        geek>>xa;
        double xb=stod(sb);
        if(xa==xb) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }

    return 0;
}
```

### 最长的单词

问题描述 :

明明刚开始学习英语的时候，对英语有浓厚的兴趣，但是随着时间的推移，英语单词量的增加，明明越来越觉得背单词是一件相当痛苦的事情。于是他想出各种各样的方法来增加背单词的乐趣。

这次他想出的方法是把所有要背的英语单词排成一行，找出其中最长的一个单词来先背，然后划去这个单词，在剩下的单词中再找出一个最长的单词来背，以此类推，直到把所有单词都背完。如果有多个长度相同的单词，则先背一行中靠前的那个单词。这样做的好处是：背到越后面，单词越短，越容易背，越能增加背单词的信心。

例如有这么一行单词： one two three four five 明明会首先挑出three来背，因为它是最长的一个单词，由5个字母组成；然后明明会选择four这个单词，虽然five这个单词的长度和four这个单词的长度一样，但是four在five的前面，所以明明会先背four这个单词，然后再背five，等明明把five这个单词背完以后，接着背one这个单词，最后背的是two这个单词。

但是在这样背单词之中，明明又发现了另一个问题，当要背非常多的单词时，寻找最长的单词会花很多时间，他想让你帮助他写一个程序，找出一行单词中最长的那个，节约明明背单词所花的时间，与此同时，明明希望你能告诉他这个英文单词有多少个字母组成，那他可以做到心里有数。

明明的问题可以归结为：在一行英文单词中，找出其中最长的单词（若有多个最长，找出第一个出现的），并输出这个单词的长度。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行包括许多个英语单词和空格，单词和单词之间可能有多个空格，每行的长度不会超过1000个字符。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数和一个英语单词，整数表示该英文单词的长度，整数和单词之间用一个空格隔开。输出时，每组运算结果单独占一行，其行首和行尾都没有任何空格或其他任何字符，每组运算结果与其后一组运算结果之间没有任何空行或其他任何字符，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行或其他任何字符。 注：通常，显示屏为标准输出设备。

输入范例 :

```
a bc def ghijk lmn
abc def ghi
```

输出范例 :

```
5 ghijk
3 abc
```

```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
using namespace std;


int main()
{

    string s;
    while (getline(cin, s))
    {
        stringstream ss;
        ss<<s;
        string p;

        int maxseq=0;
        string maxstring;
        while(ss>>p)
        {
            if(p.length()>maxseq)
            {
                maxseq=p.length();
                maxstring=p;
            }
        }
        cout<<maxseq<<" "<<maxstring<<endl;
    }

    return 0;
}
```

### 字符串对比

问题描述 :

给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4种情况之一：  

1：两个字符串长度不等。比如 Beijing 和 Hebei  

2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing  

3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和BEIjing  

4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing  

编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。

输入说明 :

包括两行，每行都是一个字符串

输出说明 :

仅有一个数字，表明这两个字符串的关系编号

输入范例 :

```
BEIjing
beiJing
```

输出范例 :3

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{

    string s1,s2;
    cin>>s1;
    cin>>s2;

    if(s1.length()!=s2.length())
        cout<<"1"<<endl;
    if(s1.length()==s2.length()&&s1==s2)
        cout<<"2"<<endl;
    if(s1.length()==s2.length()&&s1!=s2)
    {
        transform(s1.begin(),s1.end(),s1.begin(),::tolower);
        transform(s2.begin(),s2.end(),s2.begin(),::tolower);
        if(s1==s2)
            cout<<"3"<<endl;
        else
            cout<<"4"<<endl;
    }
    return 0;
}
```

### 幸运偶数

问题描述 :

从键盘上输入一个整数(长度不大于200)，将其各位上为奇数的数字去除，剩余的数字按数字大小从大到小排序，组成一个新的数，并输出到屏幕上。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行有一个整数，整数的长度不大于200。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的计算结果，并将这一组计算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。若全为奇数，输出结果为“None”。注：通常，显示屏为标准输出设备。

输入范例 :

```
276238496
13579
```

输出范例 :

```
866422
None
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{

    string s;
    while(cin>>s)
    {
        vector<int> nums;
        for(int i=0;i<s.length();i++)
        {
            if((s[i]-'0')%2==0)
                nums.push_back(s[i]-'0');
        }

        if(nums.size()==0)
            cout<<"None"<<endl;
        else
        {
            sort(nums.begin(),nums.end());
            for(int i=nums.size()-1;i>=0;i--)
                cout<<nums[i];
            cout<<endl;
        }
    }


    return 0;
}
```

### 单词统计

问题描述 :

从键盘上输入一个整数N，并输入N行字符串。每行字符串都包含多个单词，单词之间以空格分开。请输出每行字符串中单词的个数。

说明：以空格分隔开的任何字符串都认为是单词。比如“I'm”认为是一个单词

输入说明 :

首先输入一行，包含一个整数N，表示共测试N组数据。

后面接着输入N行，每行为一个字符串，字符串长度小于等于50。每个字符串中包含多个单词，单词之间以空格分隔。

输出说明 :

对每组测试数据，你的程序需要向标准输出文件（通常为启动该程序的终端）依次输出字符串中单词的个数。每个输出占一行，在行首和行尾不要输出多余的空格。在所有数据前后，以及两组数据之间不要输出多余的空行。

输入范例 :

```
3
i am a boy.
byebyetoyou
       haha   ,    meet        you   again!
```

输出范例 :

```
4
1
5
```

```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;


int main()
{

    string s;
    int n;
    cin>>n;
    getchar();
    while(n--)
    {
        getline(cin,s);
        stringstream ss;
        ss<<s;
        string p;
        int count=0;
        while(ss>>p)
        {
            count++;
        }
        cout<<count<<endl;
    }


    return 0;
}
```














