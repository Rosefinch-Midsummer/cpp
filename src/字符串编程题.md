# 字符串编程题

<!-- toc -->

## 7.1字符串->简单

### 加密

问题描述 :

编写一个加密程序，用来加密一个字符串。加密规则如下：

1.把字符串中的所有数字0、1 … 9分别换成小写英文字母a、b … j。

2.把字符串中的所有小写英文字母a、b … j分别换成数字0、1 … 9。

3.其它字符保持不变。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据占一行，其中只包含一个字符串，即需要被加密的字符串。该字符串包含不超过100个字符，只包含可见的ASCII字符，并且不包含空格、制表符或换行符。在行首和行尾没有多余的空格；所有数据前后没有多余的空行；两组数据之间没有多余的空行。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出一组对应的答案。每组答案占一行，其中只包含一个字符串，即问题描述中的加密结果。在行首和行尾不要输出多余的空格；在所有数据前后不要输出多余的空行；在两组数据之间不要输出多余的空行。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        for(int i=0;i<s.length();i++)
            {
                if((s[i]<='9')&&(s[i]>='0'))
                {
                    cout<<(char)(s[i]+49);
                }
                else if((s[i]>='a')&&(s[i]<='j'))
                {
                    cout<<(char)(s[i]-49);
                }
                else
                    cout<<s[i];
            }
            cout<<endl;
    }
}
```

### 字符串排序（调教GPT）

输入范例 :

```
asdf
shflsahfslfdjsldfsjd
```

输出范例 :

```
adfs
adddffffhhjjlllsssss
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        sort(s.begin(),s.end());
        cout<<s<<endl;
    }
    return 0;
}
```

以下是根据您提供的要求完成的C++程序：

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    string input;
    while (getline(cin, input)) {
        sort(input.begin(), input.end());
        cout << input << endl;
    }
    return 0;
}
```

这个程序通过使用`getline()`函数来读取输入的多组测试数据，每次读取一行字符串并存储在`input`变量中。然后，使用`sort()`函数对字符串进行排序，最后将排序后的字符串输出到标准输出流中。

请注意，该程序假设每行输入的字符串都在合理的范围内，并且每组测试数据都以换行符结束。

如果您不想使用`sort()`函数进行字符串排序，可以使用其他方法来实现。以下是一个不使用`sort()`函数的示例程序：

```cpp
#include <iostream>
#include <string>
using namespace std;

string sortString(string input) {
    for (int i = 0; i < input.length() - 1; i++) {
        for (int j = i + 1; j < input.length(); j++) {
            if (input[i] > input[j]) {
                char temp = input[i];
                input[i] = input[j];
                input[j] = temp;
            }
        }
    }
    return input;
}

int main() {
    string input;
    while (getline(cin, input)) {
        string sortedString = sortString(input);
        cout << sortedString << endl;
    }
    return 0;
}
```

在这个程序中，我们定义了一个名为`sortString`的函数，该函数接受一个字符串作为参数，并使用冒泡排序算法对字符串进行排序。然后，在`main()`函数中，我们循环读取输入的多组测试数据，并将每行字符串传递给`sortString`函数进行排序，最后将排序后的字符串输出到标准输出流中。

请注意，这种方法并不高效，因为冒泡排序的时间复杂度为O(n^2)，而`sort()`函数使用的是更高效的排序算法。然而，如果您有特定要求不允许使用`sort()`函数，这个示例程序可以实现字符串排序的功能。

### 手机短号

问题描述 :

大家都知道，手机号是一个11位长的数字串，同时，作为学生，还可以申请加入校园网，如果加入成功，你将另外拥有一个短号。假设所有的短号都是“6”+手机号的后5位，比如号码为13512345678的手机，对应的短号就是645678。

现在，如果给你一个11位长的手机号码，你能找出对应的短号吗？

输入说明 :

输入数据的第一行是一个N(N <= 1000)，表示有N个数据，接下来的N行每一行为一个11位的手机号码。

输出说明 :

输出应包括N行，每行包括一个对应的短号，输出应与输入的顺序一致。

输入范例 :

```
2
70711457490
47810534444
```

输出范例：

```
657490
634444
```

二维字符数组实现

```cpp
#include <iostream>
using namespace std;

int main() {
    int N;
    cin>>N;
    char number[N][12];
    for(int i=0;i<N;i++)
        {
            for(int j=0;j<11;j++)
                {
                    cin>>number[i][j];
                }
        }

    for(int i=0;i<N;i++)
    {
        cout<<6;
        for(int j=6;j<11;j++)
            cout<<number[i][j];
        cout<<endl;
    }
    return 0;
}
```

一维字符串实现

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int N;
    cin>>N;
    string s[N];
    for(int i=0;i<N;i++)
        cin>>s[i];

    for(int i=0;i<N;i++)
    {
        cout<<6;
        for(int j=6;j<11;j++)
            cout<<s[i][j];
        cout<<endl;
    }
    return 0;
}
```

### 求绝对值（求助GPT）

问题描述 :

给你一个大整数（绝对值不超过1,000位数），请求出这个数字的绝对值。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据占一行，其中仅有一个整数N；N的绝对值不会超过1,000位数；输入的数据没有前导零；如果N是负数，则在负号和最左边一位数字之间不会有空格。每行的行首和行尾都没有多余的空格。在所有数据的前后，以及两组数据之间都没有多余的空行。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。每组答案占一行，其中仅有一个整数，即N的绝对值。在行首和行尾不要输出多余的空格。在所有数据的前后，以及两组数据之间不要输出多余的空行。

自己写的这个有溢出问题，只在部分数据上是AC。

```cpp
#include <iostream>
#include <sstream>
#include <cmath>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        stringstream geek(s);
        int x=0;
        geek>>x;

        cout<<abs(x)<<endl;
    }
    return 0;
}
```

```cpp
#include <iostream>
#include <sstream>
#include <cmath>
using namespace std;


int main()
{
    string s;
    while(cin>>s)
    {
        cout<<abs(stoi(s))<<endl;
    }
    return 0;
}
```

根据题目的要求，我们可以用C++的`std::string`类来处理大数字。读取输入时，我们将数字当作字符串读取；然后，通过检查第一个字符是否为负号（'-'）来决定是否需要去掉它，从而得到绝对值。以下是一个可能的实现：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string num;
    while (std::cin >> num) {
        // 如果数字是负数，去掉负号
        if (num[0] == '-')
            num = num.substr(1);
        std::cout << num << std::endl;
    }
    return 0;
}
```

这个程序会继续读取输入，直到没有更多的数据可以读取（例如，如果你在终端里运行它，你可以通过按Ctrl+D来表示输入结束）。

注意，这个程序并没有处理可能的输入错误，例如如果输入的字符串中包含非数字字符。根据题目的描述，我们假定所有的输入都是有效的。

### 字符串统计

问题描述 :

对于给定的一个字符串，统计其中小写字母出现的次数。

输入说明 :

输入数据有多行，第一行是一个整数n，表示测试实例的个数，后面跟着n行，每行包括一个由字母和数字组成的字符串。

输出说明 :

对于每个测试实例，输出该串中数值的个数，每个输出占一行。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s;
    int N;
    cin>>N;
    while(N--)
    {
        cin>>s;
        int num=0;
        for(int i=0;i<s.length();i++)
        {
            if(s[i]<='z'&&s[i]>='a')
                num++;
        }
        cout<<num<<endl;
    }
    return 0;
}
```

### 模拟登录

问题描述 :

编写程序模拟简单的密码登录（正确的密码是123456），首先从键盘输入用户名（用户名随意，不超过10个字符）

然后输入密码，若密码正确（即为123456）则给出问候语。

若密码不正确，则给出错误提示，并允许再次输入，

直到输入正确的密码或输入0结束。

输入说明 :

用户名，和若干次密码。

输出说明 :

若密码正确则输出:

Hello 用户名换行

并退出

若错误则输出:

Wrong Password!换行

并再次输入判断

若密码为0则在输出Wrong Password!后退出。

输入范例 :

```
tom
123
123456
```

输出范例 :

```
Wrong Password!
Hello tom
```

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string admin;
    cin>>admin;

    int password;

    while(cin>>password)
    {
        if(password!=123456&&password!=0)
            {
                cout<<"Wrong Password!"<<endl;
                continue;
            }
        else if(password!=123456&&password==0)
            {
                cout<<"Wrong Password!"<<endl;
                break;
            }
        else
            {
                cout<<"Hello"<<" "<<admin<<endl;
                break;
            }
    }

    return 0;
}
```

### 日期（调教GPT）

问题描述 :

输入星期日到星期六的英文缩写（Sun,Mon,Tue,Wed,Thu,Fri,Sat），输出其对应的完整单词。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每行输入相关单词，在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出从标准输入设备中读入的每一组测试数据对应的结果。所有数据前后没有多余的空行，两组数据之间也没有多余的空行。每组输出数据由一行组成，该行为该英文单词的全称。

```cpp
#include <iostream>
#include <string>
using namespace std;


int main()
{
    string s,s1,s2,s3,s4,s5,s6,s7;
    s1="Mon";
    s2="Tue";
    s3="Wed";
    s4="Thu";
    s5="Fri";
    s6="Sat";
    s7="Sun";

    while(cin>>s)
    {
        if(s.compare(s1)==0)
            {
                cout<<"Monday"<<endl;
                continue;
            }
        else if(s.compare(s2)==0)
            {
                cout<<"Tuesday"<<endl;
                continue;
            }
        else if(s.compare(s3)==0)
            {
                cout<<"Wednesday"<<endl;
                continue;
            }
        else if(s.compare(s4)==0)
            {
                cout<<"Thursday"<<endl;
                continue;
            }
        else if(s.compare(s5)==0)
            {
                cout<<"Friday"<<endl;
                continue;
            }
        else if(s.compare(s6)==0)
            {
                cout<<"Saturday"<<endl;
                continue;
            }
        else
            {
                cout<<"Sunday"<<endl;
                continue;
            }

    }

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

std::string getFullDay(const std::string& abbreviation) {
    if (abbreviation == "Sun") {
        return "Sunday";
    } else if (abbreviation == "Mon") {
        return "Monday";
    } else if (abbreviation == "Tue") {
        return "Tuesday";
    } else if (abbreviation == "Wed") {
        return "Wednesday";
    } else if (abbreviation == "Thu") {
        return "Thursday";
    } else if (abbreviation == "Fri") {
        return "Friday";
    } else if (abbreviation == "Sat") {
        return "Saturday";
    } else {
        return "Invalid abbreviation";
    }
}

int main() {
    std::string abbreviation;

    while (std::getline(std::cin, abbreviation)) {
        std::string fullDay = getFullDay(abbreviation);
        std::cout << fullDay << std::endl;
    }

    return 0;
}
```

在这个程序中，我们首先定义了一个`getFullDay`函数，用于根据输入的英文缩写返回完整的星期几的单词。在`getFullDay`函数中，我们使用`if-else`语句判断输入的缩写是哪一天，并返回对应的完整单词。

在`main`函数中，我们使用`std::getline`函数循环读取输入的每一行数据，将输入的缩写作为参数调用`getFullDay`函数得到完整单词，然后将其输出到标准输出设备。

请注意，根据您的问题描述，程序假设每组测试数据都在一行中，并且每组数据之间没有多余的空行。如果输入的缩写不在星期日到星期六的范围内，程序将输出"Invalid abbreviation"。

您可以根据需要自行扩展或修改`getFullDay`函数，以适应其他缩写或完整单词的映射关系。
### 删除字符（调教GPT）

问题描述 :

从键盘输入一个字符串和一个字符，将输入字符从字符串中删除，输出新的字符串。如果字符串中没有此字符，则原样输出字符串。

输入说明 :

输入两行，第一行输入一个字符串，第二行输入一个字符。

字符串最多允许输入20个任意字符。

输出说明 :

输出删除字符后的字符串。

输入范例 :

```
ab  ccdc
c
```

输出范例 :

```
ab  d
```

自己写的程序存在PE错误

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{
    string s;
    getline(cin,s);
    char ch;
    cin>>ch;

    s.erase(remove(s.begin(),s.end(),ch),s.end());
    cout<<s<<endl;

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    char ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::cin >> ch;

    // 删除字符
    std::string result;
    for (char c : str) {
        if (c != ch) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在这个程序中，我们使用了`std::string`来存储输入的字符串和输出的结果。首先，我们使用`std::getline`函数来读取一行输入字符串，然后使用`std::cin`来读取一个字符。接下来，我们使用一个循环遍历输入的字符串，如果当前字符不等于要删除的字符，就将它添加到结果字符串中。最后，我们输出结果字符串。

请注意，根据您的问题描述，删除字符是区分大小写的。如果您希望删除字符时不区分大小写，可以使用`std::tolower`函数或`std::toupper`函数将字符转换为统一的大小写后进行比较。

抱歉，我之前提供的程序确实没有正确处理空格、换行和制表符等特殊字符。为了解决这个问题，我们可以使用`std::getline`函数读取输入字符串，并使用`std::getline`函数的第三个参数指定定界符为空格字符。

以下是更新后的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    char ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::cin >> ch;
    std::cin.ignore(); // 忽略换行符

    // 删除字符
    std::string result;
    for (char c : str) {
        if (c != ch) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在更新后的程序中，我们使用了`std::getline`函数来读取输入的字符串，同时将空格字符作为定界符，这样可以正确读取包含空格的字符串。然后，我们使用`std::cin.ignore()`来忽略输入中的换行符，以确保后续的字符输入不受影响。

现在，程序应该能够正确处理空格、换行和制表符等特殊字符。请再次尝试并检查结果是否正确。

非常抱歉出现了这个问题。我注意到在之前的程序中，我们使用了`std::cin`来读取输入的字符。然而，`std::cin`在读取字符时会忽略空格、换行和制表符等空白字符。为了解决这个问题，我们可以改用`std::getline`函数来读取输入的字符，将空格字符作为定界符。

以下是更新后的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    std::string ch;

    // 输入字符串
    std::getline(std::cin, str);

    // 输入字符
    std::getline(std::cin, ch);

    // 删除字符
    std::string result;
    for (char c : str) {
        if (ch.find(c) == std::string::npos) {
            result += c;
        }
    }

    // 输出结果
    std::cout << result << std::endl;

    return 0;
}
```

在这个更新后的程序中，我们使用`std::getline`函数来读取输入的字符串和字符。我们将输入的字符存储在`std::string`类型的变量`ch`中。然后，我们使用`std::string`的`find`函数来判断字符串中是否包含要删除的字符。如果字符不在字符串中，我们将其添加到结果字符串中。

请再次尝试并检查程序是否能够正确处理空格、换行和制表符等特殊字符。如果问题仍然存在，请提供更多的详细信息，我将尽力帮助您解决问题。

### 倒序（调教GPT）

问题描述 :

编写程序，把一串字符以倒序的方式输出。

输入说明 :

你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。第一行输入字符串的个数n。之后就有n组输入数据，每组输入为一行字符串，该串由ASCII字符的任意组合构成，它们之间可能有一个或多个空格，在行首和行尾没有多余的空格。

输出说明 :

对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的文本终端，例如你在Windows中启动该程序所用的命令行终端）依次输出从标准输入设备中读入的每一组测试数据对应的结果，使其成为输入串的倒序。所有数据前后没有多余的空格，两组数据之间也没有多余的空行。

输入范例：

```
2
abcd-ef
I love ACM!
```

输出范例：

```
fe-dcba
!MCA evol I
```

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    int N;
    cin>>N;
    cin.get();
    string s;
    while(N--)
    {
        getline(cin,s);
        string result;
        for(int i=s.length();i>=0;i--)
        {
            result += s[i];
        }
        if (result[0] == '\0')
            result = result.substr(1);
        cout<<result<<endl;
    }

    return 0;
}
```

以下是根据您提供的问题描述完成的C++程序：

```cpp
#include <iostream>
#include <string>

int main() {
    int n;
    std::cin >> n;
    std::cin.ignore(); // 忽略换行符

    for (int i = 0; i < n; i++) {
        std::string str;
        std::getline(std::cin, str);

        // 倒序输出字符串
        for (int j = str.length() - 1; j >= 0; j--) {
            std::cout << str[j];
        }
        std::cout << std::endl;
    }

    return 0;
}
```

在这个程序中，我们首先读取一个整数`n`，表示要输入的字符串个数。然后使用`std::cin.ignore()`来忽略输入中的换行符。

接下来，我们使用一个循环来读取每组测试数据。对于每组数据，我们使用`std::getline`函数来读取输入的字符串。然后，我们使用一个循环从字符串的最后一个字符开始，倒序输出每个字符。

最后，我们在每组数据输出完成后输出一个换行符。

请注意，根据您的问题描述，程序假设输入的每组数据都在一行中，并且每组数据之间没有多余的空行。

## 7.2字符串->中等

### 加法器（求助GPT）

问题描述 :

明明读小学的时候，不喜欢数学，尤其是不喜欢做加法，一做加法就头疼，这样导致明明长大后数学依然不好，而且对数字产生了抵触心理。可是不巧的是，明明进了一家会计公司，每天都要计算很多数据，在这些计算中加法运算居多，而且这些加法不只是是两个数之间的加法，更有多个数的连加。 例如：1+2+3的正确答案是6。 这给明明造成了很大的麻烦。你是明明的好朋友，看到明明如此痛苦，就产生了帮助明明的想法。你想帮明明写一个程序，这个程序能计算一串正整数的连加，从而帮助明明摆脱数字的困扰。 明明的问题可以归结为：给你一串正整数的连加表达式，完成这个表达式的计算。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅有一行，每行有一个表达式，表达式由正整数和加号（“+”）组成，不含其他任何符号，表达式中的数字小于等于30000,表达式的长度不超过1000，具体格式见输入样例。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即表达式的值。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
1+2+3
5+111
```

输出范例 :

```
6
116
```

```cpp
#include <iostream>
#include <sstream>

using namespace std;

int calculateSum(const string& expression) {
    stringstream ss(expression);
    int sum = 0;
    int num;
    char op;

    // 从流中读取数字和操作符，并进行计算
    ss >> num;
    sum = num;
    while (ss >> op >> num) {
        if (op == '+')
            sum += num;
    }

    return sum;
}

int main() {
    string expression;
    while (getline(cin, expression)) {
        int sum = calculateSum(expression);
        cout << sum << endl;
    }

    return 0;
}

```

### 翻译字符串

问题描述 :

在现代战争中，情报战越来越显示出它的重要性，敌我双方都想方设法得到对方的情报，然后一举歼灭对方。然而，随着加密技术的出现，对情报进行加密变得越来越频繁，想破解敌方的情报也越来越难。明明是一名富有经验的情报工作人员，他的主要任务就是破解敌方的情报，从而得到对己方有利的信息。在一次破解情报任务中，明明再次成功地破解了敌方的情报。明明的破解方法如下：一串以‘@’为结束标志的字符串，从左至右对其进行翻译，若字符串中当前字符是整数n（0≤n≤9），则表示将后一个字符重复n+1次，不论后一个字符是否为数字，且后一个字符无需再次翻译；若当前字符非数字，则表示自己，无需翻译，直接输出即可。最后，输出翻译完的字符串。

例如字符串为：2d352d@，因为第一个字符为数字2，则将后一个字符d输出3次，而d则不需再翻译，然后翻译3，3也是一个数字，则将后一个字符5输出4次，而5则不需再翻译，然后翻译2，2也是一个数字，将后一个字符d输出3次，而d则不需再翻译，最后一个字符为@，表示自己，直接输出即可，最后的输出为：ddd 555 5dd d@；（注：在翻译时，‘@’)当作字符处理。） 这样翻译字符串的方法虽然简单，但是由于敌方的文件巨大，仅仅靠手工翻译是很难在短时间内完成的。于是明明就求助于你这位程序专家，按照明明提供的破译方法写一个程序，帮助明明快速把敌方文件翻译完成。

明明的问题可以归结为：按照文中提供的破译情报的方法，对字符串进行翻译，然后输出翻译后的字符串。

输入说明 :

你写的程序要求从标准输入设备（通常，键盘为标准输入设备）中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行包含一个以‘@’为结束标志的字符串，字符串由数字、小写字母以及‘@’组成，中间不包含空格，字符串长度不大于10。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备（通常，显示屏为标准输出设备）中。每组运算结果为经过翻译的字符串，字符串中的字符以三个为一组输出，每组字符之间用一个空格隔开。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。

输入范例 :

```
a1b2c3d4@ 
2d352d@ 
dsegweg@
```

输出范例 :

```
abb ccc ddd d@@ @@@
ddd 555 5dd d@
dse gwe g@
```

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    string expression;
    vector<char> result;
    while (getline(cin, expression)) {

            for(int i=0;i<expression.length();i++)
            {

                if(expression[i]<='z'&&expression[i]>='a')
                    result.push_back(expression[i]);
                if(expression[i]<='9'&&expression[i]>='0')
                {
                    for(int j=0;j<=expression[i]-'0';j++)
                        result.push_back(expression[i+1]);
                    i++;
                }
                if((expression[i-1]<='z'&&expression[i-1]>='a'&&expression[i]=='@')||expression[0]=='@')
                {
                    result.push_back(expression[i]);
                }

            }

            for(int i=0;i<result.size()-1;i++)
            {
                cout<<result[i];
                if((i+1)%3==0) cout<<" ";
            }
            cout<<result[result.size()-1]<<endl;
            result.clear();
    }

    return 0;
}
```

根据题目要求，我们需要编写一个程序来实现字符串的翻译。下面是相应的C++程序：

```cpp
#include <iostream>
#include <string>

using namespace std;

string translateString(const string& str) {
    string translatedStr;
    int len = str.length();
    int i = 0;

    while (i < len) {
        if (isdigit(str[i])) {
            int count = str[i] - '0';  // 计算重复次数
            char ch = str[i + 1];      // 获取下一个字符
            translatedStr.append(count, ch);
            i += 2;
        } else if (str[i] == '@') {
            translatedStr.push_back('@');
            i++;
        } else {
            translatedStr.push_back(str[i]);
            i++;
        }
    }

    return translatedStr;
}

int main() {
    string str;
    while (getline(cin, str, '@')) {
        string translatedStr = translateString(str);
        int len = translatedStr.length();
        for (int i = 0; i < len; i += 3) {
            cout << translatedStr.substr(i, 3) << ' ';
        }
        cout << endl;
    }

    return 0;
}
```

在上述程序中，我们定义了一个`translateString`函数，用于实现字符串的翻译。函数遍历输入字符串，根据题目提供的翻译规则进行处理，将翻译后的字符追加到`translatedStr`字符串中。

在`main`函数中，我们使用`getline`函数从标准输入读取以`@`为结束标志的字符串。然后，我们调用`translateString`函数对字符串进行翻译，并将结果输出到标准输出。为了满足输出格式要求，我们将每三个字符以一组输出，并在每组字符之间添加一个空格。

请尝试运行程序，并输入相应的字符串进行测试。程序将对字符串进行翻译并输出结果。

ChatGPT给出的程序是错误的，不过所用代码给了我不少启发，改写后的能AC的程序如下：

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    string expression;
    string result;
    while (getline(cin, expression)) {

            for(int i=0;i<expression.length();i++)
            {

                if(expression[i]<='z'&&expression[i]>='a')
                    result.push_back(expression[i]);
                if(isdigit(expression[i]))
                {
                    int count=expression[i]-'0';
                    char ch=expression[i+1];
                    result.append(count+1,ch);
                    i++;
                }
                if((expression[i-1]<='z'&&expression[i-1]>='a'&&expression[i]=='@')||expression[0]=='@')
                {
                    result.push_back(expression[i]);
                }

            }
            int len=result.length();
            for(int i=0;i<len-1;i++)
            {
                cout<<result[i];
                if((i+1)%3==0) cout<<" ";
            }
            cout<<result[len-1]<<endl;
            result.clear();
    }

    return 0;
}
```

### 求字符串的起始位置

问题描述 :

在程序设计中，对字符串的处理是经常遇到的一个问题。

例如，将字符串中所有的英文字母变成大写，或者将一个字符串与另一个字符串连接构成一个新的字符串。

由于此类的操作非常普遍，因此，在设计程序语言的时候，设计者就已经把这类操作的代码写好了，如果编程人员要使用这些代码，只需把该类代码的头文件包含到自己的程序中，编程人员就可以很简单的调用，这样使编程节省了不少时间。

明明是一名项目经理，他现在负责一种新的程序设计语言的开发，现在需要预先实现大量的和处理字符串有关的功能方法，以后这些方法会包含到程序设计语言中，方便程序语言使用者的开发。你是明明手下的一名软件工程师，明明分配给你一个任务，在两个字符串中，找到一个字符串在另一个字符串中的起始位置。 例如，有两个字符串，一个字符串s= “abc”，另一个字符串subs=“bc”，现在就要找出“bc”在“abc”中的其实位置，在这个例子中，“bc”的起始位置为2。

明明的问题可以归结为：输入两串字符串s和subs，求s中subs的起始位置。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据两行，每组测试数据的第一行为字符串s，s的长度小于100，每组测试数据的第二行为字符串subs，subs的长度小于100，s和subs中仅包含小写字母和数字。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数m，即subs在s中的起始位置，如果在s中找不到subs这个子串，则m=0。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
abc 
bc 
aaa 
bbb
```

输出范例 :

```
2
0
```

```cpp
#include <iostream>
#include <string>
using namespace std;

int main()
{
    string s,subs;
    while(cin>>s>>subs)
    {
        if(s.find(subs)!=s.npos)
            cout<<s.find(subs)+1<<endl;
        else
            cout<<0<<endl;
    }
}
```

### 字符串统计（附GPT4实现）

问题描述 :

明明最近在做一个有关字符串的统计工作。两个由小写字母组成的字符串s1和s2，明明需要统计出以下四种关系：   

（1）在s1或s2中存在的字母（包括在s1和s2中都存在的字母）；   

（2）在s1中且在s2中的字母；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母；   

（4）不在s1中且也不在s2中的字母；   

例如两个字符串s1为“lkjsvoahs”，s2为“qglhskjdfg”：   

（1）在s1或者在s2或者s1、s2中都存在的字母：adfghjkloqsv；   

（2）在s1中且在s2中的字母：hjkls；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母：adfgoqv；   

（4）不在s1中且也不在s2中的字母：bceimnprtuwxyz；   

明明统计了很久，但是由于统计过程十分繁琐，且很容易出错，导致明明的进度非常慢，很有可能因为统计不完而错过了晚上的约会。因此明明想请你帮个忙，帮他写一个程序，用程序来统计出以上几项内容。   

明明的问题可以归结为：  

输入两串由小写字母组成的字符串s1和s2，比较其中的字母，输出以下四项，输出的字母以字典顺序排列：   

（1）在s1或s2中存在的字母（包括在s1和s2中都存在的字母）；   

（2）在s1中且在s2中的字母；   

（3）在s1中但不在s2中的字母，在s2中但不在s1中的字母；   

（4）不在s1中且也不在s2中的字母；   

例如字符串s1为sadf，s2为asdf，则需输出以下四行（注意输出的格式）：  

in s1 or s2:adfs   

in s1 and s2:adfs   

in s1 but not in s2 ,or in s2 but not in s1:   

not in s1 and s2:bceghijklmnopqrtuvwxyz

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据两行，每组测试数据的第一行为字符串s1，每组测试数据的第二行为字符串s2；s1和s2都由小写英文字母组成，且长度不超过26个字符。测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。

每组运算结果由四行组成： 

第一行为在s1或者在s2或者s1、s2中都存在的字母； 

第二行为在s1中且在s2中的字母； 

第三行为在s1中但不在s2中的字母，在s2中但不在s1中的字母； 

第四行为不在s1中且也不在s2中的字母； 

具体格式请参考样例输出。 

每组运算结果其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。 

注：通常，显示屏为标准输出设备。

输入范例 :

```
sadf 
asdf 
lkjsvoahs 
qglhskjdfg
```

输出范例 :

```
in s1 or s2:adfs
in s1 and s2:adfs
in s1 but not in s2 ,or in s2 but not in s1:
not in s1 and s2:bceghijklmnopqrtuvwxyz

in s1 or s2:adfghjkloqsv
in s1 and s2:hjkls
in s1 but not in s2 ,or in s2 but not in s1:adfgoqv
not in s1 and s2:bceimnprtuwxyz
```

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;

void sort_string(string s )
{
    int len=s.length();
    char schar[len+1];
    strcpy(schar,s.c_str());
    char temp;
    for(int i=0;i<len-1;i++)
    {
        for(int j=i;j<len;j++)
        {
            if(schar[i]>schar[j])
            {
                temp=schar[i];
                schar[i]=schar[j];
                schar[j]=temp;
            }
        }
    }
    cout<<schar<<endl;

}

int main()
{
    string s1,s2,s3="abcdefghijklmnopqrstuvwxyz";
    bool firstline=true;
    while(cin>>s1>>s2)
    {
        string ins1ands2,notins1s2,ins1ors2,ins1butnotins2orins2butnotins1;
        if(!firstline)
            cout<<endl;
        firstline=false;
        for(int i=0;i<s1.length();i++)
        {
            for(int j=0;j<s2.length();j++)
            {
                if(s1[i]==s2[j]&&ins1ands2.find(s1[i])==ins1ands2.npos)
                    ins1ands2.push_back(s1[i]);
            }
        }

        for(int j=0;j<s1.length();j++)
        {
            if(ins1ands2.find(s1[j])==ins1ands2.npos&&ins1butnotins2orins2butnotins1.find(s1[j])==ins1butnotins2orins2butnotins1.npos)
                ins1butnotins2orins2butnotins1.push_back(s1[j]);
        }
        for(int j=0;j<s2.length();j++)
        {
            if(ins1ands2.find(s2[j])==ins1ands2.npos&&ins1butnotins2orins2butnotins1.find(s2[j])==ins1butnotins2orins2butnotins1.npos)
                ins1butnotins2orins2butnotins1.push_back(s2[j]);
        }
        for(int j=0;j<ins1ands2.length();j++)
        {
            ins1ors2.push_back(ins1ands2[j]);
        }
        for(int j=0;j<ins1butnotins2orins2butnotins1.length();j++)
        {
            ins1ors2.push_back(ins1butnotins2orins2butnotins1[j]);
        }
        for(int j=0;j<s3.length();j++)
        {
            if(ins1ors2.find(s3[j])==ins1ors2.npos)
                notins1s2.push_back(s3[j]);
        }

        cout<<"in s1 or s2:";sort_string(ins1ors2);

        cout<<"in s1 and s2:";sort_string(ins1ands2);

        cout<<"in s1 but not in s2 ,or in s2 but not in s1:";sort_string(ins1butnotins2orins2butnotins1);

        cout<<"not in s1 and s2:";sort_string(notins1s2);

    }
}
```

这个问题可以通过使用set数据结构在C++中解决。set数据结构可以自动排序并且不会有重复元素。这是一个示例解决方案：

```cpp
#include <iostream>
#include <set>
#include <string>
#include <algorithm>
using namespace std;

int main()
{
    string s1, s2;
    bool isFirst = true; // 用于判断是否为第一次输入
    
    //while(getline(cin, s1) && getline(cin, s2))
    while(cin>>s1&&cin>>s2)
    {
        if(isFirst)
            isFirst = false; // 第一次输入后设置为false
        else
            cout << endl; // 在每组输入之间添加一个空行

        set<char> set1(s1.begin(), s1.end());
        set<char> set2(s2.begin(), s2.end());
        set<char> setOr, setAnd, setDiff, setNone;

        // 在s1或s2中存在的字母
        set_union(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setOr, setOr.begin()));

        // 在s1中且在s2中的字母
        set_intersection(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setAnd, setAnd.begin()));

        // 在s1中但不在s2中的字母，在s2中但不在s1中的字母
        set_symmetric_difference(set1.begin(), set1.end(), set2.begin(), set2.end(), inserter(setDiff, setDiff.begin()));

        // 不在s1中且也不在s2中的字母
        for(char ch = 'a'; ch <= 'z'; ++ch)
        {
            if(setOr.count(ch) == 0)
            {
                setNone.insert(ch);
            }
        }

        cout << "in s1 or s2:";
        for (char ch : setOr)
            cout << ch;
        cout << endl;

        cout << "in s1 and s2:";
        for (char ch : setAnd)
            cout << ch;
        cout << endl;

        cout << "in s1 but not in s2 ,or in s2 but not in s1:";
        for (char ch : setDiff)
            cout << ch;
        cout << endl;

        cout << "not in s1 and s2:";
        for (char ch : setNone)
            cout << ch;
    }

    return 0;
}
```

这个程序首先读取两个输入字符串s1和s2，然后创建两个set，分别用于存储s1和s2的字符。然后，程序使用set的操作函数（如`set_union`，`set_intersection`，`set_symmetric_difference`）来计算并打印所需的输出。

错误提示指出`set_union`未在当前作用域中声明，这是因为你没有包含所需的头文件。`set_union`函数位于`algorithm`头文件中，因此你需要在代码中包含该头文件。

请将以下行添加到你的代码中，以包含`algorithm`头文件：

```cpp
#include <algorithm>
```

### 十进制转换成其它进制（求助GPT）

问题描述 :

编写一个程序，将一个十进制数转换成任意的2~20以内的其他进制数。这些数据由数字0-9，字母A-J组成，其中A=10，B=11……J=19。例如90转换为16进制数为5A（90=5\*16+10\*1）。

输入说明 :

程序需要输入多组数据，每组数据一行，每行有两个数，用空格隔开，分别表示十进制数和转换成的进制数。输入数据不会超过10000，例如：90 16 表示将90转换成16进制数。

输出说明 :

对于每行输入数据需输出一个结果。每个结果包含为一个20以内的进制的数。输出的字母都为大写字母。例如：90 16需输出结果5A。

输入范例 :

```
127 2 
90 16
```

输出范例 :

```
1111111
5A
```

根据题目描述，我们需要编写一个程序将十进制数转换为指定进制的数。下面是一个完成此任务的 C++ 程序示例：

```cpp
#include <iostream>
#include <string>
#include <stack>
using namespace std;

string DecimalToBase(int decimal, int base) {
    stack<char> digits;

    while (decimal > 0) {
        int remainder = decimal % base;
        char digit;
        if (remainder < 10) {
            digit = '0' + remainder;
        } else {
            digit = 'A' + remainder - 10;
        }
        digits.push(digit);
        decimal /= base;
    }

    string result;
    while (!digits.empty()) {
        result += digits.top();
        digits.pop();
    }

    return result;
}

int main() {
    int decimal, base;
    while (cin >> decimal >> base) {
        string result = DecimalToBase(decimal, base);
        cout << result << endl;
    }

    return 0;
}
```

上述代码中，我们定义了 `DecimalToBase()` 函数，它将十进制数 `decimal` 转换为指定进制 `base` 的数。在函数中，我们使用了一个栈 `digits` 来存储每个位上的数字或字母。然后，我们通过不断取余和除法的操作，将十进制数转换为指定进制。最后，我们将栈中的数字或字母依次弹出，构成最终的转换结果。

在 `main()` 函数中，我们循环读取输入的十进制数和进制数，并调用 `DecimalToBase()` 函数进行转换，并输出结果。

请将上述代码保存到一个名为 `main.cpp` 的文件中，并使用编译器进行编译和运行。然后，根据题目要求输入数据，程序将输出对应的转换结果。例如，对于输入示例 `127 2`，输出将为 `1111111`；对于输入示例 `90 16`，输出将为 `5A`。

### 构造序列（求助GPT）

问题描述 :

序列是在数学世界中一种非常有趣的数字现象，它通过某一规则来产生数字，使数字变得有趣、变幻无穷。很多数学家对序列这种事物产生了浓厚的兴趣，花了很多时间对其进行研究，明明就是其中的一位。一天，他又在研究一种新的序列产生规则，该序列的规则如下：

1） 第1轮，写出两个1，即11；

2） 第2轮，在它们中间插入2，成为121；

3） 第3轮，在上面数中每两个相邻的和为3的数之间插入3，成为13231；

4） 以此类推下去，第n轮，在第n-1轮的数字的基础上，每两个相邻的和为n的数之间插入n。

明明根据这个规则开始构造序列。开始还觉得容易，但是越到后面，明明发现构造序列的计算量越来越大，计算难度也越来越高，计算速度也越来越慢。于是，明明就求助于你这位程序设计专家，能否帮他写一个程序，构造出序列的前9项，然后当明明需要知道序列中的哪一项的时，你就把那一项的数字告诉明明。

明明的问题可以归结为：根据题目描述中所描述的序列产生规则构造序列的前9项，然后告诉你一个正整数n，要求你输出序列的第n项。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数n（1≤n≤9），代表之后所要求的序列的第n项的值。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数，即所要求的序列中那一项的数值，每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
3 
4 
5
```

输出范例 :

```
13231
1432341
15435253451
```

自己写的程序只能搞定n=3的结果。。。。

```cpp
#include <string>
using namespace std;

string seq(int n)
{
    if(n==1) return "11";
    if(n==2) return "121";
    if(n>=3)
    {
        string s=seq(n-1);
        for(int i=0;i<n-1;i++)
        {
            if((seq(n-1)[i]-'0')+(seq(n-1)[i+1]-'0')==n)
            {
                int j=i;
                if(i!=0) j++;
                s.insert(j+1,string(1,(char)(n+'0')));
                //s.push_back(seq(n-1)[i]);
                //s.push_back(n+'0');
                //s.push_back(seq(n-1)[i+1]);
            }
            //s.push_back(seq(n-1)[i+1]);
        }
        return s;
    }
}

int main() {
    int n;
    while (cin >> n) {
        string result=seq(n);
        cout<<result<<endl;
    }

    return 0;
}
```

这个问题需要使用递归的方式来解决。下面是一个C++的解决方案：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<string> sequence(10);

void generate_sequence() {
    sequence[1] = "11";
    for(int i = 2; i <= 9; ++i) {
        string tmp = "";
        for(int j = 0; j < sequence[i - 1].size(); ++j) {
            tmp += sequence[i - 1][j];
            if(j < sequence[i - 1].size() - 1 && sequence[i - 1][j] + sequence[i - 1][j + 1] - 2 * '0' == i)
                tmp += to_string(i);
        }
        sequence[i] = tmp;
    }
}

int main() {
    generate_sequence();

    int n;
    while(cin >> n) {
        cout << sequence[n] << endl;
    }

    return 0;
}
```

这段程序首先会生成一个全局变量`sequence`，这个变量是一个字符串的向量，用于存储生成的序列。然后，`generate_sequence`函数会被调用来生成前9个序列。

在`generate_sequence`函数中，我们首先设定序列的第一个元素为"11"。然后，对于每一个序列的元素，我们遍历前一个元素中的每一个字符。如果当前字符和下一个字符的和等于当前的序列号，我们就在这两个字符之间插入当前的序列号。

在`main`函数中，我们首先调用`generate_sequence`函数来生成序列。然后，我们读取输入，对于每一个输入的整数n，我们打印出序列的第n个元素。

能AC的简化版如下：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<string> sequence={"11","121","13231","1432341","15435253451","1654352534561","1765473572753745671","18765473857275837456781","19876594738579297583749567891"};

int main() {

    int n;
    while(cin >> n) {
        cout << sequence[n-1] << endl;
    }

    return 0;
}
```

### A == B ?

问题描述 :

给你两个非负实数A和B，如果A等于B，输出 "YES", 否则输出"NO"

输入说明 :

第一行N，表示有N组测试数据。

以下N行，每行两个非负实数 A和B。每个实数不超过1000位，且可能在前面和后面有0存在。

输出说明 :

对于每组测试数据，如果A和B相等则输出 "YES"， 否则输出 "NO"。

每组测试数据占一行，两组测试数据之间无空行。行首与行尾均无空格。

输入范例 :

```
2
100.0 00100
0100.1234576 00000000100.123457
```

输出范例：

```
YES
NO
```

```cpp
#include <iostream>
#include <string>
#include <sstream>

using namespace std;


int main()
{

    int n;
    cin>>n;
    while(n--)
    {
        string sa,sb;
        cin>>sa>>sb;
        stringstream geek(sa);
        double xa=0;
        geek>>xa;
        double xb=stod(sb);
        if(xa==xb) cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }

    return 0;
}
```

### 最长的单词

问题描述 :

明明刚开始学习英语的时候，对英语有浓厚的兴趣，但是随着时间的推移，英语单词量的增加，明明越来越觉得背单词是一件相当痛苦的事情。于是他想出各种各样的方法来增加背单词的乐趣。

这次他想出的方法是把所有要背的英语单词排成一行，找出其中最长的一个单词来先背，然后划去这个单词，在剩下的单词中再找出一个最长的单词来背，以此类推，直到把所有单词都背完。如果有多个长度相同的单词，则先背一行中靠前的那个单词。这样做的好处是：背到越后面，单词越短，越容易背，越能增加背单词的信心。

例如有这么一行单词： one two three four five 明明会首先挑出three来背，因为它是最长的一个单词，由5个字母组成；然后明明会选择four这个单词，虽然five这个单词的长度和four这个单词的长度一样，但是four在five的前面，所以明明会先背four这个单词，然后再背five，等明明把five这个单词背完以后，接着背one这个单词，最后背的是two这个单词。

但是在这样背单词之中，明明又发现了另一个问题，当要背非常多的单词时，寻找最长的单词会花很多时间，他想让你帮助他写一个程序，找出一行单词中最长的那个，节约明明背单词所花的时间，与此同时，明明希望你能告诉他这个英文单词有多少个字母组成，那他可以做到心里有数。

明明的问题可以归结为：在一行英文单词中，找出其中最长的单词（若有多个最长，找出第一个出现的），并输出这个单词的长度。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行包括许多个英语单词和空格，单词和单词之间可能有多个空格，每行的长度不会超过1000个字符。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果为一个整数和一个英语单词，整数表示该英文单词的长度，整数和单词之间用一个空格隔开。输出时，每组运算结果单独占一行，其行首和行尾都没有任何空格或其他任何字符，每组运算结果与其后一组运算结果之间没有任何空行或其他任何字符，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行或其他任何字符。 注：通常，显示屏为标准输出设备。

输入范例 :

```
a bc def ghijk lmn
abc def ghi
```

输出范例 :

```
5 ghijk
3 abc
```

```cpp
#include <iostream>
#include <string>
#include <cstdio>
#include <sstream>
using namespace std;


int main()
{

    string s;
    while (getline(cin, s))
    {
        stringstream ss;
        ss<<s;
        string p;

        int maxseq=0;
        string maxstring;
        while(ss>>p)
        {
            if(p.length()>maxseq)
            {
                maxseq=p.length();
                maxstring=p;
            }
        }
        cout<<maxseq<<" "<<maxstring<<endl;
    }

    return 0;
}
```

### 字符串对比

问题描述 :

给定两个仅由大写字母或小写字母组成的字符串(长度介于1到10之间)，它们之间的关系是以下4种情况之一：  

1：两个字符串长度不等。比如 Beijing 和 Hebei  

2：两个字符串不仅长度相等，而且相应位置上的字符完全一致(区分大小写)，比如 Beijing 和 Beijing  

3：两个字符串长度相等，相应位置上的字符仅在不区分大小写的前提下才能达到完全一致（也就是说，它并不满足情况2）。比如 beijing 和BEIjing  

4：两个字符串长度相等，但是即使是不区分大小写也不能使这两个字符串一致。比如 Beijing 和 Nanjing  

编程判断输入的两个字符串之间的关系属于这四类中的哪一类，给出所属的类的编号。

输入说明 :

包括两行，每行都是一个字符串

输出说明 :

仅有一个数字，表明这两个字符串的关系编号

输入范例 :

```
BEIjing
beiJing
```

输出范例 :3

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{

    string s1,s2;
    cin>>s1;
    cin>>s2;

    if(s1.length()!=s2.length())
        cout<<"1"<<endl;
    if(s1.length()==s2.length()&&s1==s2)
        cout<<"2"<<endl;
    if(s1.length()==s2.length()&&s1!=s2)
    {
        transform(s1.begin(),s1.end(),s1.begin(),::tolower);
        transform(s2.begin(),s2.end(),s2.begin(),::tolower);
        if(s1==s2)
            cout<<"3"<<endl;
        else
            cout<<"4"<<endl;
    }
    return 0;
}
```

### 幸运偶数

问题描述 :

从键盘上输入一个整数(长度不大于200)，将其各位上为奇数的数字去除，剩余的数字按数字大小从大到小排序，组成一个新的数，并输出到屏幕上。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据仅占一行，每行有一个整数，整数的长度不大于200。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的计算结果，并将这一组计算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。若全为奇数，输出结果为“None”。注：通常，显示屏为标准输出设备。

输入范例 :

```
276238496
13579
```

输出范例 :

```
866422
None
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;


int main()
{

    string s;
    while(cin>>s)
    {
        vector<int> nums;
        for(int i=0;i<s.length();i++)
        {
            if((s[i]-'0')%2==0)
                nums.push_back(s[i]-'0');
        }

        if(nums.size()==0)
            cout<<"None"<<endl;
        else
        {
            sort(nums.begin(),nums.end());
            for(int i=nums.size()-1;i>=0;i--)
                cout<<nums[i];
            cout<<endl;
        }
    }


    return 0;
}
```

### 单词统计

问题描述 :

从键盘上输入一个整数N，并输入N行字符串。每行字符串都包含多个单词，单词之间以空格分开。请输出每行字符串中单词的个数。

说明：以空格分隔开的任何字符串都认为是单词。比如“I'm”认为是一个单词

输入说明 :

首先输入一行，包含一个整数N，表示共测试N组数据。

后面接着输入N行，每行为一个字符串，字符串长度小于等于50。每个字符串中包含多个单词，单词之间以空格分隔。

输出说明 :

对每组测试数据，你的程序需要向标准输出文件（通常为启动该程序的终端）依次输出字符串中单词的个数。每个输出占一行，在行首和行尾不要输出多余的空格。在所有数据前后，以及两组数据之间不要输出多余的空行。

输入范例 :

```
3
i am a boy.
byebyetoyou
       haha   ,    meet        you   again!
```

输出范例 :

```
4
1
5
```

```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;


int main()
{

    string s;
    int n;
    cin>>n;
    getchar();
    while(n--)
    {
        getline(cin,s);
        stringstream ss;
        ss<<s;
        string p;
        int count=0;
        while(ss>>p)
        {
            count++;
        }
        cout<<count<<endl;
    }


    return 0;
}
```

## 7.3字符串->较难

### 网络警察

问题描述 :

作为一名网络警察，你的任务是监视电子邮件，看其中是否有一些敏感的关键词。不过，有些狡猾的犯罪嫌疑人会改变某些单词的字母顺序，以逃避检查。请编写一个程序，发现这种调整过顺序的关键词。

输入说明 :

输入有两行，第一行是关键词列表，第二行是待检查的句子。

单词全部为小写，单词之间以一个空格分隔，每一行的单词个数不限

输出说明 :

输出为在该句子中所找到的经过顺序调整的关键词

按照在关键词列表中的先后顺序输出

输入范例 :

```
missiles guns mines
aameric ssell snug dan iimsssle ot sit neeemis
```

输出范例 :

```
missiles guns
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <sstream>
using namespace std;

int main()
{
    string keyword,str,str2,word;
    vector<string> keywords;
    vector<string> keywords2;
    getline(cin,str);
    stringstream ss;
    ss<<str;
    while(ss>>keyword)
    {
        keywords.push_back(keyword);
        sort(keyword.begin(),keyword.end());
        keywords2.push_back(keyword);
    }
    getline(cin,str2);
    stringstream ss2;
    vector<string> texts;
    ss2<<str2;
    while(ss2>>word)
    {
        sort(word.begin(),word.end());
        texts.push_back(word);
    }
    bool IsFirst=true;
    for(int i=0;i<keywords2.size();i++)
    {
        for(int j=0;j<texts.size();j++)
        {
            if(keywords2[i]==texts[j])
            {
                if(IsFirst)
                {
                    cout<<keywords[i];
                    IsFirst=false;
                }
                else
                {
                    cout<<" "<<keywords[i];
                }
            }
        }
    }
    cout<<endl;
    return 0;
}
```

### 分割数字并排序

问题描述 :

输入一行数字，如果我们把这行数字中的‘5’都看成空格，那么就得到一行用空格分割的若干非负整数（可能有些整数以‘0’开头，这些头部的‘0’应该被忽略掉，除非这个整数就是由若干个‘0’组成的，这时这个整数就是0）。

你的任务是：对这些分割得到的整数，依从小到大的顺序排序输出。

输入说明 :

输入包含多组测试用例，第一行，测试案例个数，每组输入数据只有一行数字（数字之间没有空格），这行数字的长度不大于1000。  

输入数据保证：分割得到的非负整数不会大于100000000；输入数据不可能全由‘5’组成。

输出说明 :

对于每个测试用例，输出分割得到的整数排序的结果，相邻的两个整数之间用一个空格分开，每组输出占一行。

输入范例 :

```
2
0051231232050775
4000050005045453356356456454564567677686564654
```

输出范例 :

```
0 77 12312320
0 4 4 4 4 33 63 64 64 64 646 40000 67677686
```

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <sstream>
using namespace std;

int main()
{
    int n;
    cin>>n;
    for(int t=0;t<n;t++)
    {
        string str,s;
        bool IsFirst=true;
        vector<int> nums;
        cin>>str;
        for(int i=0;i<str.length();i++)
        {
            if(str[i]=='5')
                str[i]=(char)32;
        }
        stringstream ss;
        ss<<str;
        while(ss>>s)
        {
            nums.push_back(stoi(s));
        }
        sort(nums.begin(),nums.end());
        for(int j=0;j<nums.size();j++)
        {
            if(IsFirst)
            {
                cout<<nums[j];
                IsFirst=false;
            }
            else
            {
                cout<<" "<<nums[j];
            }
        }
        cout<<endl;
    }

    return 0;
}
```

如果不使用`getline(cin,str);`而是使用`cin>>str`，需要在输入n之后用`getchar();`读入一个空格

```cpp
#include <iostream>
#include <string>
#include <algorithm>
#include <sstream>
using namespace std;

int main()
{
    int n;
    cin>>n;
    getchar();
    for(int t=0;t<n;t++)
    {
        string str,s;
        bool IsFirst=true;
        vector<int> nums;
        getline(cin,str);
        for(int i=0;i<str.length();i++)
        {
            if(str[i]=='5')
                str[i]=(char)32;
        }
        stringstream ss;
        ss<<str;
        while(ss>>s)
        {
            nums.push_back(stoi(s));
        }
        sort(nums.begin(),nums.end());
        for(int j=0;j<nums.size();j++)
        {
            if(IsFirst)
            {
                cout<<nums[j];
                IsFirst=false;
            }
            else
            {
                cout<<" "<<nums[j];
            }
        }
        cout<<endl;
    }

    return 0;
}
```

### 16进制加法（求助GPT）

问题描述 :

某天、小晨在路上背着单词，突遇一外星人，外星人对小晨很感兴趣，为了考验小晨的智商，就向小晨提问简单加法，由于外星人使用16进制，所以，小晨必须用16进制回答。

输入说明 :

首先输入一个整数T，

以下T行，每行两个16进制数字

输出说明 :

T行，每行一个16进制数，为求出的两数之和。

其中的英文字母a到f为小写。

输入范例 :

```
2
4b0d 4887
2745 7438
```

输出范例 :

```
9394
9b7d
```

### 牧场安全系统

问题描述 :

明明是一家养牛场的老板，随着养牛场的规模扩大，牛的数量变得越来越多。因此，管理也就越来越难，还时常发生一些事故，比如：一些牛会走失，一些牛会因为疏忽照顾而生长不佳等等，这些都给明明造成了损失。于是，明明决定给养牛场安装一套现代化的生产管理系统，用科学的方法来管理养牛场，在这套安全系统中，需要为每头牛编一个号码，这个号码是唯一的，用来标识每一头牛。这样明明在管理时，就不会疏忽任意一头牛，也不会使牛再次走失。但是在给每头牛编号的时候，明明遇到了困难，由于系统的原因，系统对每头牛的编号有一定的限制，这个编号必须有L个小写字母组成，这些小写字母必须在固定的几个字母中选择，并且在这个编号中至少要有一个元音('a', 'e', 'i', 'o', 或者 'u')，至少有两个辅音(除去元音以外的音节), 并且字母按字母表顺序排列(例如，'abc'是有效的，而'bac'不是有效的)。 例如：假设编号由5个小写字母组成，且这些小写字母只能为a、b、c、d、e、f，这样构成的可能的编号就有以下6种： bcdef acdef abdef abcef abcdf abcde 明明觉得这样编号的方法非常麻烦，仅仅靠手工排列是很难完成的，出错的可能性很大，这时，明明想起了你，你是一位程序设计专家，你能否帮明明写一个程序，帮助他按照编号的规则，由程序生成所有的有效编号，供明明使用。 明明的问题可以归结为：给你一个有效编号的长度L，和C个可用的小写字母，按照编码规则生成所有的有效编号。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有二行，第一行为两个整数L(3≤L≤15)和C(3≤C≤26)，L表示编号的长度，C表示可以选择的小写字母的数量，L和C用一个空格隔开。第二行有C个两两不相同的小写字母，相互以一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果分为两个部分，第一部分为所有生成的有效编号，每行一个，按字母表逆序顺序输出，第二部分为一个整数，表示总共有多少个有效编码。 每组运算结果的行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
3 3
a b c
5 6
a b c d e f
```

输出范例 :

```
abc
1

bcdef
acdef
abdef
abcef
abcdf
abcde
6
```

### 牧场安全系统（求助GPT）

问题描述 :

明明是一家养牛场的老板，随着养牛场的规模扩大，牛的数量变得越来越多。因此，管理也就越来越难，还时常发生一些事故，比如：一些牛会走失，一些牛会因为疏忽照顾而生长不佳等等，这些都给明明造成了损失。于是，明明决定给养牛场安装一套现代化的生产管理系统，用科学的方法来管理养牛场，在这套安全系统中，需要为每头牛编一个号码，这个号码是唯一的，用来标识每一头牛。这样明明在管理时，就不会疏忽任意一头牛，也不会使牛再次走失。但是在给每头牛编号的时候，明明遇到了困难，由于系统的原因，系统对每头牛的编号有一定的限制，这个编号必须有L个小写字母组成，这些小写字母必须在固定的几个字母中选择，并且在这个编号中至少要有一个元音('a', 'e', 'i', 'o', 或者 'u')，至少有两个辅音(除去元音以外的音节), 并且字母按字母表顺序排列(例如，'abc'是有效的，而'bac'不是有效的)。 例如：假设编号由5个小写字母组成，且这些小写字母只能为a、b、c、d、e、f，这样构成的可能的编号就有以下6种： bcdef acdef abdef abcef abcdf abcde 明明觉得这样编号的方法非常麻烦，仅仅靠手工排列是很难完成的，出错的可能性很大，这时，明明想起了你，你是一位程序设计专家，你能否帮明明写一个程序，帮助他按照编号的规则，由程序生成所有的有效编号，供明明使用。 明明的问题可以归结为：给你一个有效编号的长度L，和C个可用的小写字母，按照编码规则生成所有的有效编号。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每组测试数据有二行，第一行为两个整数L(3≤L≤15)和C(3≤C≤26)，L表示编号的长度，C表示可以选择的小写字母的数量，L和C用一个空格隔开。第二行有C个两两不相同的小写字母，相互以一个空格隔开。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将这一组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。每组运算结果分为两个部分，第一部分为所有生成的有效编号，每行一个，按字母表逆序顺序输出，第二部分为一个整数，表示总共有多少个有效编码。 每组运算结果的行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间有一个空行，最后一组运算结果后面没有空行。 注：通常，显示屏为标准输出设备。

输入范例 :

```
3 3
a b c
5 6
a b c d e f
```

输出范例 :

```
abc
1

bcdef
acdef
abdef
abcef
abcdf
abcde
6
```

网上查到的能AC的代码如下：

```cpp
 
#include "bits/stdc++.h"
using namespace std;
char vowel[10]={'a','e','i','o','u'};
bool Qualified(string sernum){
int vonum=0;
bool flag=0;
string tmp=sernum;
for(int i=0;i<5;i++){
    char tmp=vowel[i];
    if(sernum.find(tmp)!=sernum.npos){//利用了一个元音字母不会出现两次的特性
        vonum++;
        flag=true;
    }
}
if(flag){
    flag=false;
    if(sernum.size()-vonum>=2){
        flag=true;
    }
}
if(flag)
{
    flag= false;
    sort(sernum.begin(),sernum.end());
    if(tmp==sernum)
        flag=true;
}
return flag;
}
void solve(string library,int L,int C,int &cot,string &res){
    string temp,tmp;
    tmp=res;
    int num=0;
    if(L==C)
    {
        tmp+=library;
        if(Qualified(tmp))
        {
            cout<<tmp<<endl;
            cot++;
        }
 
    } else {
        for (int i = L; i <= C; i++) {
            tmp = res;
            if (C - i >= 0 && C - i <= C - 1) {
                tmp += library.at(C - i);
                temp.assign(library.end() - i + 1, library.end());
                solve(temp, L - 1, i - 1, cot, tmp);
            } else {
                if (Qualified(tmp)) {
                    cout << tmp << endl;
                    cot++;
                }
                i=C;
            }
 
        }
    }
 
}
int main(){
    int L,C;
    while(cin>>L>>C){
char temp;
int cot=0,num=C;
string library,res;
while(num--){
    cin>>temp;
    library+=temp;
}
sort(library.begin(),library.end());
        solve(library,L,C,cot,res);
        cout<<cot<<endl;
    }
 
    return 0;
}
```

在GPT的修改自己上，自己修改的代码还有一个测试数据通过不了。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

bool isValidCode(const string& code) {
    int vowelCount = 0;
    int consonantCount = 0;
    bool hasVowel = false;
    bool hasConsonant = false;

    for (char c : code) {
        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {
            vowelCount++;
            hasVowel = true;
        } else {
            consonantCount++;
            hasConsonant = true;
        }
    }

    return vowelCount >= 1 && consonantCount >= 2 && hasVowel && hasConsonant;
}

void generateCodes(vector<string>& codes, string library, int L, int C, string code) {
    if (code.length() == L) {
        if (isValidCode(code)) {
            codes.push_back(code);
        }
        return;
    }

    if (C == 0) {
        return;
    }

    generateCodes(codes, library, L, C - 1, code);
    generateCodes(codes, library, L, C - 1, code + library[C - 1]);
}

int main() {
    int L, C;
    while (cin >> L >> C) {
        string library;
        for (int i = 0; i < C; i++) {
            char temp;
            cin >> temp;
            library += temp;
        }

        sort(library.begin(), library.end());

        vector<string> codes;

        generateCodes(codes, library, L, C, "");

        for (int i=codes.size()-1;i>=0;i--) {
                sort(codes[i].begin(), codes[i].end());
                cout << codes[i] << endl;
        }

        cout << codes.size() << endl;
    }

    return 0;
}
```

```
4 6
a b c d e f
```

正确结果：

```
cdef
bdef
bcef
bcde
adef
acef
acdf
acde
abef
abdf
abde
abcf
abce
abcd
14
```

错误输出：

```
cdef
bdef
adef
bcef
acef
abef
acdf
abdf
abcf
bcde
acde
abde
abce
abcd
14
```

首先，我们明确下程序的目标：我们需要确保每个有效的编号包含至少一个元音和至少两个辅音，并且所有的字母都必须按照字母表的顺序排列。在下面的代码中，我们将通过添加适当的检查条件来完成这个目标。

这是GPT4修改后的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

// 这个函数检查一个字符是否是元音
bool is_vowel(char c) {
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}

// 这个函数检查一个字符串是否符合我们的要求
bool is_valid(const string &s) {
    int vowels = 0, consonants = 0;
    for (char c : s) {
        if (is_vowel(c)) vowels++;
        else consonants++;
    }
    return vowels >= 1 && consonants >= 2;
}

// 这个函数生成所有可能的组合并检查它们是否有效
void solve(const string &alphabet, string prefix, int L, int &count) {
    // 如果前缀的长度等于L，我们检查它是否有效，并可能打印它
    if (prefix.size() == L) {
        if (is_valid(prefix)) {
            cout << prefix << "\n";
            count++;
        }
    } 
    else {
        // 对于每个尚未使用的字符，我们添加它到前缀并递归地继续搜索
        for (int i = 0; i < alphabet.size(); i++) {
            // 但是，我们只添加字母表中的下一个字符，以确保按字母表顺序
            if (!prefix.empty() && alphabet[i] <= prefix.back()) continue;
            solve(alphabet, prefix + alphabet[i], L, count);
        }
    }
}

int main() {
    int L, C;
    while (cin >> L >> C) {
        string alphabet;
        for (int i = 0; i < C; i++) {
            char c;
            cin >> c;
            alphabet.push_back(c);
        }
        // 我们需要确保字母表是排序的
        sort(alphabet.begin(), alphabet.end());

        int count = 0;
        solve(alphabet, "", L, count);
        cout << count << "\n";
    }
    return 0;
}
```

这个程序首先读取L和C的值，然后读取C个字母并将它们存储在一个字符串中。然后，它调用solve函数来生成所有可能的组合，并检查它们是否符合我们的要求（至少一个元音和至少两个辅音，并且所有字母必须按照字母表顺序排列）。如果一个组合符合要求，该程序将打印它并增加总数。最后，它打印了总数。

GPT4给出的代码仍旧不能用，在此基础上改进的能AC的代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

// 这个函数检查一个字符是否是元音
bool is_vowel(char c) {
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}

// 这个函数检查一个字符串是否符合我们的要求
bool is_valid(const string &s) {
    int vowels = 0, consonants = 0;
    for (char c : s) {
        if (is_vowel(c)) vowels++;
        else consonants++;
    }
    return vowels >= 1 && consonants >= 2;
}
vector<string> result;
// 这个函数生成所有可能的组合并检查它们是否有效
void solve(const string &alphabet, string prefix, int L, int &count) {
    // 如果前缀的长度等于L，我们检查它是否有效，并可能打印它

    if (prefix.size() == L) {
        if (is_valid(prefix)) {
            result.push_back(prefix);
            //cout<<prefix<<endl;
            count++;
        }
    }
    else {
        // 对于每个尚未使用的字符，我们添加它到前缀并递归地继续搜索
        for (int i = 0; i < alphabet.size(); i++) {
            // 但是，我们只添加字母表中的下一个字符，以确保按字母表顺序
            if (!prefix.empty() && alphabet[i] <= prefix.back()) continue;
            solve(alphabet, prefix + alphabet[i], L, count);
        }
    }
}

int main() {
    int L, C;
    while (cin >> L >> C) {
        string alphabet;
        for (int i = 0; i < C; i++) {
            char c;
            cin >> c;
            alphabet.push_back(c);
        }
        // 我们需要确保字母表是排序的
        sort(alphabet.begin(), alphabet.end());

        int count = 0;
        //vector<string> codes;
        solve(alphabet, "", L, count);
        for (int i=result.size()-1;i>=0;i--) {
                cout << result[i] << endl;
        }
        cout << count << "\n";
    }
    return 0;
}
```

### 笨小猴

问题描述 :

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！  这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。

样例输入

error

样例输出

Lucky Word  
2

样例说明

单词error中出现最多的字母r出现了3次，出现次数最少的字母出现了1次，3-1=2，2是质数。

样例输入

olympic

样例输出

No Answer  
0

样例说明

单词olympic中所有字母都只出现了1次，1-1=0，0不是质数。

输入说明 :

输入文件只有一行，是一个单词，其中只可能出现小写字母，并且长度小于100。

输出说明 :

输出文件共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出0。

输入范例 :`error`

输出范例 :

```
Lucky Word
2
```

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <cmath>
using namespace std;

bool IsPrime(int n)
{
    if(n<=1) return false;
    if(n==2) return true;
    if(n%2==0) return false;
    if(n>=3)
    {
        for(int i=3;i<=sqrt(n);i+=2)
        {
            if(n%i==0)
                return false;
        }
    }
    return true;
}
int main()
{
    string s;
    cin>>s;
    vector<char> ch;
    int maxn=0,minn=0;
    for(int i=0;i<s.length();i++)
    {
        bool IsFirst=true;
        for(int j=0;j<ch.size();j++)
        {
            if(s[i]==ch[j])
            {
                IsFirst=false;
            }
        }
        if(IsFirst)
            ch.push_back(s[i]);
    }
    vector<int> nums(ch.size(),0);
    for(int i=0;i<s.length();i++)
    {
        for(int j=0;j<ch.size();j++)
        {
            if(s[i]==ch[j])
            {
                nums[j]++;
            }
        }
    }
    maxn=nums[0];
    minn=nums[0];
    for(int j=0;j<nums.size();j++)
    {

        if(nums[j]>maxn)
            maxn=nums[j];
        if(nums[j]<minn)
            minn=nums[j];
    }
    if(IsPrime(maxn-minn))
        cout<<"Lucky Word"<<endl<<(maxn-minn)<<endl;
    else
        cout<<"No Answer"<<endl<<0<<endl;
    return 0;
}
```

### 表达式求值

问题描述 :

以字符串形式输入仅有整数和加减（正负）号构成的表达式，输出该表达式的值。

输入说明 :

标准输入设备中有多组测试数据，每组输入数据由一行组成，输入仅有整数和加减（正负）号构成的表达式（但是表达式可以插入空格）。

输出说明 :

依次输出从标准输入设备中读入的每一组测试数据对应的结果，输出一行，输出该表达式的值。所有数据前后没有多余的空格，两组数据之间也没有多余的空行。

输入范例 :

```
3+    4+  5+6
  0+1
```

输出范例 :

```
18
1
```

```cpp
#include <iostream>
#include <sstream>

using namespace std;

int calculateSum(const string& expression) {
    stringstream ss(expression);
    int sum = 0;
    int num;
    char op;

    // 从流中读取数字和操作符，并进行计算
    ss >> num;
    sum = num;
    while (ss >> op >> num) {
        if (op == '+')
            sum += num;
        if (op == '-')
            sum -= num;
    }

    return sum;
}

int main() {
    string expression;
    while (getline(cin, expression)) {
        int sum = calculateSum(expression);
        cout << sum << endl;
    }

    return 0;
}
```

### 乒乓球（求助GPT失败&&求助网络）

问题描述 :

国际乒联主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中11分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。明明就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白11分制和21分制对选手的不同影响。在开展他的研究之前，明明首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。 （注：11（21）分制，在一局比赛中，选手A先得到11（21）分且此时领先选手B 2分或2分以上时，则选手A赢得此局；若当双方打成10（20）平后，则先多得2分的一方为胜方，赢得此局。） 

明明通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在11分制和21分制下，双方的比赛结果（截至记录末尾）。一局比赛的开始比分为0比0。 比如现在有这么一份记录，（其中W表示明明获得一分，L表示明明的对手获得一分）：

WWWWWWWWWWWWWWWWWWWWWWLW 

在11分制下，此时比赛的结果是明明第一局11比0获胜，第二局11比0获胜，正在进行第三局，当前比分1比1。 

在21分制下，此时比赛结果是明明第一局21比0获胜，正在进行第二局，当前比分2比1。 

再如有这么一份记录，（其中W表示明明获得一分，L表示明明的对手获得一分）： 

WLWLWLWLWLWLWLWLWLWLWLWLWL 

在11分制下，此时比赛的结果是明明和对手打成13比13，这局比赛仍没有分出胜负，因为任何一方都没有领先其对手2分。 

在21分制下，此时比赛的结果是明明和对手打成13比13，这局比赛仍在进行中。 

由于明明参加过多年的比赛，比赛的数据量相当庞大，如果仅仅使用手工统计，在短时间内统计出结果对于明明来说是相当困难的。因此明明求助于你，希望你能写一个程序，帮助他快速地统计出结果来。 

明明的问题可以归结为：给你一系列的比赛数据（WL形式），分别按照11分制和21分制的比赛规则进行统计，然后输出统计结果。

输入说明 :

你写的程序要求从标准输入设备中读入测试数据作为你所写程序的输入数据。标准输入设备中有多组测试数据，每行包括一串有W、L和E组成比赛结果，其中W表示明明得一分，L表示明明的对手得一分，E表示该组测试数据的结束，也就是说E后面的W、L应该忽略，无需处理。每行的长度不会超过30个字符。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序要求计算出一组相应的运算结果，并将每组运算结果作为你所写程序的输出数据依次写入到标准输出设备中。

每组运算结果由两部分组成，其中第一部分是11分制下的结果，第二部分是21分制下的结果，两部分之间由一个空行分隔。

每部分由若干行组成，每一行对应一局比赛的比分（按比赛信息输入顺序），每局的比分按如下形式表示：m:n，其中m表示明明的得分，n表示明明的对手的得分，m、n之间用一个冒号隔开。

输出时，每组运算结果与其后一组运算结果之间有一个空行，第一组运算结果前面以及最后一组运算结果后面没有任何空行或其他任何字符。 注：通常，显示屏为标准输出设备。

输入范例 :

```
WWWWWWWWWWLLLLLLLLLLL
WWWWWWWWWLLLLLLLLLE
LLLLLLLLLLLLLLLLLE
```

输出范例 :

```
13:11
6:9

19:20

0:11
0:6

0:17
```

自己写的程序运行出错：

```cpp
#include <iostream>
#include <sstream>

using namespace std;

int main()
{
    string s;
    char ch;
    bool IsFirst=true;
    while(ch=(char)(cin.get())&&ch!='E')
    {
        if(!IsFirst)
            cout<<endl;
        s+=ch;
        int count_ming11=0,count_ming21=0;
        int count_c11=0,count_c21=0;
        for(int i=0;s[i]!='E';i++)
        {
            if(s[i]=='W')
            {
                count_ming11++;
                count_ming21++;
            }
            else
            {
                count_c11++;
                count_c21++;
            }
        }
        cout<<count_ming11<<" "<<count_c11<<endl;
        cout<<count_ming21<<" "<<count_c21<<endl;
        IsFirst=false;

    }
    return 0;
}
```

我这个程序为什么会自动终止呢？

这个程序自动终止的原因是因为在 `while` 循环的条件判断中，你使用了错误的运算符优先级。

以下是引起问题的代码：

```cpp
while(ch=(char)(cin.get())&&ch!='E')
```

在这行代码中，你使用了赋值运算符 `=` 和逻辑与运算符 `&&`。然而，赋值运算符的优先级比逻辑与运算符低，所以会先执行赋值操作，而不是将其作为条件判断的一部分。

因此，这行代码实际上等价于：

```cpp
while(ch = ((char)(cin.get()) && ch != 'E'))
```

这里，`cin.get()` 读取输入的字符并返回，然后将其强制转换为 `char` 类型，并与 `ch != 'E'` 进行逻辑与运算。这样，`ch` 的值将被赋予结果，而不是与 `'E'` 进行比较。

为了修复这个问题，你可以使用括号来明确指定运算符的优先级，确保条件判断正确执行。以下是修改后的代码：

```cpp
while((ch = (char)(cin.get())) && ch != 'E')
```

在这行代码中，我们使用括号明确指定了赋值运算符的优先级，确保 `ch` 的值先被赋予输入字符，然后再与 `'E'` 进行比较。

关于读入下面的数据：

```
WWWWWWWWWWLLLLLLLLLLL
WWWWWWWWWLLLLLLLLLE
LLLLLLLLLLLLLLLLLE
```

你可以通过在终端中逐行输入数据，以回车键结束每行的输入。这样，每次调用 `cin.get()` 时，它会读取一行的字符，直到遇到回车键。然后，你可以输入下一行的字符。

希望这个解答对你有帮助。如果还有其他问题，请随时提问。

根据题目描述，你需要编写一个程序来统计给定比赛数据在11分制和21分制下的比赛结果。

下面是一个可能的解决方案：

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 统计比赛结果
void calculateResults(const string& record) {
    vector<pair<int, int>> scores_11; // 11分制下的比分
    vector<pair<int, int>> scores_21; // 21分制下的比分
    int score_ming_11 = 0; // 11分制下明明的得分
    int score_ming_21 = 0; // 21分制下明明的得分
    int score_opponent_11 = 0; // 11分制下对手的得分
    int score_opponent_21 = 0; // 21分制下对手的得分

    // 遍历比赛记录
    for (char ch : record) {
        if (ch == 'W') {
            score_ming_11++; // 明明得分
            score_ming_21++;
        } else if (ch == 'L') {
            score_opponent_11++; // 对手得分
            score_opponent_21++;
        }

        // 判断11分制下是否出现胜负
        if (score_ming_11 >= 11 && score_ming_11 - score_opponent_11 >= 2) {
            scores_11.emplace_back(score_ming_11, score_opponent_11); // 添加比分
            score_ming_11 = 0; // 重置得分
            score_opponent_11 = 0;
        }

        // 判断21分制下是否出现胜负
        if (score_ming_21 >= 21 && score_ming_21 - score_opponent_21 >= 2) {
            scores_21.emplace_back(score_ming_21, score_opponent_21); // 添加比分
            score_ming_21 = 0; // 重置得分
            score_opponent_21 = 0;
        }
    }

    // 输出11分制下的比赛结果
    for (const auto& score : scores_11) {
        cout << score.first << ":" << score.second << endl;
    }
    cout << endl;

    // 输出21分制下的比赛结果
    for (const auto& score : scores_21) {
        cout << score.first << ":" << score.second << endl;
    }
    cout << endl;
}

int main() {
    string record;
    while (getline(cin, record)) {
        if (record.find('E') != string::npos) {
            break; // 遇到结束符号E，结束输入
        }
        calculateResults(record);
    }

    return 0;
}
```

这个程序会不断读取输入数据，直到遇到结束符号E。然后，它会调用 `calculateResults` 函数来计算给定比赛数据在11分制和21分制下的比赛结果，并将结果输出到标准输出设备。

希望这个解决方案对你有帮助。如果你有任何其他问题，请随时提问。

网上找到的能AC的程序：

```c
#include <stdio.h>
#include <stdlib.h>

/* run this program using the console pauser or add your own getch, system("pause") or input loop */

void regulation(char temp[],int len,int rule) {
	int m=0,n=0,i;
	for(i=0;i<len;i++) {
		if(temp[i]=='W') {
			m++;
		} else if(temp[i]=='L'){
			n++;
		}
		if((m>=rule||n>=rule)&&(m-n>=2||n-m>=2)) {
			printf("%d:%d\n",m,n);
			m=0;
			n=0;
		}
	}
	if(m!=0||n!=0)
		printf("%d:%d\n",m,n);
}



int main(int argc, char *argv[]) {
	char temp[300];
	int i;
	while(scanf("%c",&temp[0])!=EOF) {
		i=1;
		while(1) {
			scanf("%c",&temp[i]);
			if(temp[i]=='E') {
				break;
			}
			++i;
		}

		regulation(temp,i+1,11);
		printf("\n");
		regulation(temp,i+1,21);
		printf("\n");


	}
	return 0;
}

```

修改后如下：

```cpp
#include <iostream>
#include <string>
#include <cstdlib>
#include <vector>
using namespace std;

void regulation(const string& temp, int& len, int rule) {
    int m = 0, n = 0;
    for (int i = 0; i < len; i++) {
        if (temp[i] == 'W') {
            m++;
        } else if (temp[i] == 'L') {
            n++;
        }
        if ((m >= rule || n >= rule) && (m - n >= 2 || n - m >= 2)) {
            cout << m << ":" << n << endl;
            m = 0;
            n = 0;
        }
    }
    if (m != 0 || n != 0) {
        cout << m << ":" << n << endl;
    }
}

int main() {

    string str,s;
	vector<int> lens;
	while(getline(cin,s))
    {
        str+=s;
    }
    int e=0;
    vector<int> idx;
    for(int i=0;i<str.length();i++)
    {
        if(str[i]=='E')
        {
            e++;
            idx.push_back(i);
        }
    }
    int count=0;
    for(int i=0;i<str.length();i++)
    {
        if(str[i]!='E')
          {
              count++;
          }
        else
        {
            lens.push_back(count);
            count=0;
        }
    }
    vector<string> sss;
    int ee=0;
    while(ee!=e)
    {
        int i;
        string str1;
        for(i=0;str[i]!='E';i++)
        {
            str1+=str[i];
        }
        sss.push_back(str1);
        ee++;
        if(ee==e)
            break;
        str=str.substr(i+1,lens[e]-1);
    }
    for(int j=0;j<lens.size();j++)
    {
        regulation(sss[j], lens[j], 11);
        cout << endl;
        regulation(sss[j], lens[j], 21);
        cout << endl;
    }


    return 0;
}
```

### 你要乘坐的飞碟在这里

问题描述 :

一个众所周知的事实，在每一颗慧星后面是一个不明飞行物UFO。 这些不明飞行物时常来收集来自在地球上忠诚的支持者。 不幸地，他们的空间在每次旅行只能带上一群支持者。 他们要做的是用一种聪明的方案选择哪个团体被慧星带走。他们为每个慧星起了一个名字，通过这些名字来决定一个团体是不是特定的慧星带走。 

那个相配方案的细节在下面被给出， 你的工作要写一个程序来通过团体的名字和彗星的名字来决定他们是否匹配。

团体的名字和慧星的名字都以这种方式转换成一个数字: 

首先将名字中的每一个字母转换成数字， A转换成1，B转换成2...... Z转换成26。然后将一个名字中所有字母（转换得到的数字）相乘得到结果。

举例来说，彗星“ABC”对应的结果会是1\*2\*3=6，团体“USACO” 会是 21\*19\*1\*3\*15=17955 。 

如果团体的数字 mod 47 等于慧星的数字 mod 47,那么他们是匹配的，这个团体将会被带走 ! 

写一个程序读入慧星的名字和团体的名字，如果匹配则输出GO否则输出STAY。

团体的名字和慧星的名字将会是没有空格或标点的一串大写字母（不超过6个字母）

输入说明 :

第 1 行: 彗星的名字（一个长度为1到6的字符串） 第 2 行: 团体的名字（一个长度为1到6的字符串）

名字中没有空格或标点，且仅包含大写字母。

输出说明 :

单独一行包含STAY 或 GO

输入范例 :

```
COMETQ
HVNGAT
```

输出范例 :

```
GO
```

```cpp
#include <iostream>
#include <string>
using namespace std;

bool IsGo(string s1,string s2)
{
    int sum1=1,sum2=1;
    for(int i=0;i<s1.length();i++)
    {
        sum1*=(s1[i]-'A'+1);
    }
    for(int i=0;i<s2.length();i++)
    {
        sum2*=(s2[i]-'A'+1);
    }
    if(sum1%47==sum2%47)
        return true;
    else
        return false;
}

int main() {
    string s1,s2;
    cin>>s1>>s2;
    if(IsGo(s1,s2))
        cout<<"GO"<<endl;
    else
        cout<<"STAY"<<endl;
    return 0;
}
```

### 身份证排序

问题描述 :

安全局搜索到了一批(n个)身份证号码，希望按出生日期对它们进行从大到小排序，如果有相同日期，则按身份证号码从大到小进行排序。身份证号码为18位的数字组成，出生日期为第7到第14位

输入说明 :

第一行一个整数n，表示有n个身份证号码  

余下的n行，每行一个身份证号码。

n<=100000

输出说明 :

按出生日期从大到小排序后的身份证号，每行一条

输入范例 :

```
5
466272307503271156
215856472207097978
234804580401078365
404475727700034980
710351408803093165
```

输出范例 :

```
404475727700034980
234804580401078365
215856472207097978
710351408803093165
466272307503271156
```

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

bool cmp(string s1,string s2)
{
    if(s1.substr(6,8)!=s2.substr(6,8))
        return s1.substr(6,8)>s2.substr(6,8);
    if(s1!=s2)
        return s1>s2;
}

int main() {
    string s1;
    int N;
    cin>>N;
    vector<string> str;
    while(cin>>s1)
        str.push_back(s1);
    sort(str.begin(),str.end(),cmp);
    for(int i=0;i<str.size();i++)
        cout<<str[i]<<endl;
    return 0;
}
```

### 不同单词个数统计

问题描述 :

编写一个程序，输入一个句子，然后统计出这个句子当中不同的单词个数。例如：对于句子“one little two little three little boys”，总共有5个不同的单词：one, little, two, three, boys。  

说明：（1）输入的句子当中只包含英文字符和空格，单词之间用一个空格隔开；（2）不用考虑单词的大小写，假设输入的都是小写字符；（3）句子长度不超过100个字符。

输入说明 :

输入只有一行，即一个英文句子。

输出说明 :

输出只有一行，是一个整数，表示句子中不同单词的个数。

输入范例 :

```
one little two little three little boys
```

输出范例 :5

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std;

bool cmp(string s1,string s2)
{
    if(s1.substr(6,8)!=s2.substr(6,8))
        return s1.substr(6,8)>s2.substr(6,8);
    if(s1!=s2)
        return s1>s2;
}

int main()
{
    string expression,s1;
    getline(cin,expression);
    stringstream ss;
    ss<<expression;
    vector<string> str,str2;
    while(ss>>s1)
        str.push_back(s1);

    for(int i=0;i<str.size();i++)
    {
        bool Isin=false;
        for(int j=0;j<str2.size();j++)
        {
            if(str[i]==str2[j])
            {
                Isin=true;
                break;
            }
        }
        if(!Isin)
            str2.push_back(str[i]);
    }
    cout<<str2.size()<<endl;
    return 0;
}
```

### 纯粹合数

问题描述 :

明明的爸爸是一位数学家，明明受他爸爸的影响从小就喜欢数学，经常向他爸爸学习或请教数学问题。

一天，明明问他爸爸什么是合数，明明的爸爸回答说：“首先，合数都是大于1的整数，其次合数是除了1和其本身外，还能被至少一个其他自然数整除的数，例如‘4’这个数，它除了能被1和4整除外，还能被2整除，因此‘4’就是合数；但是‘3’就不是合数，因为3只能被1和3这两个数整除，因此‘3’不是合数。”

聪明的明明很快就理解了他爸爸的意思，于是又接着问他爸爸：“那什么又是纯粹合数呢？”明明的爸爸接着回答说：“一个合数，去掉最高位，剩下的数是0或仍是合数；再去掉剩下的数的最高位，剩下的数还是0或合数；这样反复，一直到最后剩下的一位数仍为0或合数；我们把这样的数称为纯粹合数。

例如‘100’这个数，它能被1、2、4、5、10、20、50、100整除，因此100是个合数，我们去掉它的最高位，剩下的数是0（其实剩下的应该是00，但是前置0对一个整数来说没有意义，因此前置0被舍去，就剩下个位数上的0），因此‘100’是一个纯粹合数。有趣的是，100是最小的一个三位纯粹合数。

再例如‘104’这个数，104能被1、2、8、13、26、52、104整除，所以104是个合数；我们去掉它的最高位后剩下4，4能被1、2、4整除，所以4也是合数，所以‘104’是一个纯粹合数。

但是‘101’就不是纯粹合数，因为‘101’只能被1和101这两个数整除。”

明明对他爸爸的回答很满意，于是自己动手从100开始寻找纯粹合数，他一共找到了100个纯粹合数，调皮的明明开始反过来考爸爸了，问他爸爸能否告诉他第2个大于等于100的纯粹合数是哪个？第3个大于等于100的纯粹合数又是哪个？……明明的爸爸被这个突如其来的问题给难住了，他无法立刻回答出来，于是请求你的帮助，帮助他回答明明的这个问题。

明明的问题可以归结为：根据一个正整数n，求出从100开始从小到大的第n个纯粹合数。

输入说明 :

你写的程序需要从标准输入设备（通常为键盘）中读入多组测试数据，每组测试数据仅占一行，每行仅包括一个正整数n（1 ≤ n ≤ 100）。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

对于每一组测试数据，你写的程序需要计算出一组相应的运算结果，并将每组运算结果依次写入到标准输出设备（通常为启动该程序的文本终端，例如Windows中的命令行终端）中。每组运算结果为一个整数，即从100开始从小到大的第n个纯粹合数。每组运算结果单独形成一行数据，其行首和行尾都没有任何空格，每组运算结果与其后一组运算结果之间没有任何空行，第一组运算结果前面以及最后一组运算结果后面也都没有任何空行。

输入范例 :

```
10
2
1
```

输出范例 :

```
124
104
100
```

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <sstream>
#include <cmath>
using namespace std;

bool isComposite(int num) {
    if (num < 4)
        return false;
    if (num % 2 == 0)
        return true;

    int sqrtNum = sqrt(num);
    for (int i = 3; i <= sqrtNum; i += 2) {
        if (num % i == 0)
            return true;
    }

    return false;
}


int main()
{
    int N;
    vector<int> nums;
    for(int i=100;i<2000;i++)
    {
        if(isComposite(i)&&(isComposite(i%10000)||(i%10000==0))&&(isComposite(i%1000)||(i%1000==0))&&(isComposite(i%100)||(i%100==0))&&(isComposite(i%10)||(i%10==0)))
        {
            nums.push_back(i);
        }
    }
    while(cin>>N)
    {
        cout<<nums[N-1]<<endl;
    }
    return 0;
}
```

### 字串统计（求助GPT）

问题描述 :

给定一个长度为n的字符串S，还有一个数字L，统计长度大于等于L的出现次数最多的子串（不同的出现可以相交），如果有多个，输出最长的，如果仍然有多个，输出第一次出现最早的。

输入说明 :

第一行一个数字L。  

第二行是字符串S。  

L大于0，且不超过S的长度。

n<=60  

S中所有字符都是小写英文字母。

输出说明 :

一行，题目要求的字符串。  
  
输入样例1：  

4  

bbaabbaaaaa  
  
输出样例1：  

bbaa  
  
输入样例2：  

2  

bbaabbaaaaa  
  
输出样例2：  

aa

输入范例 :

```
4
bbaabbaaaaa
```

输出范例 :

```
bbaa
```

```cpp
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

string findMostFrequentSubstring(const string& S, int L) {
    unordered_map<string, int> substrCount; // 存储子串出现次数
    int maxCount = 0; // 最大出现次数
    string mostFrequentSubstr; // 最频繁出现的子串

    // 遍历字符串S，统计子串出现次数
    for (int i = 0; i <= S.length() - L; i++) {
        for (int j = i + L; j <= S.length(); j++) {
            string substr = S.substr(i, j - i); // 提取子串
            substrCount[substr]++; // 子串出现次数加1
            if (substrCount[substr] > maxCount ||
                (substrCount[substr] == maxCount && substr.length() > mostFrequentSubstr.length())) {
                maxCount = substrCount[substr]; // 更新最大出现次数
                mostFrequentSubstr = substr; // 更新最频繁出现的子串
            }
        }
    }

    return mostFrequentSubstr;
}

int main() {
    int L;
    string S;

    cin >> L; // 输入L
    cin >> S; // 输入S

    string result = findMostFrequentSubstring(S, L); // 寻找最频繁的子串

    cout << result << endl; // 输出结果

    return 0;
}
```

### 字符串压缩（求助GPT）

问题描述 :

通过键盘输入字母(A-Z、a-z)组成的字符串，字符串长度不超过1000。首先将所有字母统一成小写字母，然后将字符串中连续出现的重复字母进行压缩，并输出压缩后的字符串。

压缩规则：

1、仅压缩连续重复出现的字符。比如字符串"abcbc"由于无连续重复字符，压缩后的字符串还是"abcbc"。

2、压缩字段的格式为"字符重复的次数+字符"。例如：字符串"xxxyyyyyyz"压缩后就成为"3x6yz"。

输入说明 :

你写的程序需要从标准输入设备（通常为键盘）中读入多组测试数据，每组测试数据仅占一行，每行仅包括字母(A-Z、a-z)组成的字符串。每组测试数据与其后一组测试数据之间没有任何空行，第一组测试数据前面以及最后一组测试数据后面也都没有任何空行。

输出说明 :

将处理后的字符串输出，行首与行尾无空格，也不输出多余空行。

输入范例 :

```
cCDeCC
cccccc
```

输出范例 :

```
2cde2c
6c
```

```cpp
#include <iostream>
#include <string>

using namespace std;

string compressString(const string& str) {
    string compressedStr; // 压缩后的字符串

    int count = 1; // 连续重复字符的计数器
    for (int i = 0; i < str.length(); i++) {
        if (i + 1 < str.length() && str[i] == str[i + 1]) {
            count++; // 字符连续重复，计数器加1
        } else {
            if (count > 1) {
                compressedStr += to_string(count); // 压缩字段的重复次数
            }
            compressedStr += str[i]; // 压缩字段的字符
            count = 1; // 重置计数器
        }
    }

    return compressedStr;
}

int main() {
    string input;
    while (cin >> input) {
        // 将字符串转为小写
        for (int i = 0; i < input.length(); i++) {
            input[i] = tolower(input[i]);
        }

        string compressed = compressString(input); // 压缩字符串
        cout << compressed << endl; // 输出压缩后的字符串
    }

    return 0;
}
```

### 数字密码发生器（求助GPT）

问题描述 :

在对银行账户等重要权限设置密码的时候，我们常常遇到这样的烦恼：如果为了好记用生日吧，容易被破解，不安全；如果设置不好记的密码，又担心自己也会忘记；如果写在纸上，担心纸张被别人发现或弄丢了...

这个程序的任务就是把一串拼音字母转换为6位数字（密码）。我们可以使用任何好记的拼音串(比如名字，王喜明，就写：wangximing)作为输入，程序输出6位数字。

变换的过程如下：

第一步. 如果字符串长度超过6，则把字符串6个一组折叠起来并左对齐，比如wangximing则变为：

wangxi
ming 

注意：左对齐后，ming的右边无任何字符，可认为都是字符'\0'。

第二步. 把所有垂直在同一个位置的字符的ascii码值相加，得出6个数字，如上面的例子，则得出：

228 202 220 206 120 105

第三步. 再把每个数字“缩位”处理：就是把每个位上的数字相加，得出的数字如果不是一位数，就再缩位，直到变成一位数字为止。例如: 228 => 2+2+8=12 => 1+2=3

上面的数字缩位后变为：344836, 这就是程序最终的输出结果！

输入说明 :

程序从标准输入接收数据，第一行是一个整数n（<100），表示下边有多少输入行，接下来是n行字符串（每个字符串长度<100），就是等待变换的字符串。

输出说明 :

在标准输出上输出结果，输出n行，每行都包含一个变换后的6位密码，无多余空格或空行。

输入范例 :

```
2
zhangfeng
wangximing
```

输出范例 :

```
772243
344836
```

非常抱歉，我之前的回答依然没有正确解决问题。感谢你的指正。以下是经过修正的代码：

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

vector<int> foldAndSum(const string& str) {
    vector<int> result(6, 0); // 存储结果的向量

    int index = 0; // 当前处理的字符索引
    int group = str.length() / 6; // 字符串分组数
    int remainder = str.length() % 6; // 分组后的余数

    for (int i = 0; i < group; i++) {
        for (int j = 0; j < 6; j++) {
            result[j] += str[index];
            index++;
        }
    }

    if (remainder > 0) {
        for (int i = 0; i < remainder; i++) {
            result[i] += str[index];
            index++;
        }
    }

    return result;
}

int reduceToOneDigit(int num) {
    while (num >= 10) {
        int sum = 0;
        while (num > 0) {
            sum += num % 10; // 将数字的每一位相加
            num /= 10;
        }
        num = sum;
    }
    return num;
}

int main() {
    int n;
    cin >> n; // 输入数据组数

    cin.ignore(); // 忽略换行符

    for (int i = 0; i < n; i++) {
        string input;
        getline(cin, input); // 输入字符串

        vector<int> folded = foldAndSum(input); // 折叠和求和
        for (int j = 0; j < folded.size(); j++) {
            folded[j] = reduceToOneDigit(folded[j]); // 数字缩位处理
        }

        // 输出结果
        for (int j = 0; j < folded.size(); j++) {
            cout << folded[j];
        }
        cout << endl;
    }

    return 0;
}
```

在修正后的代码中，我修改了 `foldAndSum` 函数，使其按照每六个字符一组的要求进行折叠和求和。首先计算字符串分组数和分组后的余数，然后按照分组数依次将字符的 ASCII 码值加到结果向量中。如果存在余数，则将余下的字符加到结果向量的前几位。

希望这次的修正能满足你的需求。非常抱歉之前的错误造成的困扰。如果你有任何其他问题，请随时提问。

### 大整数相加（求助GPT）

问题描述 :

I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B.

输入说明 :

The first line of the input contains an integer T(1<=T<=20) which means the number of test cases. Then T lines follow, each line consists of two positive integers, A and B. Notice that the integers are very large, that means you should not process them by using 32-bit integer. You may assume the length of each integer will not exceed 1000.

输出说明 :

For each test case, you should output two lines. The first line is "Case #:", # means the number of the test case. The second line is the an equation "A + B = Sum", Sum means the result of A + B. Note there are some spaces int the equation. Output a blank line between two test cases.

输入范例 :

```
2
1 2
112233445566778899 998877665544332211
```

输出范例 :

```
Case 1:
1 + 2 = 3

Case 2:
112233445566778899 + 998877665544332211 = 1111111111111111110
```

根据题目描述，下面是一个完成该任务的C++程序：

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

string addBigIntegers(const string& num1, const string& num2) {
    string result; // 存储相加结果的字符串
    int carry = 0; // 进位

    int i = num1.length() - 1;
    int j = num2.length() - 1;

    while (i >= 0 || j >= 0 || carry > 0) {
        int digit1 = (i >= 0) ? num1[i] - '0' : 0;
        int digit2 = (j >= 0) ? num2[j] - '0' : 0;

        int sum = digit1 + digit2 + carry;
        carry = sum / 10;
        sum = sum % 10;

        result.push_back(sum + '0');

        i--;
        j--;
    }

    reverse(result.begin(), result.end());

    return result;
}

int main() {
    int t;
    cin >> t; // 输入测试用例个数
    bool IsFirst=true;

    for (int caseNum = 1; caseNum <= t; caseNum++) {
        if(!IsFirst)
            cout << endl;
        string num1, num2;
        cin >> num1 >> num2; // 输入两个大整数

        string sum = addBigIntegers(num1, num2); // 大整数相加

        // 输出结果
        cout << "Case " << caseNum << ":" << endl;
        cout << num1 << " + " << num2 << " = " << sum << endl;
        IsFirst=false;
    }

    return 0;
}
```

该程序首先定义了一个函数 `addBigIntegers`，用于实现大整数的相加操作。函数中使用了两个指针 `i` 和 `j` 分别指向两个大整数的末尾，然后从后往前逐位相加，同时考虑进位的情况。最后将得到的结果字符串反转后返回。

在主函数中，首先读取输入的测试用例个数 `t`。然后，通过循环读取每个测试用例的两个大整数，并调用 `addBigIntegers` 函数计算它们的和。最后，按照题目要求输出结果。

希望这个程序能满足你的需求。如果你有任何其他问题，请随时提问。












