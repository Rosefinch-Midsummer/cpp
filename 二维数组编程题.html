<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>二维数组编程题 - C++程序设计</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded "><a href="程序的基本组成.html"><strong aria-hidden="true">2.</strong> 程序的基本组成</a></li><li class="chapter-item expanded "><a href="顺序结构程序设计.html"><strong aria-hidden="true">3.</strong> 顺序结构程序设计</a></li><li class="chapter-item expanded "><a href="顺序结构编程题.html"><strong aria-hidden="true">4.</strong> 顺序结构编程题</a></li><li class="chapter-item expanded "><a href="分支结构理论.html"><strong aria-hidden="true">5.</strong> 分支结构理论</a></li><li class="chapter-item expanded "><a href="分支结构程序设计.html"><strong aria-hidden="true">6.</strong> 分支结构程序设计</a></li><li class="chapter-item expanded "><a href="分支结构编程题.html"><strong aria-hidden="true">7.</strong> 分支结构编程题</a></li><li class="chapter-item expanded "><a href="循环结构理论.html"><strong aria-hidden="true">8.</strong> 循环结构理论</a></li><li class="chapter-item expanded "><a href="循环结构程序设计.html"><strong aria-hidden="true">9.</strong> 循环结构程序设计</a></li><li class="chapter-item expanded "><a href="循环结构编程题.html"><strong aria-hidden="true">10.</strong> 循环结构编程题</a></li><li class="chapter-item expanded "><a href="一维数组理论.html"><strong aria-hidden="true">11.</strong> 一维数组理论</a></li><li class="chapter-item expanded "><a href="一维数组程序设计.html"><strong aria-hidden="true">12.</strong> 一维数组程序设计</a></li><li class="chapter-item expanded "><a href="一维数组编程题.html"><strong aria-hidden="true">13.</strong> 一维数组编程题</a></li><li class="chapter-item expanded "><a href="查找及排序算法理论.html"><strong aria-hidden="true">14.</strong> 查找及排序算法理论</a></li><li class="chapter-item expanded "><a href="二维数组理论.html"><strong aria-hidden="true">15.</strong> 二维数组理论</a></li><li class="chapter-item expanded "><a href="二维数组编程题.html" class="active"><strong aria-hidden="true">16.</strong> 二维数组编程题</a></li><li class="chapter-item expanded "><a href="字符串理论.html"><strong aria-hidden="true">17.</strong> 字符串理论</a></li><li class="chapter-item expanded "><a href="vector和string程序设计.html"><strong aria-hidden="true">18.</strong> vector和string程序设计</a></li><li class="chapter-item expanded "><a href="字符串编程题.html"><strong aria-hidden="true">19.</strong> 字符串编程题</a></li><li class="chapter-item expanded "><a href="函数理论.html"><strong aria-hidden="true">20.</strong> 函数理论</a></li><li class="chapter-item expanded "><a href="函数编程题.html"><strong aria-hidden="true">21.</strong> 函数编程题</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++程序设计</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="二维数组编程题"><a class="header" href="#二维数组编程题">二维数组编程题</a></h1>
<ul>
<li><a href="#5-1%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E7%AE%80%E5%8D%95">5-1二维数组-&gt;简单</a>
<ul>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%B1%82%E5%90%84%E8%A1%8C%E5%9D%87%E5%80%BC">二维数组求各行均值</a></li>
<li><a href="#%E6%97%8B%E8%BD%AC%E5%8F%A5%E5%AD%90%E6%B1%82%E5%8A%A9gpt">旋转句子（求助GPT）</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97">特殊的矩阵运算</a></li>
<li><a href="#%E5%8F%91%E7%89%8C%E8%B0%83%E6%95%99gpt">发牌（调教GPT）</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E9%97%AE%E9%A2%98">矩阵问题</a></li>
</ul>
</li>
</ul>
<h2 id="5-1二维数组-简单"><a class="header" href="#5-1二维数组-简单">5-1二维数组-&gt;简单</a></h2>
<h3 id="二维数组求各行均值"><a class="header" href="#二维数组求各行均值">二维数组求各行均值</a></h3>
<p>问题描述 :</p>
<p>在3*4的二维数组a中，计算出各行的平均值，放在一个一维数组b中</p>
<p>输入说明 :</p>
<p>3*4的整数二维数组a的各个元素，按照三行四列的格式输入，整数之间以空格分隔。</p>
<p>输出说明 :</p>
<p>一维数组b的值，输出时，小数尾部的0不输出。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    int a[3][4];
    double b[3];
    for(int i=0;i&lt;3;i++)
    {
        double sum=0;
        for(int j=0;j&lt;4;j++)
        {
            cin&gt;&gt;a[i][j];
            sum+=a[i][j];
        }
        b[i]=sum/4.0;
    }
    for(int i=0;i&lt;3;i++)
    {
        if(i==0)
            cout&lt;&lt;b[i];
        else
            cout&lt;&lt;&quot; &quot;&lt;&lt;b[i];
    }
    cout&lt;&lt;&quot; &quot;;

    return 0;

}
</code></pre>
<h3 id="旋转句子求助gpt"><a class="header" href="#旋转句子求助gpt">旋转句子（求助GPT）</a></h3>
<p>问题描述 :</p>
<p>旋转句子，要求把输入的句子按顺时针旋转90度。即输入时的句子是从左至右和自上而下的显示方式，输出时变成从上到下和从右到左的显示方式。换句话说，就是输入的最后一句输出在最左边的列，输入的第一句输出在最右边的列。</p>
<p>输入说明 :</p>
<p>输入时最多100个句子（1句即一行），每句不超过100个字符。合法字符包括：换行符、空格、任何标点符、数字、小写和大写英文字母。</p>
<p>注意：一个句子可能不包含任何字符，即空行。</p>
<p>输出说明 :</p>
<p>按顺时针旋转90度后的那些句子。</p>
<p>注意：如果输入了n个句子，则输出就有n列，输出的最下面一行也有n列。可参见输出范例，每一行都有4个字符，最下面一行的第1、3、4个字符都是空格。</p>
<p>输入范例 :</p>
<pre><code>Rene Decartes once said,

&quot;I think, therefore I am.&quot;
Sample Input
</code></pre>
<p>输出范例 :</p>
<pre><code>S&quot; R
aI e
m  n
pt e
lh  
ei D
 n e
Ik c
n, a
p  r
ut t
th e
 e s
 r  
 e o
 f n
 o c
 r e
 e  
   s
 I a
   i
 a d
 m ,
 .  
 &quot;  
</code></pre>
<p>以下是一个解决该问题的 C++ 程序示例： </p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int MAXN = 105;

char sentence[MAXN][MAXN]; // 存储输入的句子
int len[MAXN]; // 每句话的长度
int max_len = 0; // 最长的句子长度

int main() {
    int n = 0; // 句子的数量
    while (fgets(sentence[n], MAXN, stdin)) { // 逐行读入句子
        len[n] = strlen(sentence[n]); // 记录句子长度
        if (sentence[n][len[n] - 1] == '\n') { // 判断该行句子的最后一个字符是否为换行符
            sentence[n][len[n] - 1] = '\0'; // 如果是，将其替换为字符串结束符
            len[n]--; // 更新句子长度
        }
        max_len = max(max_len, len[n]); // 更新最长的句子长度
        n++; // 句子数量加一
    }

    for (int i = 0; i &lt; max_len; i++) { // 按列输出旋转后的句子
        for (int j = n - 1; j &gt;= 0; j--) { // 按行输出每个字符
            if (i &gt;= len[j]) { // 如果该行的长度小于 i，则输出空格
                cout &lt;&lt; ' ';
            } else {
                cout &lt;&lt; sentence[j][i]; // 否则输出该行的第 i 个字符
            }
        }
        cout &lt;&lt; endl;
    }

    return 0;
}
</code></pre>
<p>程序首先定义了一个二维字符数组 <code>sentence</code> 用于存储输入的句子，以及一个一维整型数组 <code>len</code> 用于记录每个句子的长度，还定义了一个整型变量 <code>max_len</code> 用于记录最长的句子长度。</p>
<p>程序使用 <code>fgets</code> 逐行读入句子，记录每个句子的长度，并去掉每个句子的换行符。读入句子的过程中，程序同时更新 <code>max_len</code>。</p>
<p>读入句子后，程序使用两个循环，按列输出旋转后的句子。外层循环按列循环，内层循环按行循环，输出每个字符。如果该行的长度小于当前列的索引，则输出空格。否则，输出该行的第 i 个字符。</p>
<p>程序最后返回 0，结束运行。</p>
<p>如果程序多输出了一行空白字符，可能是因为输入的最后一行句子后面有一个额外的换行符。您可以尝试在读入每行句子后，判断该行句子的最后一个字符是否为换行符，如果是，则将其替换为字符串结束符 <code>\0</code>。</p>
<p>这个修改后的程序应该可以正确输出旋转后的句子，且不会多输出一行空白字符。</p>
<h3 id="特殊的矩阵运算"><a class="header" href="#特殊的矩阵运算">特殊的矩阵运算</a></h3>
<p>问题描述 :</p>
<p>输入m个方阵，方阵的元素是非0整数。对于n阶方阵A，明明现在需要进行特殊的运算。</p>
<p>方阵A有两条对角线：从左上角到右下角的对角线，元素为5 8 9，以及从左下角到右上角的对角线，元素为2 8 3。</p>
<p>求A两条对角线元素相乘的和（对角线积），<code>5*2+8*8+9*3=101；</code></p>
<p>求A两条对角线元素相除的和（对角线商）：<code>5/2+8/8+9/3=6</code>。   （注意：求对角线商时用整除，所以5/2的结果为2。）</p>
<p>输入说明 :</p>
<p>输入由多组数据组成。</p>
<p>1.     第一行有一个整数m，表示接下来有m组测试数据；</p>
<p>2.     第二行有一个整数n，表示n阶方阵，0 &lt; n &lt; 10；</p>
<p>3.     接下来的m行，每行有n*n个非0整数，整数间用空格分隔，每行对应一个矩阵。例如上述方阵A的输入格式为：5 1 3 5 8 7 2 6 9</p>
<p>输出说明 :</p>
<p>对每个矩阵，输出两个整数，表示对角线积和对角线商，用空格分隔。每个矩阵的输出结果占一行。</p>
<p>输入范例 :</p>
<pre><code>2
3
5 1 3 5 8 7 2 6 9
-2 3 2 1 2 49 22 1 2 
</code></pre>
<p>输出范例 :</p>
<pre><code>101 6
-36 2
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    int m,n;
    cin&gt;&gt;m;
    cin&gt;&gt;n;
    int arr[n][n];
    while(m--)
    {
        int sum_times=0;
        int sum_division=0;
        for(int j=0;j&lt;n;j++)
        {
            for(int t=0;t&lt;n;t++)
                cin&gt;&gt;arr[j][t];
        }
        for(int i=0;i&lt;n;i++)
        {
            sum_times+=arr[i][i]*arr[n-i-1][i];
            sum_division+=arr[i][i]/arr[n-i-1][i];

        }
        cout&lt;&lt;sum_times&lt;&lt;&quot; &quot;&lt;&lt;sum_division&lt;&lt;endl;
    }

    return 0;

}
</code></pre>
<h3 id="发牌调教gpt"><a class="header" href="#发牌调教gpt">发牌（调教GPT）</a></h3>
<p>问题描述 :</p>
<p>编制一个模拟发牌的程序。有编号为1，2，3，4四个人，将一付去掉大小怪的扑克按照如下顺序排列梅花c0-c12，方块d0-d12，红桃h0--h12，黑桃s0-s12，然后按照1，2，3，4四个人的顺序发牌，问最后每个人手上的牌有哪些。</p>
<p>输入说明 :</p>
<p>你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组输入数据由一行组成。每组数据包含一个在1到4之间的整数，代表四个人中的一个，在行首和行尾没有多余的空格。</p>
<p>输出说明 :</p>
<p>对每组测试数据，你的程序需要向标准输出设备（通常为启动该程序的终端）依次输出一组对应的答案。对于每组输入，输出那个人手上的牌。每组一行。每行包括13张牌，每张牌由牌的花色和牌的大小组成。牌的花色和牌的大小之间有一个空格，前后两张牌之间也有一个空格。其余数据前后没有多余的空格，两组数据之间也没有多余的空行。</p>
<p>输入范例 :</p>
<pre><code>1
2
</code></pre>
<p>输出范例 :</p>
<pre><code>c 0 c 4 c 8 c 12 d 3 d 7 d 11 h 2 h 6 h 10 s 1 s 5 s 9
c 1 c 5 c 9 d 0 d 4 d 8 d 12 h 3 h 7 h 11 s 2 s 6 s 10
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

int main()
{

    int n;

    string s1=&quot;c 0 c 4 c 8 c 12 d 3 d 7 d 11 h 2 h 6 h 10 s 1 s 5 s 9&quot;;

    string s2=&quot;c 1 c 5 c 9 d 0 d 4 d 8 d 12 h 3 h 7 h 11 s 2 s 6 s 10&quot;;

    string s3=&quot;c 2 c 6 c 10 d 1 d 5 d 9 h 0 h 4 h 8 h 12 s 3 s 7 s 11&quot;;
    string s4=&quot;c 3 c 7 c 11 d 2 d 6 d 10 h 1 h 5 h 9 s 0 s 4 s 8 s 12&quot;;

    while(cin&gt;&gt;n)
    {
        switch(n)
        {
        case 1:
            cout&lt;&lt;s1&lt;&lt;endl;
            break;
        case 2:
            cout&lt;&lt;s2&lt;&lt;endl;
            break;
        case 3:
            cout&lt;&lt;s3&lt;&lt;endl;
            break;
        case 4:
            cout&lt;&lt;s4&lt;&lt;endl;
            break;
        }
    }

    return 0;

}
</code></pre>
<p>以下是一个解决该问题的 C++ 程序示例：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int MAXN = 53;

char card[MAXN][3] = { // 存储所有的扑克牌
    &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;, &quot;c5&quot;, &quot;c6&quot;, &quot;c7&quot;, &quot;c8&quot;, &quot;c9&quot;, &quot;c10&quot;, &quot;c11&quot;, &quot;c12&quot;,
    &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;, &quot;d8&quot;, &quot;d9&quot;, &quot;d10&quot;, &quot;d11&quot;, &quot;d12&quot;,
    &quot;h0&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;h7&quot;, &quot;h8&quot;, &quot;h9&quot;, &quot;h10&quot;, &quot;h11&quot;, &quot;h12&quot;,
    &quot;s0&quot;, &quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;, &quot;s8&quot;, &quot;s9&quot;, &quot;s10&quot;, &quot;s11&quot;, &quot;s12&quot;
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin &gt;&gt; player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i &lt; 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i &lt; 13; i++) { // 输出当前玩家的手牌
            cout &lt;&lt; card[cards[i]] &lt;&lt; &quot; &quot;; // 根据牌的索引输出牌的花色和大小
        }
        cout &lt;&lt; endl; // 输出换行符
    }

    return 0;
}
</code></pre>
<p>程序首先定义了一个二维字符数组 <code>card</code>，用于存储所有的扑克牌。程序使用一个整型变量 <code>player</code> 循环读入每个玩家的编号，然后按照顺序发牌，并将当前玩家手中的牌存储到一个整型数组 <code>cards</code> 中。</p>
<p>程序使用一个循环输出当前玩家的手牌，即输出 <code>cards</code> 中存储的牌的花色和大小。其中，牌的花色和大小存储在 <code>card</code> 数组中，可以通过牌的索引在 <code>card</code> 中查找。</p>
<p>程序最后返回 0，结束运行。</p>
<p>上面的程序编译错误。</p>
<p><code>error: initializer-string for array of chars is too long [-fpermissive]</code></p>
<p>字符数组初始化时，数组大小一定要大于字符串长度+1，否则编译错误。字符串数组最后有<code>\0</code></p>
<p>根据您的反馈，程序报错 <code>&quot;error: initializer-string for array of chars is too long [-fpermissive]&quot;</code>，这通常是因为使用了 C++11 或更高版本的编译器，导致编译器对标准的限制更加严格，不允许使用初始化字符串的长度超过编译器规定的最大长度。</p>
<p>为了解决这个问题，您可以将 <code>card</code> 数组定义为一个二维字符指针，然后将每张扑克牌的字符串存储在堆中，并将其指针存储到 <code>card</code> 数组中。</p>
<p>以下是修改后的 C++ 程序示例：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int MAXN = 53;

char* card[MAXN] = { // 存储所有的扑克牌
    &quot;c0&quot;, &quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;, &quot;c4&quot;, &quot;c5&quot;, &quot;c6&quot;, &quot;c7&quot;, &quot;c8&quot;, &quot;c9&quot;, &quot;c10&quot;, &quot;c11&quot;, &quot;c12&quot;,
    &quot;d0&quot;, &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;, &quot;d6&quot;, &quot;d7&quot;, &quot;d8&quot;, &quot;d9&quot;, &quot;d10&quot;, &quot;d11&quot;, &quot;d12&quot;,
    &quot;h0&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;, &quot;h5&quot;, &quot;h6&quot;, &quot;h7&quot;, &quot;h8&quot;, &quot;h9&quot;, &quot;h10&quot;, &quot;h11&quot;, &quot;h12&quot;,
    &quot;s0&quot;, &quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;, &quot;s4&quot;, &quot;s5&quot;, &quot;s6&quot;, &quot;s7&quot;, &quot;s8&quot;, &quot;s9&quot;, &quot;s10&quot;, &quot;s11&quot;, &quot;s12&quot;
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin &gt;&gt; player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i &lt; 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i &lt; 13; i++) { // 输出当前玩家的手牌
            cout &lt;&lt; card[cards[i]] &lt;&lt; &quot; &quot;; // 根据牌的索引输出牌的花色和大小
        }
        cout &lt;&lt; endl; // 输出换行符
    }

    return 0;
}
</code></pre>
<p>这个修改后的程序应该可以正常编译和运行，且正确输出每个玩家的手牌。</p>
<p>PE：测试数据结果正确，但空格、换行、tab等字符不正确。</p>
<p>具体信息如下:</p>
<pre><code>测试用例 459结果为 PE:
测试用例 460结果为 PE:
测试用例 461结果为 PE:
测试用例 462结果为 PE:
</code></pre>
<p>非常感谢您的反馈。根据题目的输出要求，程序需要在输出每个玩家的手牌时，每张牌之间有一个空格，每组测试数据输出后需要换行。</p>
<p>以下是修改后的 C++ 程序示例：</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int MAXN = 53;

char* card[MAXN] = { // 存储所有的扑克牌
    &quot;c 0&quot;, &quot;c 1&quot;, &quot;c 2&quot;, &quot;c 3&quot;, &quot;c 4&quot;, &quot;c 5&quot;, &quot;c 6&quot;, &quot;c 7&quot;, &quot;c 8&quot;, &quot;c 9&quot;, &quot;c 10&quot;, &quot;c 11&quot;, &quot;c 12&quot;,
    &quot;d 0&quot;, &quot;d 1&quot;, &quot;d 2&quot;, &quot;d 3&quot;, &quot;d 4&quot;, &quot;d 5&quot;, &quot;d 6&quot;, &quot;d 7&quot;, &quot;d 8&quot;, &quot;d 9&quot;, &quot;d 10&quot;, &quot;d 11&quot;, &quot;d 12&quot;,
    &quot;h 0&quot;, &quot;h 1&quot;, &quot;h 2&quot;, &quot;h 3&quot;, &quot;h 4&quot;, &quot;h 5&quot;, &quot;h 6&quot;, &quot;h 7&quot;, &quot;h 8&quot;, &quot;h 9&quot;, &quot;h 10&quot;, &quot;h 11&quot;, &quot;h 12&quot;,
    &quot;s 0&quot;, &quot;s 1&quot;, &quot;s 2&quot;, &quot;s 3&quot;, &quot;s 4&quot;, &quot;s 5&quot;, &quot;s 6&quot;, &quot;s 7&quot;, &quot;s 8&quot;, &quot;s 9&quot;, &quot;s 10&quot;, &quot;s 11&quot;, &quot;s 12&quot;
};

int main() {
    int player; // 存储当前发牌的玩家编号
    while (cin &gt;&gt; player) { // 循环读入每个玩家的编号
        int cards[13]; // 存储当前玩家手中的牌
        memset(cards, 0, sizeof(cards)); // 初始化为0

        for (int i = 0; i &lt; 52; i++) { // 按顺序发牌
            if (i % 4 + 1 == player) { // 如果轮到当前玩家发牌
                cards[i / 4] = i; // 将当前牌加入当前玩家的手牌中
            }
        }

        for (int i = 0; i &lt; 13; i++) { // 输出当前玩家的手牌
            cout &lt;&lt; card[cards[i]];
            if (i != 12) { // 如果不是最后一张牌，则输出一个空格
                cout &lt;&lt; &quot; &quot;;
            }
        }
        cout &lt;&lt; endl; // 输出换行符
    }

    return 0;
}
</code></pre>
<p>这个修改后的程序会按照题目的输出要求输出每个玩家的手牌。每张牌的花色和大小之间有一个空格，牌与牌之间也有一个空格，每组测试数据的输出结果后面跟着一个换行符。</p>
<h3 id="矩阵问题"><a class="header" href="#矩阵问题">矩阵问题</a></h3>
<p>问题描述 :</p>
<p>从键盘上输入一个整数N，按以下规律输出一个(2N+1)*(2N+1)的矩阵：</p>
<p>对角线的值为1，</p>
<p>上半三角区域值为2，</p>
<p>下半三角区域值为3，</p>
<p>左半三角区域的值为4，</p>
<p>右半三角区域的值为5。</p>
<p>输入说明 :</p>
<p>你的程序需要从标准输入设备（通常为键盘）中读入多组测试数据。每组测试数据数据占一行，大于零，小于等于8。</p>
<p>输出说明 :</p>
<p>对每组测试数据，你的程序需要向标准输出文件（通常为启动该程序的终端）依次输出符合要求的矩阵，每行数据与数据之间以空格分隔，在行首和行尾不要输出多余的空格。在所有数据前后，以及两组数据之间不要输出多余的空行。</p>
<p>输入范例 :</p>
<pre><code>1
8
</code></pre>
<p>输出范例 :</p>
<pre><code>1 2 1
4 1 5
1 3 1
1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 1
4 1 2 2 2 2 2 2 2 2 2 2 2 2 2 1 5
4 4 1 2 2 2 2 2 2 2 2 2 2 2 1 5 5
4 4 4 1 2 2 2 2 2 2 2 2 2 1 5 5 5
4 4 4 4 1 2 2 2 2 2 2 2 1 5 5 5 5
4 4 4 4 4 1 2 2 2 2 2 1 5 5 5 5 5
4 4 4 4 4 4 1 2 2 2 1 5 5 5 5 5 5
4 4 4 4 4 4 4 1 2 1 5 5 5 5 5 5 5
4 4 4 4 4 4 4 4 1 5 5 5 5 5 5 5 5
4 4 4 4 4 4 4 1 3 1 5 5 5 5 5 5 5
4 4 4 4 4 4 1 3 3 3 1 5 5 5 5 5 5
4 4 4 4 4 1 3 3 3 3 3 1 5 5 5 5 5
4 4 4 4 1 3 3 3 3 3 3 3 1 5 5 5 5
4 4 4 1 3 3 3 3 3 3 3 3 3 1 5 5 5
4 4 1 3 3 3 3 3 3 3 3 3 3 3 1 5 5
4 1 3 3 3 3 3 3 3 3 3 3 3 3 3 1 5
1 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 1
</code></pre>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

int main()
{

    int N;

    while(cin&gt;&gt;N)
    {
        int a[2*N+1][2*N+1];
        for(int i=0;i&lt;2*N+1;i++)
        {
            for(int j=0;j&lt;2*N+1;j++)
            {
                if((i==j)||(i+j==2*N)) a[i][j]=1;
                else if(((i+j)&lt;=2*N)&amp;&amp;(i&lt;=N)&amp;&amp;(i&lt;j)) a[i][j]=2;
                else if(((i+j)&gt;=2*N+1)&amp;&amp;(i&gt;N)&amp;&amp;(i&gt;j)) a[i][j]=3;
                else if(((i+j)&lt;=2*N-1)&amp;&amp;(j&lt;=N)&amp;&amp;(i&gt;j)) a[i][j]=4;
                else a[i][j]=5;
            }
        }
        for(int i=0;i&lt;2*N+1;i++)
        {
            for(int j=0;j&lt;2*N+1;j++)
            {
                if(j&gt;0) cout&lt;&lt;&quot; &quot;;
                cout&lt;&lt;a[i][j];
            }
            cout&lt;&lt;endl;
        }
    }

    return 0;

}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="二维数组理论.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="字符串理论.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="二维数组理论.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="字符串理论.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
